<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app\jam\jqueryui\jquery-ui-1.8.23.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/data.html">data</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: app\jam\jqueryui\jquery-ui-1.8.23.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*! jQuery UI - v1.8.23 - 2012-08-15
* https:&#x2F;&#x2F;github.com&#x2F;jquery&#x2F;jquery-ui
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.effects.core.js, jquery.effects.blind.js, jquery.effects.bounce.js, jquery.effects.clip.js, jquery.effects.drop.js, jquery.effects.explode.js, jquery.effects.fade.js, jquery.effects.fold.js, jquery.effects.highlight.js, jquery.effects.pulsate.js, jquery.effects.scale.js, jquery.effects.shake.js, jquery.effects.slide.js, jquery.effects.transfer.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.tabs.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT *&#x2F;

(function( $, undefined ) {

&#x2F;&#x2F; prevent duplicate loading
&#x2F;&#x2F; this is only a problem because we proxy existing functions
&#x2F;&#x2F; and we don&#x27;t want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
	return;
}

$.extend( $.ui, {
	version: &quot;1.8.23&quot;,

	keyCode: {
		ALT: 18,
		BACKSPACE: 8,
		CAPS_LOCK: 20,
		COMMA: 188,
		COMMAND: 91,
		COMMAND_LEFT: 91, &#x2F;&#x2F; COMMAND
		COMMAND_RIGHT: 93,
		CONTROL: 17,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		INSERT: 45,
		LEFT: 37,
		MENU: 93, &#x2F;&#x2F; COMMAND_RIGHT
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SHIFT: 16,
		SPACE: 32,
		TAB: 9,
		UP: 38,
		WINDOWS: 91 &#x2F;&#x2F; COMMAND
	}
});

&#x2F;&#x2F; plugins
$.fn.extend({
	propAttr: $.fn.prop || $.fn.attr,

	_focus: $.fn.focus,
	focus: function( delay, fn ) {
		return typeof delay === &quot;number&quot; ?
			this.each(function() {
				var elem = this;
				setTimeout(function() {
					$( elem ).focus();
					if ( fn ) {
						fn.call( elem );
					}
				}, delay );
			}) :
			this._focus.apply( this, arguments );
	},

	scrollParent: function() {
		var scrollParent;
		if (($.browser.msie &amp;&amp; (&#x2F;(static|relative)&#x2F;).test(this.css(&#x27;position&#x27;))) || (&#x2F;absolute&#x2F;).test(this.css(&#x27;position&#x27;))) {
			scrollParent = this.parents().filter(function() {
				return (&#x2F;(relative|absolute|fixed)&#x2F;).test($.curCSS(this,&#x27;position&#x27;,1)) &amp;&amp; (&#x2F;(auto|scroll)&#x2F;).test($.curCSS(this,&#x27;overflow&#x27;,1)+$.curCSS(this,&#x27;overflow-y&#x27;,1)+$.curCSS(this,&#x27;overflow-x&#x27;,1));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (&#x2F;(auto|scroll)&#x2F;).test($.curCSS(this,&#x27;overflow&#x27;,1)+$.curCSS(this,&#x27;overflow-y&#x27;,1)+$.curCSS(this,&#x27;overflow-x&#x27;,1));
			}).eq(0);
		}

		return (&#x2F;fixed&#x2F;).test(this.css(&#x27;position&#x27;)) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( &quot;zIndex&quot;, zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length &amp;&amp; elem[ 0 ] !== document ) {
				&#x2F;&#x2F; Ignore z-index if position is set to a value where z-index is ignored by the browser
				&#x2F;&#x2F; This makes behavior of this function consistent across browsers
				&#x2F;&#x2F; WebKit always returns auto if the element is positioned
				position = elem.css( &quot;position&quot; );
				if ( position === &quot;absolute&quot; || position === &quot;relative&quot; || position === &quot;fixed&quot; ) {
					&#x2F;&#x2F; IE returns 0 when zIndex is not specified
					&#x2F;&#x2F; other browsers return a string
					&#x2F;&#x2F; we ignore the case of nested elements with an explicit value of 0
					&#x2F;&#x2F; &lt;div style=&quot;z-index: -10;&quot;&gt;&lt;div style=&quot;z-index: 0;&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;
					value = parseInt( elem.css( &quot;zIndex&quot; ), 10 );
					if ( !isNaN( value ) &amp;&amp; value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? &quot;selectstart&quot; : &quot;mousedown&quot; ) +
			&quot;.ui-disableSelection&quot;, function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( &quot;.ui-disableSelection&quot; );
	}
});

&#x2F;&#x2F; support: jQuery &lt;1.8
if ( !$( &quot;&lt;a&gt;&quot; ).outerWidth( 1 ).jquery ) {
	$.each( [ &quot;Width&quot;, &quot;Height&quot; ], function( i, name ) {
		var side = name === &quot;Width&quot; ? [ &quot;Left&quot;, &quot;Right&quot; ] : [ &quot;Top&quot;, &quot;Bottom&quot; ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.curCSS( elem, &quot;padding&quot; + this, true) ) || 0;
				if ( border ) {
					size -= parseFloat( $.curCSS( elem, &quot;border&quot; + this + &quot;Width&quot;, true) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.curCSS( elem, &quot;margin&quot; + this, true) ) || 0;
				}
			});
			return size;
		}

		$.fn[ &quot;inner&quot; + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ &quot;inner&quot; + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + &quot;px&quot; );
			});
		};

		$.fn[ &quot;outer&quot; + name] = function( size, margin ) {
			if ( typeof size !== &quot;number&quot; ) {
				return orig[ &quot;outer&quot; + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + &quot;px&quot; );
			});
		};
	});
}

&#x2F;&#x2F; selectors
function focusable( element, isTabIndexNotNaN ) {
	var nodeName = element.nodeName.toLowerCase();
	if ( &quot;area&quot; === nodeName ) {
		var map = element.parentNode,
			mapName = map.name,
			img;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== &quot;map&quot; ) {
			return false;
		}
		img = $( &quot;img[usemap=#&quot; + mapName + &quot;]&quot; )[0];
		return !!img &amp;&amp; visible( img );
	}
	return ( &#x2F;input|select|textarea|button|object&#x2F;.test( nodeName )
		? !element.disabled
		: &quot;a&quot; == nodeName
			? element.href || isTabIndexNotNaN
			: isTabIndexNotNaN)
		&#x2F;&#x2F; the element and all of its ancestors must be visible
		&amp;&amp; visible( element );
}

function visible( element ) {
	return !$( element ).parents().andSelf().filter(function() {
		return $.curCSS( this, &quot;visibility&quot; ) === &quot;hidden&quot; ||
			$.expr.filters.hidden( this );
	}).length;
}

$.extend( $.expr[ &quot;:&quot; ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		&#x2F;&#x2F; support: jQuery &lt;1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, &quot;tabindex&quot; ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, &quot;tabindex&quot; ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex &gt;= 0 ) &amp;&amp; focusable( element, !isTabIndexNaN );
	}
});

&#x2F;&#x2F; support
$(function() {
	var body = document.body,
		div = body.appendChild( div = document.createElement( &quot;div&quot; ) );

	&#x2F;&#x2F; access offsetHeight before setting the style to prevent a layout bug
	&#x2F;&#x2F; in IE 9 which causes the elemnt to continue to take up space even
	&#x2F;&#x2F; after it is removed from the DOM (#8026)
	div.offsetHeight;

	$.extend( div.style, {
		minHeight: &quot;100px&quot;,
		height: &quot;auto&quot;,
		padding: 0,
		borderWidth: 0
	});

	$.support.minHeight = div.offsetHeight === 100;
	$.support.selectstart = &quot;onselectstart&quot; in div;

	&#x2F;&#x2F; set display to none to avoid a layout bug in IE
	&#x2F;&#x2F; http:&#x2F;&#x2F;dev.jquery.com&#x2F;ticket&#x2F;4014
	body.removeChild( div ).style.display = &quot;none&quot;;
});

&#x2F;&#x2F; jQuery &lt;1.4.3 uses curCSS, in 1.4.3 - 1.7.2 curCSS = css, 1.8+ only has css
if ( !$.curCSS ) {
	$.curCSS = $.css;
}





&#x2F;&#x2F; deprecated
$.extend( $.ui, {
	&#x2F;&#x2F; $.ui.plugin is deprecated.  Use the proxy pattern instead.
	plugin: {
		add: function( module, option, set ) {
			var proto = $.ui[ module ].prototype;
			for ( var i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode ) {
				return;
			}
	
			for ( var i = 0; i &lt; set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},
	
	&#x2F;&#x2F; will be deprecated when we switch to jQuery 1.4 - use jQuery.contains()
	contains: function( a, b ) {
		return document.compareDocumentPosition ?
			a.compareDocumentPosition( b ) &amp; 16 :
			a !== b &amp;&amp; a.contains( b );
	},
	
	&#x2F;&#x2F; only used by resizable
	hasScroll: function( el, a ) {
	
		&#x2F;&#x2F;If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( &quot;overflow&quot; ) === &quot;hidden&quot;) {
			return false;
		}
	
		var scroll = ( a &amp;&amp; a === &quot;left&quot; ) ? &quot;scrollLeft&quot; : &quot;scrollTop&quot;,
			has = false;
	
		if ( el[ scroll ] &gt; 0 ) {
			return true;
		}
	
		&#x2F;&#x2F; TODO: determine which cases actually cause this to happen
		&#x2F;&#x2F; if the element doesn&#x27;t have the scroll set, see if it&#x27;s possible to
		&#x2F;&#x2F; set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] &gt; 0 );
		el[ scroll ] = 0;
		return has;
	},
	
	&#x2F;&#x2F; these are odd functions, fix the API or move into individual plugins
	isOverAxis: function( x, reference, size ) {
		&#x2F;&#x2F;Determines when x coordinate is over &quot;b&quot; element axis
		return ( x &gt; reference ) &amp;&amp; ( x &lt; ( reference + size ) );
	},
	isOver: function( y, x, top, left, height, width ) {
		&#x2F;&#x2F;Determines when x, y coordinates is over &quot;b&quot; element
		return $.ui.isOverAxis( y, top, height ) &amp;&amp; $.ui.isOverAxis( x, left, width );
	}
});

})( jQuery );

(function( $, undefined ) {

&#x2F;&#x2F; jQuery 1.4+
if ( $.cleanData ) {
	var _cleanData = $.cleanData;
	$.cleanData = function( elems ) {
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			try {
				$( elem ).triggerHandler( &quot;remove&quot; );
			&#x2F;&#x2F; http:&#x2F;&#x2F;bugs.jquery.com&#x2F;ticket&#x2F;8235
			} catch( e ) {}
		}
		_cleanData( elems );
	};
} else {
	var _remove = $.fn.remove;
	$.fn.remove = function( selector, keepData ) {
		return this.each(function() {
			if ( !keepData ) {
				if ( !selector || $.filter( selector, [ this ] ).length ) {
					$( &quot;*&quot;, this ).add( [ this ] ).each(function() {
						try {
							$( this ).triggerHandler( &quot;remove&quot; );
						&#x2F;&#x2F; http:&#x2F;&#x2F;bugs.jquery.com&#x2F;ticket&#x2F;8235
						} catch( e ) {}
					});
				}
			}
			return _remove.call( $(this), selector, keepData );
		});
	};
}

$.widget = function( name, base, prototype ) {
	var namespace = name.split( &quot;.&quot; )[ 0 ],
		fullName;
	name = name.split( &quot;.&quot; )[ 1 ];
	fullName = namespace + &quot;-&quot; + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	&#x2F;&#x2F; create selector for plugin
	$.expr[ &quot;:&quot; ][ fullName ] = function( elem ) {
		return !!$.data( elem, name );
	};

	$[ namespace ] = $[ namespace ] || {};
	$[ namespace ][ name ] = function( options, element ) {
		&#x2F;&#x2F; allow instantiation without initializing for simple inheritance
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	var basePrototype = new base();
	&#x2F;&#x2F; we need to make the options hash a property directly on the new instance
	&#x2F;&#x2F; otherwise we&#x27;ll modify the options hash on the prototype that we&#x27;re
	&#x2F;&#x2F; inheriting from
&#x2F;&#x2F;	$.each( basePrototype, function( key, val ) {
&#x2F;&#x2F;		if ( $.isPlainObject(val) ) {
&#x2F;&#x2F;			basePrototype[ key ] = $.extend( {}, val );
&#x2F;&#x2F;		}
&#x2F;&#x2F;	});
	basePrototype.options = $.extend( true, {}, basePrototype.options );
	$[ namespace ][ name ].prototype = $.extend( true, basePrototype, {
		namespace: namespace,
		widgetName: name,
		widgetEventPrefix: $[ namespace ][ name ].prototype.widgetEventPrefix || name,
		widgetBaseClass: fullName
	}, prototype );

	$.widget.bridge( name, $[ namespace ][ name ] );
};

$.widget.bridge = function( name, object ) {
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === &quot;string&quot;,
			args = Array.prototype.slice.call( arguments, 1 ),
			returnValue = this;

		&#x2F;&#x2F; allow multiple hashes to be passed on init
		options = !isMethodCall &amp;&amp; args.length ?
			$.extend.apply( null, [ true, options ].concat(args) ) :
			options;

		&#x2F;&#x2F; prevent calls to internal methods
		if ( isMethodCall &amp;&amp; options.charAt( 0 ) === &quot;_&quot; ) {
			return returnValue;
		}

		if ( isMethodCall ) {
			this.each(function() {
				var instance = $.data( this, name ),
					methodValue = instance &amp;&amp; $.isFunction( instance[options] ) ?
						instance[ options ].apply( instance, args ) :
						instance;
				&#x2F;&#x2F; TODO: add this back in 1.9 and use $.error() (see #5972)
&#x2F;&#x2F;				if ( !instance ) {
&#x2F;&#x2F;					throw &quot;cannot call methods on &quot; + name + &quot; prior to initialization; &quot; +
&#x2F;&#x2F;						&quot;attempted to call method &#x27;&quot; + options + &quot;&#x27;&quot;;
&#x2F;&#x2F;				}
&#x2F;&#x2F;				if ( !$.isFunction( instance[options] ) ) {
&#x2F;&#x2F;					throw &quot;no such method &#x27;&quot; + options + &quot;&#x27; for &quot; + name + &quot; widget instance&quot;;
&#x2F;&#x2F;				}
&#x2F;&#x2F;				var methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance &amp;&amp; methodValue !== undefined ) {
					returnValue = methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, name );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, name, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( options, element ) {
	&#x2F;&#x2F; allow instantiation without initializing for simple inheritance
	if ( arguments.length ) {
		this._createWidget( options, element );
	}
};

$.Widget.prototype = {
	widgetName: &quot;widget&quot;,
	widgetEventPrefix: &quot;&quot;,
	options: {
		disabled: false
	},
	_createWidget: function( options, element ) {
		&#x2F;&#x2F; $.widget.bridge stores the plugin instance, but we do it anyway
		&#x2F;&#x2F; so that it&#x27;s stored even before the _create function runs
		$.data( element, this.widgetName, this );
		this.element = $( element );
		this.options = $.extend( true, {},
			this.options,
			this._getCreateOptions(),
			options );

		var self = this;
		this.element.bind( &quot;remove.&quot; + this.widgetName, function() {
			self.destroy();
		});

		this._create();
		this._trigger( &quot;create&quot; );
		this._init();
	},
	_getCreateOptions: function() {
		return $.metadata &amp;&amp; $.metadata.get( this.element[0] )[ this.widgetName ];
	},
	_create: function() {},
	_init: function() {},

	destroy: function() {
		this.element
			.unbind( &quot;.&quot; + this.widgetName )
			.removeData( this.widgetName );
		this.widget()
			.unbind( &quot;.&quot; + this.widgetName )
			.removeAttr( &quot;aria-disabled&quot; )
			.removeClass(
				this.widgetBaseClass + &quot;-disabled &quot; +
				&quot;ui-state-disabled&quot; );
	},

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;

		if ( arguments.length === 0 ) {
			&#x2F;&#x2F; don&#x27;t return a reference to the internal hash
			return $.extend( {}, this.options );
		}

		if  (typeof key === &quot;string&quot; ) {
			if ( value === undefined ) {
				return this.options[ key ];
			}
			options = {};
			options[ key ] = value;
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var self = this;
		$.each( options, function( key, value ) {
			self._setOption( key, value );
		});

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === &quot;disabled&quot; ) {
			this.widget()
				[ value ? &quot;addClass&quot; : &quot;removeClass&quot;](
					this.widgetBaseClass + &quot;-disabled&quot; + &quot; &quot; +
					&quot;ui-state-disabled&quot; )
				.attr( &quot;aria-disabled&quot;, value );
		}

		return this;
	},

	enable: function() {
		return this._setOption( &quot;disabled&quot;, false );
	},
	disable: function() {
		return this._setOption( &quot;disabled&quot;, true );
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		&#x2F;&#x2F; the original event may come from any element
		&#x2F;&#x2F; so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		&#x2F;&#x2F; copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );

		return !( $.isFunction(callback) &amp;&amp;
			callback.call( this.element[0], event, data ) === false ||
			event.isDefaultPrevented() );
	}
};

})( jQuery );

(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function( e ) {
	mouseHandled = false;
});

$.widget(&quot;ui.mouse&quot;, {
	options: {
		cancel: &#x27;:input,option&#x27;,
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var self = this;

		this.element
			.bind(&#x27;mousedown.&#x27;+this.widgetName, function(event) {
				return self._mouseDown(event);
			})
			.bind(&#x27;click.&#x27;+this.widgetName, function(event) {
				if (true === $.data(event.target, self.widgetName + &#x27;.preventClickEvent&#x27;)) {
				    $.removeData(event.target, self.widgetName + &#x27;.preventClickEvent&#x27;);
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	&#x2F;&#x2F; TODO: make sure destroying one instance of mouse doesn&#x27;t mess with
	&#x2F;&#x2F; other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind(&#x27;.&#x27;+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind(&#x27;mousemove.&#x27;+this.widgetName, this._mouseMoveDelegate)
				.unbind(&#x27;mouseup.&#x27;+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		&#x2F;&#x2F; don&#x27;t let more than one widget handle mouseStart
		if( mouseHandled ) { return };

		&#x2F;&#x2F; we may have missed mouseup (out of window)
		(this._mouseStarted &amp;&amp; this._mouseUp(event));

		this._mouseDownEvent = event;

		var self = this,
			btnIsLeft = (event.which == 1),
			&#x2F;&#x2F; event.target.nodeName works around a bug in IE 8 with
			&#x2F;&#x2F; disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel == &quot;string&quot; &amp;&amp; event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				self.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) &amp;&amp; this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		&#x2F;&#x2F; Click event may never have fired (Gecko &amp; Opera)
		if (true === $.data(event.target, this.widgetName + &#x27;.preventClickEvent&#x27;)) {
			$.removeData(event.target, this.widgetName + &#x27;.preventClickEvent&#x27;);
		}

		&#x2F;&#x2F; these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return self._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return self._mouseUp(event);
		};
		$(document)
			.bind(&#x27;mousemove.&#x27;+this.widgetName, this._mouseMoveDelegate)
			.bind(&#x27;mouseup.&#x27;+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();
		
		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		&#x2F;&#x2F; IE mouseup check - mouseup happened when mouse was out of window
		if ($.browser.msie &amp;&amp; !(document.documentMode &gt;= 9) &amp;&amp; !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) &amp;&amp; this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind(&#x27;mousemove.&#x27;+this.widgetName, this._mouseMoveDelegate)
			.unbind(&#x27;mouseup.&#x27;+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target == this._mouseDownEvent.target) {
			    $.data(event.target, this.widgetName + &#x27;.preventClickEvent&#x27;, true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) &gt;= this.options.distance
		);
	},

	_mouseDelayMet: function(event) {
		return this.mouseDelayMet;
	},

	&#x2F;&#x2F; These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(event) {},
	_mouseDrag: function(event) {},
	_mouseStop: function(event) {},
	_mouseCapture: function(event) { return true; }
});

})(jQuery);

(function( $, undefined ) {

$.widget(&quot;ui.draggable&quot;, $.ui.mouse, {
	widgetEventPrefix: &quot;drag&quot;,
	options: {
		addClasses: true,
		appendTo: &quot;parent&quot;,
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: &quot;auto&quot;,
		cursorAt: false,
		grid: false,
		handle: false,
		helper: &quot;original&quot;,
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: &quot;default&quot;,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: &quot;both&quot;,
		snapTolerance: 20,
		stack: false,
		zIndex: false
	},
	_create: function() {

		if (this.options.helper == &#x27;original&#x27; &amp;&amp; !(&#x2F;^(?:r|a|f)&#x2F;).test(this.element.css(&quot;position&quot;)))
			this.element[0].style.position = &#x27;relative&#x27;;

		(this.options.addClasses &amp;&amp; this.element.addClass(&quot;ui-draggable&quot;));
		(this.options.disabled &amp;&amp; this.element.addClass(&quot;ui-draggable-disabled&quot;));

		this._mouseInit();

	},

	destroy: function() {
		if(!this.element.data(&#x27;draggable&#x27;)) return;
		this.element
			.removeData(&quot;draggable&quot;)
			.unbind(&quot;.draggable&quot;)
			.removeClass(&quot;ui-draggable&quot;
				+ &quot; ui-draggable-dragging&quot;
				+ &quot; ui-draggable-disabled&quot;);
		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function(event) {

		var o = this.options;

		&#x2F;&#x2F; among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).is(&#x27;.ui-resizable-handle&#x27;))
			return false;

		&#x2F;&#x2F;Quit if we&#x27;re not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle)
			return false;
		
		if ( o.iframeFix ) {
			$(o.iframeFix === true ? &quot;iframe&quot; : o.iframeFix).each(function() {
				$(&#x27;&lt;div class=&quot;ui-draggable-iframeFix&quot; style=&quot;background: #fff;&quot;&gt;&lt;&#x2F;div&gt;&#x27;)
				.css({
					width: this.offsetWidth+&quot;px&quot;, height: this.offsetHeight+&quot;px&quot;,
					position: &quot;absolute&quot;, opacity: &quot;0.001&quot;, zIndex: 1000
				})
				.css($(this).offset())
				.appendTo(&quot;body&quot;);
			});
		}

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		&#x2F;&#x2F;Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass(&quot;ui-draggable-dragging&quot;);

		&#x2F;&#x2F;Cache the helper size
		this._cacheHelperProportions();

		&#x2F;&#x2F;If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		&#x2F;*
		 * - Position generation -
		 * This block generates everything position related - it&#x27;s the core of draggables.
		 *&#x2F;

		&#x2F;&#x2F;Cache the margins of the original element
		this._cacheMargins();

		&#x2F;&#x2F;Store the helper&#x27;s css position
		this.cssPosition = this.helper.css(&quot;position&quot;);
		this.scrollParent = this.helper.scrollParent();

		&#x2F;&#x2F;The element&#x27;s absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { &#x2F;&#x2F;Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() &#x2F;&#x2F;This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		&#x2F;&#x2F;Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		&#x2F;&#x2F;Adjust the mouse offset relative to the helper if &#x27;cursorAt&#x27; is supplied
		(o.cursorAt &amp;&amp; this._adjustOffsetFromHelper(o.cursorAt));

		&#x2F;&#x2F;Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		&#x2F;&#x2F;Trigger event + callbacks
		if(this._trigger(&quot;start&quot;, event) === false) {
			this._clear();
			return false;
		}

		&#x2F;&#x2F;Recache the helper size
		this._cacheHelperProportions();

		&#x2F;&#x2F;Prepare the droppable offsets
		if ($.ui.ddmanager &amp;&amp; !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		
		this._mouseDrag(event, true); &#x2F;&#x2F;Execute the drag once - this causes the helper not to be visible before getting its correct position
		
		&#x2F;&#x2F;If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) $.ui.ddmanager.dragStart(this, event);
		
		return true;
	},

	_mouseDrag: function(event, noPropagation) {

		&#x2F;&#x2F;Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);

		&#x2F;&#x2F;Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger(&#x27;drag&#x27;, event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis != &quot;y&quot;) this.helper[0].style.left = this.position.left+&#x27;px&#x27;;
		if(!this.options.axis || this.options.axis != &quot;x&quot;) this.helper[0].style.top = this.position.top+&#x27;px&#x27;;
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		return false;
	},

	_mouseStop: function(event) {

		&#x2F;&#x2F;If we are using droppables, inform the manager about the drop
		var dropped = false;
		if ($.ui.ddmanager &amp;&amp; !this.options.dropBehaviour)
			dropped = $.ui.ddmanager.drop(this, event);

		&#x2F;&#x2F;if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}
		
		&#x2F;&#x2F;if the original element is no longer in the DOM don&#x27;t bother to continue (see #8269)
		var element = this.element[0], elementInDom = false;
		while ( element &amp;&amp; (element = element.parentNode) ) {
			if (element == document ) {
				elementInDom = true;
			}
		}
		if ( !elementInDom &amp;&amp; this.options.helper === &quot;original&quot; )
			return false;

		if((this.options.revert == &quot;invalid&quot; &amp;&amp; !dropped) || (this.options.revert == &quot;valid&quot; &amp;&amp; dropped) || this.options.revert === true || ($.isFunction(this.options.revert) &amp;&amp; this.options.revert.call(this.element, dropped))) {
			var self = this;
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(self._trigger(&quot;stop&quot;, event) !== false) {
					self._clear();
				}
			});
		} else {
			if(this._trigger(&quot;stop&quot;, event) !== false) {
				this._clear();
			}
		}

		return false;
	},
	
	_mouseUp: function(event) {
		if (this.options.iframeFix === true) {
			$(&quot;div.ui-draggable-iframeFix&quot;).each(function() { 
				this.parentNode.removeChild(this); 
			}); &#x2F;&#x2F;Remove frame helpers
		}
		
		&#x2F;&#x2F;If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) $.ui.ddmanager.dragStop(this, event);
		
		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},
	
	cancel: function() {
		
		if(this.helper.is(&quot;.ui-draggable-dragging&quot;)) {
			this._mouseUp({});
		} else {
			this._clear();
		}
		
		return this;
		
	},

	_getHandle: function(event) {

		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
		$(this.options.handle, this.element)
			.find(&quot;*&quot;)
			.andSelf()
			.each(function() {
				if(this == event.target) handle = true;
			});

		return handle;

	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == &#x27;clone&#x27; ? this.element.clone().removeAttr(&#x27;id&#x27;) : this.element);

		if(!helper.parents(&#x27;body&#x27;).length)
			helper.appendTo((o.appendTo == &#x27;parent&#x27; ? this.element[0].parentNode : o.appendTo));

		if(helper[0] != this.element[0] &amp;&amp; !(&#x2F;(fixed|absolute)&#x2F;).test(helper.css(&quot;position&quot;)))
			helper.css(&quot;position&quot;, &quot;absolute&quot;);

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == &#x27;string&#x27;) {
			obj = obj.split(&#x27; &#x27;);
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if (&#x27;left&#x27; in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if (&#x27;right&#x27; in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if (&#x27;top&#x27; in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if (&#x27;bottom&#x27; in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		&#x2F;&#x2F;Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		&#x2F;&#x2F; This is a special case where we need to modify a offset calculated on start, since the following happened:
		&#x2F;&#x2F; 1. The position of the helper is absolute, so it&#x27;s position is calculated based on the next positioned parent
		&#x2F;&#x2F; 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn&#x27;t the document, which means that
		&#x2F;&#x2F;    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == &#x27;absolute&#x27; &amp;&amp; this.scrollParent[0] != document &amp;&amp; $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) &#x2F;&#x2F;This needs to be actually done for all browsers, since pageX&#x2F;pageY includes this information
		|| (this.offsetParent[0].tagName &amp;&amp; this.offsetParent[0].tagName.toLowerCase() == &#x27;html&#x27; &amp;&amp; $.browser.msie)) &#x2F;&#x2F;Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css(&quot;borderTopWidth&quot;),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css(&quot;borderLeftWidth&quot;),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == &quot;relative&quot;) {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css(&quot;top&quot;),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css(&quot;left&quot;),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css(&quot;marginLeft&quot;),10) || 0),
			top: (parseInt(this.element.css(&quot;marginTop&quot;),10) || 0),
			right: (parseInt(this.element.css(&quot;marginRight&quot;),10) || 0),
			bottom: (parseInt(this.element.css(&quot;marginBottom&quot;),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == &#x27;parent&#x27;) o.containment = this.helper[0].parentNode;
		if(o.containment == &#x27;document&#x27; || o.containment == &#x27;window&#x27;) this.containment = [
			o.containment == &#x27;document&#x27; ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
			o.containment == &#x27;document&#x27; ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
			(o.containment == &#x27;document&#x27; ? 0 : $(window).scrollLeft()) + $(o.containment == &#x27;document&#x27; ? document : window).width() - this.helperProportions.width - this.margins.left,
			(o.containment == &#x27;document&#x27; ? 0 : $(window).scrollTop()) + ($(o.containment == &#x27;document&#x27; ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(&#x2F;^(document|window|parent)$&#x2F;).test(o.containment) &amp;&amp; o.containment.constructor != Array) {
		        var c = $(o.containment);
			var ce = c[0]; if(!ce) return;
			var co = c.offset();
			var over = ($(ce).css(&quot;overflow&quot;) != &#x27;hidden&#x27;);

			this.containment = [
				(parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingLeft&quot;),10) || 0),
				(parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingTop&quot;),10) || 0),
				(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingRight&quot;),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
				(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingBottom&quot;),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;

		} else if(o.containment.constructor == Array) {
			this.containment = o.containment;
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == &quot;absolute&quot; ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == &#x27;absolute&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (&#x2F;(html|body)&#x2F;i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	&#x2F;&#x2F; The absolute mouse position
				+ this.offset.relative.top * mod										&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				- ($.browser.safari &amp;&amp; $.browser.version &lt; 526 &amp;&amp; this.cssPosition == &#x27;fixed&#x27; ? 0 : ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																&#x2F;&#x2F; The absolute mouse position
				+ this.offset.relative.left * mod										&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				- ($.browser.safari &amp;&amp; $.browser.version &lt; 526 &amp;&amp; this.cssPosition == &#x27;fixed&#x27; ? 0 : ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == &#x27;absolute&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (&#x2F;(html|body)&#x2F;i).test(scroll[0].tagName);
		var pageX = event.pageX;
		var pageY = event.pageY;

		&#x2F;*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 *&#x2F;

		if(this.originalPosition) { &#x2F;&#x2F;If we are not dragging yet, we won&#x27;t check for options
		         var containment;
		         if(this.containment) {
				 if (this.relative_container){
				     var co = this.relative_container.offset();
				     containment = [ this.containment[0] + co.left,
						     this.containment[1] + co.top,
						     this.containment[2] + co.left,
						     this.containment[3] + co.top ];
				 }
				 else {
				     containment = this.containment;
				 }

				if(event.pageX - this.offset.click.left &lt; containment[0]) pageX = containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top &lt; containment[1]) pageY = containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left &gt; containment[2]) pageX = containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top &gt; containment[3]) pageY = containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				&#x2F;&#x2F;Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) &#x2F; o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? (!(top - this.offset.click.top &lt; containment[1] || top - this.offset.click.top &gt; containment[3]) ? top : (!(top - this.offset.click.top &lt; containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) &#x2F; o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? (!(left - this.offset.click.left &lt; containment[0] || left - this.offset.click.left &gt; containment[2]) ? left : (!(left - this.offset.click.left &lt; containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																&#x2F;&#x2F; The absolute mouse position
				- this.offset.click.top													&#x2F;&#x2F; Click offset (relative to the element)
				- this.offset.relative.top												&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				+ ($.browser.safari &amp;&amp; $.browser.version &lt; 526 &amp;&amp; this.cssPosition == &#x27;fixed&#x27; ? 0 : ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																&#x2F;&#x2F; The absolute mouse position
				- this.offset.click.left												&#x2F;&#x2F; Click offset (relative to the element)
				- this.offset.relative.left												&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				+ ($.browser.safari &amp;&amp; $.browser.version &lt; 526 &amp;&amp; this.cssPosition == &#x27;fixed&#x27; ? 0 : ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_clear: function() {
		this.helper.removeClass(&quot;ui-draggable-dragging&quot;);
		if(this.helper[0] != this.element[0] &amp;&amp; !this.cancelHelperRemoval) this.helper.remove();
		&#x2F;&#x2F;if($.ui.ddmanager) $.ui.ddmanager.current = null;
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	&#x2F;&#x2F; From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		if(type == &quot;drag&quot;) this.positionAbs = this._convertPositionTo(&quot;absolute&quot;); &#x2F;&#x2F;The absolute position has to be recalculated after plugins
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function(event) {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.extend($.ui.draggable, {
	version: &quot;1.8.23&quot;
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;connectToSortable&quot;, {
	start: function(event, ui) {

		var inst = $(this).data(&quot;draggable&quot;), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, &#x27;sortable&#x27;);
			if (sortable &amp;&amp; !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	&#x2F;&#x2F; Call the sortable&#x27;s refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it&#x27;s initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger(&quot;activate&quot;, event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		&#x2F;&#x2F;If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data(&quot;draggable&quot;),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; &#x2F;&#x2F;Don&#x27;t remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; &#x2F;&#x2F;Remove it in the sortable instance (so sortable plugins like revert still work)

				&#x2F;&#x2F;The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: &#x27;valid&#x2F;invalid&#x27;
				if(this.shouldRevert) this.instance.options.revert = true;

				&#x2F;&#x2F;Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				&#x2F;&#x2F;If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper == &#x27;original&#x27;)
					this.instance.currentItem.css({ top: &#x27;auto&#x27;, left: &#x27;auto&#x27; });

			} else {
				this.instance.cancelHelperRemoval = false; &#x2F;&#x2F;Remove the helper in the sortable instance
				this.instance._trigger(&quot;deactivate&quot;, event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data(&quot;draggable&quot;), self = this;

		var checkPos = function(o) {
			var dyClick = this.offset.click.top, dxClick = this.offset.click.left;
			var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;
			var itemHeight = o.height, itemWidth = o.width;
			var itemTop = o.top, itemLeft = o.left;

			return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);
		};

		$.each(inst.sortables, function(i) {
			
			&#x2F;&#x2F;Copy over some variables to allow calling the sortable&#x27;s native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;
			
			if(this.instance._intersectsWith(this.instance.containerCache)) {

				&#x2F;&#x2F;If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					&#x2F;&#x2F;Now we fake the start of dragging for the sortable instance,
					&#x2F;&#x2F;by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					&#x2F;&#x2F;We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn&#x27;t create a new one)
					this.instance.currentItem = $(self).clone().removeAttr(&#x27;id&#x27;).appendTo(this.instance.element).data(&quot;sortable-item&quot;, true);
					this.instance.options._helper = this.instance.options.helper; &#x2F;&#x2F;Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					&#x2F;&#x2F;Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger(&quot;toSortable&quot;, event);
					inst.dropped = this.instance.element; &#x2F;&#x2F;draggable revert needs that
					&#x2F;&#x2F;hack so receive&#x2F;update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				&#x2F;&#x2F;Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) this.instance._mouseDrag(event);

			} else {

				&#x2F;&#x2F;If it doesn&#x27;t intersect with the sortable, and it intersected before,
				&#x2F;&#x2F;we fake the drag stop of the sortable, but make sure it doesn&#x27;t remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;
					
					&#x2F;&#x2F;Prevent reverting on this forced stop
					this.instance.options.revert = false;
					
					&#x2F;&#x2F; The out event needs to be triggered independently
					this.instance._trigger(&#x27;out&#x27;, event, this.instance._uiHash(this.instance));
					
					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					&#x2F;&#x2F;Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it&#x27;s original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) this.instance.placeholder.remove();

					inst._trigger(&quot;fromSortable&quot;, event);
					inst.dropped = false; &#x2F;&#x2F;draggable revert needs that
				}

			};

		});

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;cursor&quot;, {
	start: function(event, ui) {
		var t = $(&#x27;body&#x27;), o = $(this).data(&#x27;draggable&#x27;).options;
		if (t.css(&quot;cursor&quot;)) o._cursor = t.css(&quot;cursor&quot;);
		t.css(&quot;cursor&quot;, o.cursor);
	},
	stop: function(event, ui) {
		var o = $(this).data(&#x27;draggable&#x27;).options;
		if (o._cursor) $(&#x27;body&#x27;).css(&quot;cursor&quot;, o._cursor);
	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;opacity&quot;, {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data(&#x27;draggable&#x27;).options;
		if(t.css(&quot;opacity&quot;)) o._opacity = t.css(&quot;opacity&quot;);
		t.css(&#x27;opacity&#x27;, o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data(&#x27;draggable&#x27;).options;
		if(o._opacity) $(ui.helper).css(&#x27;opacity&#x27;, o._opacity);
	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;scroll&quot;, {
	start: function(event, ui) {
		var i = $(this).data(&quot;draggable&quot;);
		if(i.scrollParent[0] != document &amp;&amp; i.scrollParent[0].tagName != &#x27;HTML&#x27;) i.overflowOffset = i.scrollParent.offset();
	},
	drag: function(event, ui) {

		var i = $(this).data(&quot;draggable&quot;), o = i.options, scrolled = false;

		if(i.scrollParent[0] != document &amp;&amp; i.scrollParent[0].tagName != &#x27;HTML&#x27;) {

			if(!o.axis || o.axis != &#x27;x&#x27;) {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY &lt; o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - i.overflowOffset.top &lt; o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
			}

			if(!o.axis || o.axis != &#x27;y&#x27;) {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX &lt; o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - i.overflowOffset.left &lt; o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
			}

		} else {

			if(!o.axis || o.axis != &#x27;x&#x27;) {
				if(event.pageY - $(document).scrollTop() &lt; o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) &lt; o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
			}

			if(!o.axis || o.axis != &#x27;y&#x27;) {
				if(event.pageX - $(document).scrollLeft() &lt; o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) &lt; o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
			}

		}

		if(scrolled !== false &amp;&amp; $.ui.ddmanager &amp;&amp; !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(i, event);

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;snap&quot;, {
	start: function(event, ui) {

		var i = $(this).data(&quot;draggable&quot;), o = i.options;
		i.snapElements = [];

		$(o.snap.constructor != String ? ( o.snap.items || &#x27;:data(draggable)&#x27; ) : o.snap).each(function() {
			var $t = $(this); var $o = $t.offset();
			if(this != i.element[0]) i.snapElements.push({
				item: this,
				width: $t.outerWidth(), height: $t.outerHeight(),
				top: $o.top, left: $o.left
			});
		});

	},
	drag: function(event, ui) {

		var inst = $(this).data(&quot;draggable&quot;), o = inst.options;
		var d = o.snapTolerance;

		var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (var i = inst.snapElements.length - 1; i &gt;= 0; i--){

			var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,
				t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;

			&#x2F;&#x2F;Yes, I know, this is insane ;)
			if(!((l-d &lt; x1 &amp;&amp; x1 &lt; r+d &amp;&amp; t-d &lt; y1 &amp;&amp; y1 &lt; b+d) || (l-d &lt; x1 &amp;&amp; x1 &lt; r+d &amp;&amp; t-d &lt; y2 &amp;&amp; y2 &lt; b+d) || (l-d &lt; x2 &amp;&amp; x2 &lt; r+d &amp;&amp; t-d &lt; y1 &amp;&amp; y1 &lt; b+d) || (l-d &lt; x2 &amp;&amp; x2 &lt; r+d &amp;&amp; t-d &lt; y2 &amp;&amp; y2 &lt; b+d))) {
				if(inst.snapElements[i].snapping) (inst.options.snap.release &amp;&amp; inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode != &#x27;inner&#x27;) {
				var ts = Math.abs(t - y2) &lt;= d;
				var bs = Math.abs(b - y1) &lt;= d;
				var ls = Math.abs(l - x2) &lt;= d;
				var rs = Math.abs(r - x1) &lt;= d;
				if(ts) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: b, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: r }).left - inst.margins.left;
			}

			var first = (ts || bs || ls || rs);

			if(o.snapMode != &#x27;outer&#x27;) {
				var ts = Math.abs(t - y1) &lt;= d;
				var bs = Math.abs(b - y2) &lt;= d;
				var ls = Math.abs(l - x1) &lt;= d;
				var rs = Math.abs(r - x2) &lt;= d;
				if(ts) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: t, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: l }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
			}

			if(!inst.snapElements[i].snapping &amp;&amp; (ts || bs || ls || rs || first))
				(inst.options.snap.snap &amp;&amp; inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		};

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;stack&quot;, {
	start: function(event, ui) {

		var o = $(this).data(&quot;draggable&quot;).options;

		var group = $.makeArray($(o.stack)).sort(function(a,b) {
			return (parseInt($(a).css(&quot;zIndex&quot;),10) || 0) - (parseInt($(b).css(&quot;zIndex&quot;),10) || 0);
		});
		if (!group.length) { return; }
		
		var min = parseInt(group[0].style.zIndex) || 0;
		$(group).each(function(i) {
			this.style.zIndex = min + i;
		});

		this[0].style.zIndex = min + group.length;

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;zIndex&quot;, {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data(&quot;draggable&quot;).options;
		if(t.css(&quot;zIndex&quot;)) o._zIndex = t.css(&quot;zIndex&quot;);
		t.css(&#x27;zIndex&#x27;, o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data(&quot;draggable&quot;).options;
		if(o._zIndex) $(ui.helper).css(&#x27;zIndex&#x27;, o._zIndex);
	}
});

})(jQuery);

(function( $, undefined ) {

$.widget(&quot;ui.droppable&quot;, {
	widgetEventPrefix: &quot;drop&quot;,
	options: {
		accept: &#x27;*&#x27;,
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: &#x27;default&#x27;,
		tolerance: &#x27;intersect&#x27;
	},
	_create: function() {

		var o = this.options, accept = o.accept;
		this.isover = 0; this.isout = 1;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		&#x2F;&#x2F;Store the droppable&#x27;s proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		&#x2F;&#x2F; Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses &amp;&amp; this.element.addClass(&quot;ui-droppable&quot;));

	},

	destroy: function() {
		var drop = $.ui.ddmanager.droppables[this.options.scope];
		for ( var i = 0; i &lt; drop.length; i++ )
			if ( drop[i] == this )
				drop.splice(i, 1);

		this.element
			.removeClass(&quot;ui-droppable ui-droppable-disabled&quot;)
			.removeData(&quot;droppable&quot;)
			.unbind(&quot;.droppable&quot;);

		return this;
	},

	_setOption: function(key, value) {

		if(key == &#x27;accept&#x27;) {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.addClass(this.options.activeClass);
		(draggable &amp;&amp; this._trigger(&#x27;activate&#x27;, event, this.ui(draggable)));
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
		(draggable &amp;&amp; this._trigger(&#x27;deactivate&#x27;, event, this.ui(draggable)));
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; &#x2F;&#x2F; Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);
			this._trigger(&#x27;over&#x27;, event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; &#x2F;&#x2F; Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger(&#x27;out&#x27;, event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; &#x2F;&#x2F; Bail if draggable and droppable are same element

		var childrenIntersection = false;
		this.element.find(&quot;:data(droppable)&quot;).not(&quot;.ui-draggable-dragging&quot;).each(function() {
			var inst = $.data(this, &#x27;droppable&#x27;);
			if(
				inst.options.greedy
				&amp;&amp; !inst.options.disabled
				&amp;&amp; inst.options.scope == draggable.options.scope
				&amp;&amp; inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))
				&amp;&amp; $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) return false;

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger(&#x27;drop&#x27;, event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.extend($.ui.droppable, {
	version: &quot;1.8.23&quot;
});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) return false;

	var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;
	var l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case &#x27;fit&#x27;:
			return (l &lt;= x1 &amp;&amp; x2 &lt;= r
				&amp;&amp; t &lt;= y1 &amp;&amp; y2 &lt;= b);
			break;
		case &#x27;intersect&#x27;:
			return (l &lt; x1 + (draggable.helperProportions.width &#x2F; 2) &#x2F;&#x2F; Right Half
				&amp;&amp; x2 - (draggable.helperProportions.width &#x2F; 2) &lt; r &#x2F;&#x2F; Left Half
				&amp;&amp; t &lt; y1 + (draggable.helperProportions.height &#x2F; 2) &#x2F;&#x2F; Bottom Half
				&amp;&amp; y2 - (draggable.helperProportions.height &#x2F; 2) &lt; b ); &#x2F;&#x2F; Top Half
			break;
		case &#x27;pointer&#x27;:
			var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),
				isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
			return isOver;
			break;
		case &#x27;touch&#x27;:
			return (
					(y1 &gt;= t &amp;&amp; y1 &lt;= b) ||	&#x2F;&#x2F; Top edge touching
					(y2 &gt;= t &amp;&amp; y2 &lt;= b) ||	&#x2F;&#x2F; Bottom edge touching
					(y1 &lt; t &amp;&amp; y2 &gt; b)		&#x2F;&#x2F; Surrounded vertically
				) &amp;&amp; (
					(x1 &gt;= l &amp;&amp; x1 &lt;= r) ||	&#x2F;&#x2F; Left edge touching
					(x2 &gt;= l &amp;&amp; x2 &lt;= r) ||	&#x2F;&#x2F; Right edge touching
					(x1 &lt; l &amp;&amp; x2 &gt; r)		&#x2F;&#x2F; Surrounded horizontally
				);
			break;
		default:
			return false;
			break;
		}

};

&#x2F;*
	This manager tracks offsets of draggables and droppables
*&#x2F;
$.ui.ddmanager = {
	current: null,
	droppables: { &#x27;default&#x27;: [] },
	prepareOffsets: function(t, event) {

		var m = $.ui.ddmanager.droppables[t.options.scope] || [];
		var type = event ? event.type : null; &#x2F;&#x2F; workaround for #2317
		var list = (t.currentItem || t.element).find(&quot;:data(droppable)&quot;).andSelf();

		droppablesLoop: for (var i = 0; i &lt; m.length; i++) {

			if(m[i].options.disabled || (t &amp;&amp; !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue;	&#x2F;&#x2F;No disabled and non-accepted
			for (var j=0; j &lt; list.length; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; &#x2F;&#x2F;Filter out elements in the current dragged item
			m[i].visible = m[i].element.css(&quot;display&quot;) != &quot;none&quot;; if(!m[i].visible) continue; 									&#x2F;&#x2F;If the element is not visible, continue

			if(type == &quot;mousedown&quot;) m[i]._activate.call(m[i], event); &#x2F;&#x2F;Activate the droppable if used directly from draggables

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(!this.options) return;
			if (!this.options.disabled &amp;&amp; this.visible &amp;&amp; $.ui.intersect(draggable, this, this.options.tolerance))
				dropped = this._drop.call(this, event) || dropped;

			if (!this.options.disabled &amp;&amp; this.visible &amp;&amp; this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = 1; this.isover = 0;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		&#x2F;&#x2F;Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parents( &quot;:not(body,html)&quot; ).bind( &quot;scroll.droppable&quot;, function() {
			if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
		});
	},
	drag: function(draggable, event) {

		&#x2F;&#x2F;If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);

		&#x2F;&#x2F;Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) return;
			var intersects = $.ui.intersect(draggable, this, this.options.tolerance);

			var c = !intersects &amp;&amp; this.isover == 1 ? &#x27;isout&#x27; : (intersects &amp;&amp; this.isover == 0 ? &#x27;isover&#x27; : null);
			if(!c) return;

			var parentInstance;
			if (this.options.greedy) {
				var parent = this.element.parents(&#x27;:data(droppable):eq(0)&#x27;);
				if (parent.length) {
					parentInstance = $.data(parent[0], &#x27;droppable&#x27;);
					parentInstance.greedyChild = (c == &#x27;isover&#x27; ? 1 : 0);
				}
			}

			&#x2F;&#x2F; we just moved into a greedy child
			if (parentInstance &amp;&amp; c == &#x27;isover&#x27;) {
				parentInstance[&#x27;isover&#x27;] = 0;
				parentInstance[&#x27;isout&#x27;] = 1;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = 1; this[c == &#x27;isout&#x27; ? &#x27;isover&#x27; : &#x27;isout&#x27;] = 0;
			this[c == &quot;isover&quot; ? &quot;_over&quot; : &quot;_out&quot;].call(this, event);

			&#x2F;&#x2F; we just moved out of a greedy child
			if (parentInstance &amp;&amp; c == &#x27;isout&#x27;) {
				parentInstance[&#x27;isout&#x27;] = 0;
				parentInstance[&#x27;isover&#x27;] = 1;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parents( &quot;:not(body,html)&quot; ).unbind( &quot;scroll.droppable&quot; );
		&#x2F;&#x2F;Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
	}
};

})(jQuery);

(function( $, undefined ) {

$.widget(&quot;ui.resizable&quot;, $.ui.mouse, {
	widgetEventPrefix: &quot;resize&quot;,
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: &quot;slow&quot;,
		animateEasing: &quot;swing&quot;,
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: &quot;e,s,se&quot;,
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		zIndex: 1000
	},
	_create: function() {

		var self = this, o = this.options;
		this.element.addClass(&quot;ui-resizable&quot;);

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || &#x27;ui-resizable-helper&#x27; : null
		});

		&#x2F;&#x2F;Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(&#x2F;canvas|textarea|input|select|button|img&#x2F;i)) {

			&#x2F;&#x2F;Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$(&#x27;&lt;div class=&quot;ui-wrapper&quot; style=&quot;overflow: hidden;&quot;&gt;&lt;&#x2F;div&gt;&#x27;).css({
					position: this.element.css(&#x27;position&#x27;),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css(&#x27;top&#x27;),
					left: this.element.css(&#x27;left&#x27;)
				})
			);

			&#x2F;&#x2F;Overwrite the original this.element
			this.element = this.element.parent().data(
				&quot;resizable&quot;, this.element.data(&#x27;resizable&#x27;)
			);

			this.elementIsWrapper = true;

			&#x2F;&#x2F;Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css(&quot;marginLeft&quot;), marginTop: this.originalElement.css(&quot;marginTop&quot;), marginRight: this.originalElement.css(&quot;marginRight&quot;), marginBottom: this.originalElement.css(&quot;marginBottom&quot;) });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			&#x2F;&#x2F;Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css(&#x27;resize&#x27;);
			this.originalElement.css(&#x27;resize&#x27;, &#x27;none&#x27;);

			&#x2F;&#x2F;Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: &#x27;static&#x27;, zoom: 1, display: &#x27;block&#x27; }));

			&#x2F;&#x2F; avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css(&#x27;margin&#x27;) });

			&#x2F;&#x2F; fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$(&#x27;.ui-resizable-handle&#x27;, this.element).length ? &quot;e,s,se&quot; : { n: &#x27;.ui-resizable-n&#x27;, e: &#x27;.ui-resizable-e&#x27;, s: &#x27;.ui-resizable-s&#x27;, w: &#x27;.ui-resizable-w&#x27;, se: &#x27;.ui-resizable-se&#x27;, sw: &#x27;.ui-resizable-sw&#x27;, ne: &#x27;.ui-resizable-ne&#x27;, nw: &#x27;.ui-resizable-nw&#x27; });
		if(this.handles.constructor == String) {

			if(this.handles == &#x27;all&#x27;) this.handles = &#x27;n,e,s,w,se,sw,ne,nw&#x27;;
			var n = this.handles.split(&quot;,&quot;); this.handles = {};

			for(var i = 0; i &lt; n.length; i++) {

				var handle = $.trim(n[i]), hname = &#x27;ui-resizable-&#x27;+handle;
				var axis = $(&#x27;&lt;div class=&quot;ui-resizable-handle &#x27; + hname + &#x27;&quot;&gt;&lt;&#x2F;div&gt;&#x27;);

				&#x2F;&#x2F; Apply zIndex to all handles - see #7960
				axis.css({ zIndex: o.zIndex });

				&#x2F;&#x2F;TODO : What&#x27;s going on here?
				if (&#x27;se&#x27; == handle) {
					axis.addClass(&#x27;ui-icon ui-icon-gripsmall-diagonal-se&#x27;);
				};

				&#x2F;&#x2F;Insert into internal handles object and append to element
				this.handles[handle] = &#x27;.ui-resizable-&#x27;+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			target = target || this.element;

			for(var i in this.handles) {

				if(this.handles[i].constructor == String)
					this.handles[i] = $(this.handles[i], this.element).show();

				&#x2F;&#x2F;Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper &amp;&amp; this.originalElement[0].nodeName.match(&#x2F;textarea|input|select|button&#x2F;i)) {

					var axis = $(this.handles[i], this.element), padWrapper = 0;

					&#x2F;&#x2F;Checking the correct pad and border
					padWrapper = &#x2F;sw|ne|nw|se|n|s&#x2F;.test(i) ? axis.outerHeight() : axis.outerWidth();

					&#x2F;&#x2F;The padding type i have to apply...
					var padPos = [ &#x27;padding&#x27;,
						&#x2F;ne|nw|n&#x2F;.test(i) ? &#x27;Top&#x27; :
						&#x2F;se|sw|s&#x2F;.test(i) ? &#x27;Bottom&#x27; :
						&#x2F;^e$&#x2F;.test(i) ? &#x27;Right&#x27; : &#x27;Left&#x27; ].join(&quot;&quot;);

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				&#x2F;&#x2F;TODO: What&#x27;s that good for? There&#x27;s not anything to be executed left
				if(!$(this.handles[i]).length)
					continue;

			}
		};

		&#x2F;&#x2F;TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $(&#x27;.ui-resizable-handle&#x27;, this.element)
			.disableSelection();

		&#x2F;&#x2F;Matching axis name
		this._handles.mouseover(function() {
			if (!self.resizing) {
				if (this.className)
					var axis = this.className.match(&#x2F;ui-resizable-(se|sw|ne|nw|n|e|s|w)&#x2F;i);
				&#x2F;&#x2F;Axis, default = se
				self.axis = axis &amp;&amp; axis[1] ? axis[1] : &#x27;se&#x27;;
			}
		});

		&#x2F;&#x2F;If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass(&quot;ui-resizable-autohide&quot;)
				.hover(function() {
					if (o.disabled) return;
					$(this).removeClass(&quot;ui-resizable-autohide&quot;);
					self._handles.show();
				},
				function(){
					if (o.disabled) return;
					if (!self.resizing) {
						$(this).addClass(&quot;ui-resizable-autohide&quot;);
						self._handles.hide();
					}
				});
		}

		&#x2F;&#x2F;Initialize the mouse interaction
		this._mouseInit();

	},

	destroy: function() {

		this._mouseDestroy();

		var _destroy = function(exp) {
			$(exp).removeClass(&quot;ui-resizable ui-resizable-disabled ui-resizable-resizing&quot;)
				.removeData(&quot;resizable&quot;).unbind(&quot;.resizable&quot;).find(&#x27;.ui-resizable-handle&#x27;).remove();
		};

		&#x2F;&#x2F;TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			var wrapper = this.element;
			wrapper.after(
				this.originalElement.css({
					position: wrapper.css(&#x27;position&#x27;),
					width: wrapper.outerWidth(),
					height: wrapper.outerHeight(),
					top: wrapper.css(&#x27;top&#x27;),
					left: wrapper.css(&#x27;left&#x27;)
				})
			).remove();
		}

		this.originalElement.css(&#x27;resize&#x27;, this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var handle = false;
		for (var i in this.handles) {
			if ($(this.handles[i])[0] == event.target) {
				handle = true;
			}
		}

		return !this.options.disabled &amp;&amp; handle;
	},

	_mouseStart: function(event) {

		var o = this.options, iniPos = this.element.position(), el = this.element;

		this.resizing = true;
		this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };

		&#x2F;&#x2F; bugfix for http:&#x2F;&#x2F;dev.jquery.com&#x2F;ticket&#x2F;1749
		if (el.is(&#x27;.ui-draggable&#x27;) || (&#x2F;absolute&#x2F;).test(el.css(&#x27;position&#x27;))) {
			el.css({ position: &#x27;absolute&#x27;, top: iniPos.top, left: iniPos.left });
		}

		this._renderProxy();

		var curleft = num(this.helper.css(&#x27;left&#x27;)), curtop = num(this.helper.css(&#x27;top&#x27;));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		&#x2F;&#x2F;Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		&#x2F;&#x2F;Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio == &#x27;number&#x27;) ? o.aspectRatio : ((this.originalSize.width &#x2F; this.originalSize.height) || 1);

	    var cursor = $(&#x27;.ui-resizable-&#x27; + this.axis).css(&#x27;cursor&#x27;);
	    $(&#x27;body&#x27;).css(&#x27;cursor&#x27;, cursor == &#x27;auto&#x27; ? this.axis + &#x27;-resize&#x27; : cursor);

		el.addClass(&quot;ui-resizable-resizing&quot;);
		this._propagate(&quot;start&quot;, event);
		return true;
	},

	_mouseDrag: function(event) {

		&#x2F;&#x2F;Increase performance, avoid regex
		var el = this.helper, o = this.options, props = {},
			self = this, smp = this.originalMousePosition, a = this.axis;

		var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;
		var trigger = this._change[a];
		if (!trigger) return false;

		&#x2F;&#x2F; Calculate the attrs that will be change
		var data = trigger.apply(this, [event, dx, dy]), ie6 = $.browser.msie &amp;&amp; $.browser.version &lt; 7, csdif = this.sizeDiff;

		&#x2F;&#x2F; Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey)
			data = this._updateRatio(data, event);

		data = this._respectSize(data, event);

		&#x2F;&#x2F; plugins callbacks need to be called first
		this._propagate(&quot;resize&quot;, event);

		el.css({
			top: this.position.top + &quot;px&quot;, left: this.position.left + &quot;px&quot;,
			width: this.size.width + &quot;px&quot;, height: this.size.height + &quot;px&quot;
		});

		if (!this._helper &amp;&amp; this._proportionallyResizeElements.length)
			this._proportionallyResize();

		this._updateCache(data);

		&#x2F;&#x2F; calling the user callback at the end
		this._trigger(&#x27;resize&#x27;, event, this.ui());

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var o = this.options, self = this;

		if(this._helper) {
			var pr = this._proportionallyResizeElements, ista = pr.length &amp;&amp; (&#x2F;textarea&#x2F;i).test(pr[0].nodeName),
				soffseth = ista &amp;&amp; $.ui.hasScroll(pr[0], &#x27;left&#x27;) &#x2F;* TODO - jump height *&#x2F; ? 0 : self.sizeDiff.height,
				soffsetw = ista ? 0 : self.sizeDiff.width;

			var s = { width: (self.helper.width()  - soffsetw), height: (self.helper.height() - soffseth) },
				left = (parseInt(self.element.css(&#x27;left&#x27;), 10) + (self.position.left - self.originalPosition.left)) || null,
				top = (parseInt(self.element.css(&#x27;top&#x27;), 10) + (self.position.top - self.originalPosition.top)) || null;

			if (!o.animate)
				this.element.css($.extend(s, { top: top, left: left }));

			self.helper.height(self.size.height);
			self.helper.width(self.size.width);

			if (this._helper &amp;&amp; !o.animate) this._proportionallyResize();
		}

		$(&#x27;body&#x27;).css(&#x27;cursor&#x27;, &#x27;auto&#x27;);

		this.element.removeClass(&quot;ui-resizable-resizing&quot;);

		this._propagate(&quot;stop&quot;, event);

		if (this._helper) this.helper.remove();
		return false;

	},

    _updateVirtualBoundaries: function(forceAspectRatio) {
        var o = this.options, pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b;

        b = {
            minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
            maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
            minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
            maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
        };

        if(this._aspectRatio || forceAspectRatio) {
            &#x2F;&#x2F; We want to create an enclosing box whose aspect ration is the requested one
            &#x2F;&#x2F; First, compute the &quot;projected&quot; size for each dimension based on the aspect ratio and other dimension
            pMinWidth = b.minHeight * this.aspectRatio;
            pMinHeight = b.minWidth &#x2F; this.aspectRatio;
            pMaxWidth = b.maxHeight * this.aspectRatio;
            pMaxHeight = b.maxWidth &#x2F; this.aspectRatio;

            if(pMinWidth &gt; b.minWidth) b.minWidth = pMinWidth;
            if(pMinHeight &gt; b.minHeight) b.minHeight = pMinHeight;
            if(pMaxWidth &lt; b.maxWidth) b.maxWidth = pMaxWidth;
            if(pMaxHeight &lt; b.maxHeight) b.maxHeight = pMaxHeight;
        }
        this._vBoundaries = b;
    },

	_updateCache: function(data) {
		var o = this.options;
		this.offset = this.helper.offset();
		if (isNumber(data.left)) this.position.left = data.left;
		if (isNumber(data.top)) this.position.top = data.top;
		if (isNumber(data.height)) this.size.height = data.height;
		if (isNumber(data.width)) this.size.width = data.width;
	},

	_updateRatio: function(data, event) {

		var o = this.options, cpos = this.position, csize = this.size, a = this.axis;

		if (isNumber(data.height)) data.width = (data.height * this.aspectRatio);
		else if (isNumber(data.width)) data.height = (data.width &#x2F; this.aspectRatio);

		if (a == &#x27;sw&#x27;) {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a == &#x27;nw&#x27;) {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function(data, event) {

		var el = this.helper, o = this._vBoundaries, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,
				ismaxw = isNumber(data.width) &amp;&amp; o.maxWidth &amp;&amp; (o.maxWidth &lt; data.width), ismaxh = isNumber(data.height) &amp;&amp; o.maxHeight &amp;&amp; (o.maxHeight &lt; data.height),
					isminw = isNumber(data.width) &amp;&amp; o.minWidth &amp;&amp; (o.minWidth &gt; data.width), isminh = isNumber(data.height) &amp;&amp; o.minHeight &amp;&amp; (o.minHeight &gt; data.height);

		if (isminw) data.width = o.minWidth;
		if (isminh) data.height = o.minHeight;
		if (ismaxw) data.width = o.maxWidth;
		if (ismaxh) data.height = o.maxHeight;

		var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;
		var cw = &#x2F;sw|nw|w&#x2F;.test(a), ch = &#x2F;nw|ne|n&#x2F;.test(a);

		if (isminw &amp;&amp; cw) data.left = dw - o.minWidth;
		if (ismaxw &amp;&amp; cw) data.left = dw - o.maxWidth;
		if (isminh &amp;&amp; ch)	data.top = dh - o.minHeight;
		if (ismaxh &amp;&amp; ch)	data.top = dh - o.maxHeight;

		&#x2F;&#x2F; fixing jump error on top&#x2F;left - bug #2330
		var isNotwh = !data.width &amp;&amp; !data.height;
		if (isNotwh &amp;&amp; !data.left &amp;&amp; data.top) data.top = null;
		else if (isNotwh &amp;&amp; !data.top &amp;&amp; data.left) data.left = null;

		return data;
	},

	_proportionallyResize: function() {

		var o = this.options;
		if (!this._proportionallyResizeElements.length) return;
		var element = this.helper || this.element;

		for (var i=0; i &lt; this._proportionallyResizeElements.length; i++) {

			var prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				var b = [prel.css(&#x27;borderTopWidth&#x27;), prel.css(&#x27;borderRightWidth&#x27;), prel.css(&#x27;borderBottomWidth&#x27;), prel.css(&#x27;borderLeftWidth&#x27;)],
					p = [prel.css(&#x27;paddingTop&#x27;), prel.css(&#x27;paddingRight&#x27;), prel.css(&#x27;paddingBottom&#x27;), prel.css(&#x27;paddingLeft&#x27;)];

				this.borderDif = $.map(b, function(v, i) {
					var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;
					return border + padding;
				});
			}

			if ($.browser.msie &amp;&amp; !(!($(element).is(&#x27;:hidden&#x27;) || $(element).parents(&#x27;:hidden&#x27;).length)))
				continue;

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		};

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $(&#x27;&lt;div style=&quot;overflow:hidden;&quot;&gt;&lt;&#x2F;div&gt;&#x27;);

			&#x2F;&#x2F; fix ie6 offset TODO: This seems broken
			var ie6 = $.browser.msie &amp;&amp; $.browser.version &lt; 7, ie6offset = (ie6 ? 1 : 0),
			pxyoffset = ( ie6 ? 2 : -1 );

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() + pxyoffset,
				height: this.element.outerHeight() + pxyoffset,
				position: &#x27;absolute&#x27;,
				left: this.elementOffset.left - ie6offset +&#x27;px&#x27;,
				top: this.elementOffset.top - ie6offset +&#x27;px&#x27;,
				zIndex: ++o.zIndex &#x2F;&#x2F;TODO: Don&#x27;t modify option
			});

			this.helper
				.appendTo(&quot;body&quot;)
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx, dy) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n != &quot;resize&quot; &amp;&amp; this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

$.extend($.ui.resizable, {
	version: &quot;1.8.23&quot;
});

&#x2F;*
 * Resizable Extensions
 *&#x2F;

$.ui.plugin.add(&quot;resizable&quot;, &quot;alsoResize&quot;, {

	start: function (event, ui) {
		var self = $(this).data(&quot;resizable&quot;), o = self.options;

		var _store = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				el.data(&quot;resizable-alsoresize&quot;, {
					width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
					left: parseInt(el.css(&#x27;left&#x27;), 10), top: parseInt(el.css(&#x27;top&#x27;), 10)
				});
			});
		};

		if (typeof(o.alsoResize) == &#x27;object&#x27; &amp;&amp; !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var self = $(this).data(&quot;resizable&quot;), o = self.options, os = self.originalSize, op = self.originalPosition;

		var delta = {
			height: (self.size.height - os.height) || 0, width: (self.size.width - os.width) || 0,
			top: (self.position.top - op.top) || 0, left: (self.position.left - op.left) || 0
		},

		_alsoResize = function (exp, c) {
			$(exp).each(function() {
				var el = $(this), start = $(this).data(&quot;resizable-alsoresize&quot;), style = {}, 
					css = c &amp;&amp; c.length ? c : el.parents(ui.originalElement[0]).length ? [&#x27;width&#x27;, &#x27;height&#x27;] : [&#x27;width&#x27;, &#x27;height&#x27;, &#x27;top&#x27;, &#x27;left&#x27;];

				$.each(css, function (i, prop) {
					var sum = (start[prop]||0) + (delta[prop]||0);
					if (sum &amp;&amp; sum &gt;= 0)
						style[prop] = sum || null;
				});

				el.css(style);
			});
		};

		if (typeof(o.alsoResize) == &#x27;object&#x27; &amp;&amp; !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function (event, ui) {
		$(this).removeData(&quot;resizable-alsoresize&quot;);
	}
});

$.ui.plugin.add(&quot;resizable&quot;, &quot;animate&quot;, {

	stop: function(event, ui) {
		var self = $(this).data(&quot;resizable&quot;), o = self.options;

		var pr = self._proportionallyResizeElements, ista = pr.length &amp;&amp; (&#x2F;textarea&#x2F;i).test(pr[0].nodeName),
					soffseth = ista &amp;&amp; $.ui.hasScroll(pr[0], &#x27;left&#x27;) &#x2F;* TODO - jump height *&#x2F; ? 0 : self.sizeDiff.height,
						soffsetw = ista ? 0 : self.sizeDiff.width;

		var style = { width: (self.size.width - soffsetw), height: (self.size.height - soffseth) },
					left = (parseInt(self.element.css(&#x27;left&#x27;), 10) + (self.position.left - self.originalPosition.left)) || null,
						top = (parseInt(self.element.css(&#x27;top&#x27;), 10) + (self.position.top - self.originalPosition.top)) || null;

		self.element.animate(
			$.extend(style, top &amp;&amp; left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(self.element.css(&#x27;width&#x27;), 10),
						height: parseInt(self.element.css(&#x27;height&#x27;), 10),
						top: parseInt(self.element.css(&#x27;top&#x27;), 10),
						left: parseInt(self.element.css(&#x27;left&#x27;), 10)
					};

					if (pr &amp;&amp; pr.length) $(pr[0]).css({ width: data.width, height: data.height });

					&#x2F;&#x2F; propagating resize, and updating values for each animation step
					self._updateCache(data);
					self._propagate(&quot;resize&quot;, event);

				}
			}
		);
	}

});

$.ui.plugin.add(&quot;resizable&quot;, &quot;containment&quot;, {

	start: function(event, ui) {
		var self = $(this).data(&quot;resizable&quot;), o = self.options, el = self.element;
		var oc = o.containment,	ce = (oc instanceof $) ? oc.get(0) : (&#x2F;parent&#x2F;.test(oc)) ? el.parent().get(0) : oc;
		if (!ce) return;

		self.containerElement = $(ce);

		if (&#x2F;document&#x2F;.test(oc) || oc == document) {
			self.containerOffset = { left: 0, top: 0 };
			self.containerPosition = { left: 0, top: 0 };

			self.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		&#x2F;&#x2F; i&#x27;m a node, so compute top, left, right, bottom
		else {
			var element = $(ce), p = [];
			$([ &quot;Top&quot;, &quot;Right&quot;, &quot;Left&quot;, &quot;Bottom&quot; ]).each(function(i, name) { p[i] = num(element.css(&quot;padding&quot; + name)); });

			self.containerOffset = element.offset();
			self.containerPosition = element.position();
			self.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			var co = self.containerOffset, ch = self.containerSize.height,	cw = self.containerSize.width,
						width = ($.ui.hasScroll(ce, &quot;left&quot;) ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			self.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function(event, ui) {
		var self = $(this).data(&quot;resizable&quot;), o = self.options,
				ps = self.containerSize, co = self.containerOffset, cs = self.size, cp = self.position,
				pRatio = self._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = self.containerElement;

		if (ce[0] != document &amp;&amp; (&#x2F;static&#x2F;).test(ce.css(&#x27;position&#x27;))) cop = co;

		if (cp.left &lt; (self._helper ? co.left : 0)) {
			self.size.width = self.size.width + (self._helper ? (self.position.left - co.left) : (self.position.left - cop.left));
			if (pRatio) self.size.height = self.size.width &#x2F; self.aspectRatio;
			self.position.left = o.helper ? co.left : 0;
		}

		if (cp.top &lt; (self._helper ? co.top : 0)) {
			self.size.height = self.size.height + (self._helper ? (self.position.top - co.top) : self.position.top);
			if (pRatio) self.size.width = self.size.height * self.aspectRatio;
			self.position.top = self._helper ? co.top : 0;
		}

		self.offset.left = self.parentData.left+self.position.left;
		self.offset.top = self.parentData.top+self.position.top;

		var woset = Math.abs( (self._helper ? self.offset.left - cop.left : (self.offset.left - cop.left)) + self.sizeDiff.width ),
					hoset = Math.abs( (self._helper ? self.offset.top - cop.top : (self.offset.top - co.top)) + self.sizeDiff.height );

		var isParent = self.containerElement.get(0) == self.element.parent().get(0),
		    isOffsetRelative = &#x2F;relative|absolute&#x2F;.test(self.containerElement.css(&#x27;position&#x27;));

		if(isParent &amp;&amp; isOffsetRelative) woset -= self.parentData.left;

		if (woset + self.size.width &gt;= self.parentData.width) {
			self.size.width = self.parentData.width - woset;
			if (pRatio) self.size.height = self.size.width &#x2F; self.aspectRatio;
		}

		if (hoset + self.size.height &gt;= self.parentData.height) {
			self.size.height = self.parentData.height - hoset;
			if (pRatio) self.size.width = self.size.height * self.aspectRatio;
		}
	},

	stop: function(event, ui){
		var self = $(this).data(&quot;resizable&quot;), o = self.options, cp = self.position,
				co = self.containerOffset, cop = self.containerPosition, ce = self.containerElement;

		var helper = $(self.helper), ho = helper.offset(), w = helper.outerWidth() - self.sizeDiff.width, h = helper.outerHeight() - self.sizeDiff.height;

		if (self._helper &amp;&amp; !o.animate &amp;&amp; (&#x2F;relative&#x2F;).test(ce.css(&#x27;position&#x27;)))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

		if (self._helper &amp;&amp; !o.animate &amp;&amp; (&#x2F;static&#x2F;).test(ce.css(&#x27;position&#x27;)))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

	}
});

$.ui.plugin.add(&quot;resizable&quot;, &quot;ghost&quot;, {

	start: function(event, ui) {

		var self = $(this).data(&quot;resizable&quot;), o = self.options, cs = self.size;

		self.ghost = self.originalElement.clone();
		self.ghost
			.css({ opacity: .25, display: &#x27;block&#x27;, position: &#x27;relative&#x27;, height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass(&#x27;ui-resizable-ghost&#x27;)
			.addClass(typeof o.ghost == &#x27;string&#x27; ? o.ghost : &#x27;&#x27;);

		self.ghost.appendTo(self.helper);

	},

	resize: function(event, ui){
		var self = $(this).data(&quot;resizable&quot;), o = self.options;
		if (self.ghost) self.ghost.css({ position: &#x27;relative&#x27;, height: self.size.height, width: self.size.width });
	},

	stop: function(event, ui){
		var self = $(this).data(&quot;resizable&quot;), o = self.options;
		if (self.ghost &amp;&amp; self.helper) self.helper.get(0).removeChild(self.ghost.get(0));
	}

});

$.ui.plugin.add(&quot;resizable&quot;, &quot;grid&quot;, {

	resize: function(event, ui) {
		var self = $(this).data(&quot;resizable&quot;), o = self.options, cs = self.size, os = self.originalSize, op = self.originalPosition, a = self.axis, ratio = o._aspectRatio || event.shiftKey;
		o.grid = typeof o.grid == &quot;number&quot; ? [o.grid, o.grid] : o.grid;
		var ox = Math.round((cs.width - os.width) &#x2F; (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) &#x2F; (o.grid[1]||1)) * (o.grid[1]||1);

		if (&#x2F;^(se|s|e)$&#x2F;.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
		}
		else if (&#x2F;^(ne)$&#x2F;.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
		}
		else if (&#x2F;^(sw)$&#x2F;.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.left = op.left - ox;
		}
		else {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
			self.position.left = op.left - ox;
		}
	}

});

var num = function(v) {
	return parseInt(v, 10) || 0;
};

var isNumber = function(value) {
	return !isNaN(parseInt(value, 10));
};

})(jQuery);

(function( $, undefined ) {

$.widget(&quot;ui.selectable&quot;, $.ui.mouse, {
	options: {
		appendTo: &#x27;body&#x27;,
		autoRefresh: true,
		distance: 0,
		filter: &#x27;*&#x27;,
		tolerance: &#x27;touch&#x27;
	},
	_create: function() {
		var self = this;

		this.element.addClass(&quot;ui-selectable&quot;);

		this.dragged = false;

		&#x2F;&#x2F; cache selectee children based on filter
		var selectees;
		this.refresh = function() {
			selectees = $(self.options.filter, self.element[0]);
			selectees.addClass(&quot;ui-selectee&quot;);
			selectees.each(function() {
				var $this = $(this);
				var pos = $this.offset();
				$.data(this, &quot;selectable-item&quot;, {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass(&#x27;ui-selected&#x27;),
					selecting: $this.hasClass(&#x27;ui-selecting&#x27;),
					unselecting: $this.hasClass(&#x27;ui-unselecting&#x27;)
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass(&quot;ui-selectee&quot;);

		this._mouseInit();

		this.helper = $(&quot;&lt;div class=&#x27;ui-selectable-helper&#x27;&gt;&lt;&#x2F;div&gt;&quot;);
	},

	destroy: function() {
		this.selectees
			.removeClass(&quot;ui-selectee&quot;)
			.removeData(&quot;selectable-item&quot;);
		this.element
			.removeClass(&quot;ui-selectable ui-selectable-disabled&quot;)
			.removeData(&quot;selectable&quot;)
			.unbind(&quot;.selectable&quot;);
		this._mouseDestroy();

		return this;
	},

	_mouseStart: function(event) {
		var self = this;

		this.opos = [event.pageX, event.pageY];

		if (this.options.disabled)
			return;

		var options = this.options;

		this.selectees = $(options.filter, this.element[0]);

		this._trigger(&quot;start&quot;, event);

		$(options.appendTo).append(this.helper);
		&#x2F;&#x2F; position helper (lasso)
		this.helper.css({
			&quot;left&quot;: event.clientX,
			&quot;top&quot;: event.clientY,
			&quot;width&quot;: 0,
			&quot;height&quot;: 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter(&#x27;.ui-selected&#x27;).each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			selectee.startselected = true;
			if (!event.metaKey &amp;&amp; !event.ctrlKey) {
				selectee.$element.removeClass(&#x27;ui-selected&#x27;);
				selectee.selected = false;
				selectee.$element.addClass(&#x27;ui-unselecting&#x27;);
				selectee.unselecting = true;
				&#x2F;&#x2F; selectable UNSELECTING callback
				self._trigger(&quot;unselecting&quot;, event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().andSelf().each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			if (selectee) {
				var doSelect = (!event.metaKey &amp;&amp; !event.ctrlKey) || !selectee.$element.hasClass(&#x27;ui-selected&#x27;);
				selectee.$element
					.removeClass(doSelect ? &quot;ui-unselecting&quot; : &quot;ui-selected&quot;)
					.addClass(doSelect ? &quot;ui-selecting&quot; : &quot;ui-unselecting&quot;);
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				&#x2F;&#x2F; selectable (UN)SELECTING callback
				if (doSelect) {
					self._trigger(&quot;selecting&quot;, event, {
						selecting: selectee.element
					});
				} else {
					self._trigger(&quot;unselecting&quot;, event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {
		var self = this;
		this.dragged = true;

		if (this.options.disabled)
			return;

		var options = this.options;

		var x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
		if (x1 &gt; x2) { var tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 &gt; y2) { var tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});

		this.selectees.each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			&#x2F;&#x2F;prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element == self.element[0])
				return;
			var hit = false;
			if (options.tolerance == &#x27;touch&#x27;) {
				hit = ( !(selectee.left &gt; x2 || selectee.right &lt; x1 || selectee.top &gt; y2 || selectee.bottom &lt; y1) );
			} else if (options.tolerance == &#x27;fit&#x27;) {
				hit = (selectee.left &gt; x1 &amp;&amp; selectee.right &lt; x2 &amp;&amp; selectee.top &gt; y1 &amp;&amp; selectee.bottom &lt; y2);
			}

			if (hit) {
				&#x2F;&#x2F; SELECT
				if (selectee.selected) {
					selectee.$element.removeClass(&#x27;ui-selected&#x27;);
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass(&#x27;ui-unselecting&#x27;);
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass(&#x27;ui-selecting&#x27;);
					selectee.selecting = true;
					&#x2F;&#x2F; selectable SELECTING callback
					self._trigger(&quot;selecting&quot;, event, {
						selecting: selectee.element
					});
				}
			} else {
				&#x2F;&#x2F; UNSELECT
				if (selectee.selecting) {
					if ((event.metaKey || event.ctrlKey) &amp;&amp; selectee.startselected) {
						selectee.$element.removeClass(&#x27;ui-selecting&#x27;);
						selectee.selecting = false;
						selectee.$element.addClass(&#x27;ui-selected&#x27;);
						selectee.selected = true;
					} else {
						selectee.$element.removeClass(&#x27;ui-selecting&#x27;);
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass(&#x27;ui-unselecting&#x27;);
							selectee.unselecting = true;
						}
						&#x2F;&#x2F; selectable UNSELECTING callback
						self._trigger(&quot;unselecting&quot;, event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey &amp;&amp; !event.ctrlKey &amp;&amp; !selectee.startselected) {
						selectee.$element.removeClass(&#x27;ui-selected&#x27;);
						selectee.selected = false;

						selectee.$element.addClass(&#x27;ui-unselecting&#x27;);
						selectee.unselecting = true;
						&#x2F;&#x2F; selectable UNSELECTING callback
						self._trigger(&quot;unselecting&quot;, event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var self = this;

		this.dragged = false;

		var options = this.options;

		$(&#x27;.ui-unselecting&#x27;, this.element[0]).each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			selectee.$element.removeClass(&#x27;ui-unselecting&#x27;);
			selectee.unselecting = false;
			selectee.startselected = false;
			self._trigger(&quot;unselected&quot;, event, {
				unselected: selectee.element
			});
		});
		$(&#x27;.ui-selecting&#x27;, this.element[0]).each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			selectee.$element.removeClass(&#x27;ui-selecting&#x27;).addClass(&#x27;ui-selected&#x27;);
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			self._trigger(&quot;selected&quot;, event, {
				selected: selectee.element
			});
		});
		this._trigger(&quot;stop&quot;, event);

		this.helper.remove();

		return false;
	}

});

$.extend($.ui.selectable, {
	version: &quot;1.8.23&quot;
});

})(jQuery);

(function( $, undefined ) {

$.widget(&quot;ui.sortable&quot;, $.ui.mouse, {
	widgetEventPrefix: &quot;sort&quot;,
	ready: false,
	options: {
		appendTo: &quot;parent&quot;,
		axis: false,
		connectWith: false,
		containment: false,
		cursor: &#x27;auto&#x27;,
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: &quot;original&quot;,
		items: &#x27;&gt; *&#x27;,
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: &quot;default&quot;,
		tolerance: &quot;intersect&quot;,
		zIndex: 1000
	},
	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass(&quot;ui-sortable&quot;);

		&#x2F;&#x2F;Get the items
		this.refresh();

		&#x2F;&#x2F;Let&#x27;s determine if the items are being displayed horizontally
		this.floating = this.items.length ? o.axis === &#x27;x&#x27; || (&#x2F;left|right&#x2F;).test(this.items[0].item.css(&#x27;float&#x27;)) || (&#x2F;inline|table-cell&#x2F;).test(this.items[0].item.css(&#x27;display&#x27;)) : false;

		&#x2F;&#x2F;Let&#x27;s determine the parent&#x27;s offset
		this.offset = this.element.offset();

		&#x2F;&#x2F;Initialize mouse events for interaction
		this._mouseInit();
		
		&#x2F;&#x2F;We&#x27;re ready to go
		this.ready = true

	},

	destroy: function() {
		$.Widget.prototype.destroy.call( this );
		this.element
			.removeClass(&quot;ui-sortable ui-sortable-disabled&quot;);
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i &gt;= 0; i-- )
			this.items[i].item.removeData(this.widgetName + &quot;-item&quot;);

		return this;
	},

	_setOption: function(key, value){
		if ( key === &quot;disabled&quot; ) {
			this.options[ key ] = value;
	
			this.widget()
				[ value ? &quot;addClass&quot; : &quot;removeClass&quot;]( &quot;ui-sortable-disabled&quot; );
		} else {
			&#x2F;&#x2F; Don&#x27;t call widget base _setOption for disable as it adds ui-state-disabled class
			$.Widget.prototype._setOption.apply(this, arguments);
		}
	},

	_mouseCapture: function(event, overrideHandle) {
		var that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type == &#x27;static&#x27;) return false;

		&#x2F;&#x2F;We have to refresh the items data once first
		this._refreshItems(event);

		&#x2F;&#x2F;Find out if the clicked node (or one of its parents) is a actual item in this.items
		var currentItem = null, self = this, nodes = $(event.target).parents().each(function() {
			if($.data(this, that.widgetName + &#x27;-item&#x27;) == self) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + &#x27;-item&#x27;) == self) currentItem = $(event.target);

		if(!currentItem) return false;
		if(this.options.handle &amp;&amp; !overrideHandle) {
			var validHandle = false;

			$(this.options.handle, currentItem).find(&quot;*&quot;).andSelf().each(function() { if(this == event.target) validHandle = true; });
			if(!validHandle) return false;
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var o = this.options, self = this;
		this.currentContainer = this;

		&#x2F;&#x2F;We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		&#x2F;&#x2F;Create and append the visible helper
		this.helper = this._createHelper(event);

		&#x2F;&#x2F;Cache the helper size
		this._cacheHelperProportions();

		&#x2F;*
		 * - Position generation -
		 * This block generates everything position related - it&#x27;s the core of draggables.
		 *&#x2F;

		&#x2F;&#x2F;Cache the margins of the original element
		this._cacheMargins();

		&#x2F;&#x2F;Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		&#x2F;&#x2F;The element&#x27;s absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { &#x2F;&#x2F;Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() &#x2F;&#x2F;This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		&#x2F;&#x2F; Only after we got the offset, we can change the helper&#x27;s position to absolute
		&#x2F;&#x2F; TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css(&quot;position&quot;, &quot;absolute&quot;);
		this.cssPosition = this.helper.css(&quot;position&quot;);
		
		&#x2F;&#x2F;Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		&#x2F;&#x2F;Adjust the mouse offset relative to the helper if &#x27;cursorAt&#x27; is supplied
		(o.cursorAt &amp;&amp; this._adjustOffsetFromHelper(o.cursorAt));

		&#x2F;&#x2F;Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		&#x2F;&#x2F;If the helper is not the original, hide the original so it&#x27;s not playing any role during the drag, won&#x27;t cause anything bad this way
		if(this.helper[0] != this.currentItem[0]) {
			this.currentItem.hide();
		}

		&#x2F;&#x2F;Create the placeholder
		this._createPlaceholder();

		&#x2F;&#x2F;Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		if(o.cursor) { &#x2F;&#x2F; cursor option
			if ($(&#x27;body&#x27;).css(&quot;cursor&quot;)) this._storedCursor = $(&#x27;body&#x27;).css(&quot;cursor&quot;);
			$(&#x27;body&#x27;).css(&quot;cursor&quot;, o.cursor);
		}

		if(o.opacity) { &#x2F;&#x2F; opacity option
			if (this.helper.css(&quot;opacity&quot;)) this._storedOpacity = this.helper.css(&quot;opacity&quot;);
			this.helper.css(&quot;opacity&quot;, o.opacity);
		}

		if(o.zIndex) { &#x2F;&#x2F; zIndex option
			if (this.helper.css(&quot;zIndex&quot;)) this._storedZIndex = this.helper.css(&quot;zIndex&quot;);
			this.helper.css(&quot;zIndex&quot;, o.zIndex);
		}

		&#x2F;&#x2F;Prepare scrolling
		if(this.scrollParent[0] != document &amp;&amp; this.scrollParent[0].tagName != &#x27;HTML&#x27;)
			this.overflowOffset = this.scrollParent.offset();

		&#x2F;&#x2F;Call callbacks
		this._trigger(&quot;start&quot;, event, this._uiHash());

		&#x2F;&#x2F;Recache the helper size
		if(!this._preserveHelperProportions)
			this._cacheHelperProportions();


		&#x2F;&#x2F;Post &#x27;activate&#x27; events to possible containers
		if(!noActivation) {
			 for (var i = this.containers.length - 1; i &gt;= 0; i--) { this.containers[i]._trigger(&quot;activate&quot;, event, self._uiHash(this)); }
		}

		&#x2F;&#x2F;Prepare possible droppables
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		if ($.ui.ddmanager &amp;&amp; !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.dragging = true;

		this.helper.addClass(&quot;ui-sortable-helper&quot;);
		this._mouseDrag(event); &#x2F;&#x2F;Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {

		&#x2F;&#x2F;Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		&#x2F;&#x2F;Do scrolling
		if(this.options.scroll) {
			var o = this.options, scrolled = false;
			if(this.scrollParent[0] != document &amp;&amp; this.scrollParent[0].tagName != &#x27;HTML&#x27;) {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY &lt; o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - this.overflowOffset.top &lt; o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX &lt; o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - this.overflowOffset.left &lt; o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;

			} else {

				if(event.pageY - $(document).scrollTop() &lt; o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) &lt; o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);

				if(event.pageX - $(document).scrollLeft() &lt; o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) &lt; o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);

			}

			if(scrolled !== false &amp;&amp; $.ui.ddmanager &amp;&amp; !o.dropBehaviour)
				$.ui.ddmanager.prepareOffsets(this, event);
		}

		&#x2F;&#x2F;Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);

		&#x2F;&#x2F;Set the helper position
		if(!this.options.axis || this.options.axis != &quot;y&quot;) this.helper[0].style.left = this.position.left+&#x27;px&#x27;;
		if(!this.options.axis || this.options.axis != &quot;x&quot;) this.helper[0].style.top = this.position.top+&#x27;px&#x27;;

		&#x2F;&#x2F;Rearrange
		for (var i = this.items.length - 1; i &gt;= 0; i--) {

			&#x2F;&#x2F;Cache variables and intersection, continue if no intersection
			var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);
			if (!intersection) continue;

			if(itemElement != this.currentItem[0] &#x2F;&#x2F;cannot intersect with itself
				&amp;&amp;	this.placeholder[intersection == 1 ? &quot;next&quot; : &quot;prev&quot;]()[0] != itemElement &#x2F;&#x2F;no useless actions that have been done before
				&amp;&amp;	!$.ui.contains(this.placeholder[0], itemElement) &#x2F;&#x2F;no action if the item moved is the parent of the item checked
				&amp;&amp; (this.options.type == &#x27;semi-dynamic&#x27; ? !$.ui.contains(this.element[0], itemElement) : true)
				&#x2F;&#x2F;&amp;&amp; itemElement.parentNode == this.placeholder[0].parentNode &#x2F;&#x2F; only rearrange items within the same container
			) {

				this.direction = intersection == 1 ? &quot;down&quot; : &quot;up&quot;;

				if (this.options.tolerance == &quot;pointer&quot; || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger(&quot;change&quot;, event, this._uiHash());
				break;
			}
		}

		&#x2F;&#x2F;Post events to containers
		this._contactContainers(event);

		&#x2F;&#x2F;Interconnect with droppables
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		&#x2F;&#x2F;Call callbacks
		this._trigger(&#x27;sort&#x27;, event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) return;

		&#x2F;&#x2F;If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager &amp;&amp; !this.options.dropBehaviour)
			$.ui.ddmanager.drop(this, event);

		if(this.options.revert) {
			var self = this;
			var cur = self.placeholder.offset();

			self.reverting = true;

			$(this.helper).animate({
				left: cur.left - this.offset.parent.left - self.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
				top: cur.top - this.offset.parent.top - self.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
			}, parseInt(this.options.revert, 10) || 500, function() {
				self._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		var self = this;

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper == &quot;original&quot;)
				this.currentItem.css(this._storedCSS).removeClass(&quot;ui-sortable-helper&quot;);
			else
				this.currentItem.show();

			&#x2F;&#x2F;Post deactivating events to containers
			for (var i = this.containers.length - 1; i &gt;= 0; i--){
				this.containers[i]._trigger(&quot;deactivate&quot;, null, self._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger(&quot;out&quot;, null, self._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			&#x2F;&#x2F;$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			if(this.options.helper != &quot;original&quot; &amp;&amp; this.helper &amp;&amp; this.helper[0].parentNode) this.helper.remove();

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o &amp;&amp; o.connected);
		var str = []; o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || &#x27;id&#x27;) || &#x27;&#x27;).match(o.expression || (&#x2F;(.+)[-=_](.+)&#x2F;));
			if(res) str.push((o.key || res[1]+&#x27;[]&#x27;)+&#x27;=&#x27;+(o.key &amp;&amp; o.expression ? res[1] : res[2]));
		});

		if(!str.length &amp;&amp; o.key) {
			str.push(o.key + &#x27;=&#x27;);
		}

		return str.join(&#x27;&amp;&#x27;);

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o &amp;&amp; o.connected);
		var ret = []; o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || &#x27;id&#x27;) || &#x27;&#x27;); });
		return ret;

	},

	&#x2F;* Be careful with the following core functions *&#x2F;
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height;

		var l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height;

		var dyClick = this.offset.click.top,
			dxClick = this.offset.click.left;

		var isOverElement = (y1 + dyClick) &gt; t &amp;&amp; (y1 + dyClick) &lt; b &amp;&amp; (x1 + dxClick) &gt; l &amp;&amp; (x1 + dxClick) &lt; r;

		if(	   this.options.tolerance == &quot;pointer&quot;
			|| this.options.forcePointerForContainers
			|| (this.options.tolerance != &quot;pointer&quot; &amp;&amp; this.helperProportions[this.floating ? &#x27;width&#x27; : &#x27;height&#x27;] &gt; item[this.floating ? &#x27;width&#x27; : &#x27;height&#x27;])
		) {
			return isOverElement;
		} else {

			return (l &lt; x1 + (this.helperProportions.width &#x2F; 2) &#x2F;&#x2F; Right Half
				&amp;&amp; x2 - (this.helperProportions.width &#x2F; 2) &lt; r &#x2F;&#x2F; Left Half
				&amp;&amp; t &lt; y1 + (this.helperProportions.height &#x2F; 2) &#x2F;&#x2F; Bottom Half
				&amp;&amp; y2 - (this.helperProportions.height &#x2F; 2) &lt; b ); &#x2F;&#x2F; Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = (this.options.axis === &#x27;x&#x27;) || $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = (this.options.axis === &#x27;y&#x27;) || $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight &amp;&amp; isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement)
			return false;

		return this.floating ?
			( ((horizontalDirection &amp;&amp; horizontalDirection == &quot;right&quot;) || verticalDirection == &quot;down&quot;) ? 2 : 1 )
			: ( verticalDirection &amp;&amp; (verticalDirection == &quot;down&quot; ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height&#x2F;2), item.height),
			isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width&#x2F;2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating &amp;&amp; horizontalDirection) {
			return ((horizontalDirection == &quot;right&quot; &amp;&amp; isOverRightHalf) || (horizontalDirection == &quot;left&quot; &amp;&amp; !isOverRightHalf));
		} else {
			return verticalDirection &amp;&amp; ((verticalDirection == &quot;down&quot; &amp;&amp; isOverBottomHalf) || (verticalDirection == &quot;up&quot; &amp;&amp; !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta != 0 &amp;&amp; (delta &gt; 0 ? &quot;down&quot; : &quot;up&quot;);
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta != 0 &amp;&amp; (delta &gt; 0 ? &quot;right&quot; : &quot;left&quot;);
	},

	refresh: function(event) {
		this._refreshItems(event);
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor == String
			? [options.connectWith]
			: options.connectWith;
	},
	
	_getItemsAsjQuery: function(connected) {

		var self = this;
		var items = [];
		var queries = [];
		var connectWith = this._connectWith();

		if(connectWith &amp;&amp; connected) {
			for (var i = connectWith.length - 1; i &gt;= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j &gt;= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst &amp;&amp; inst != this &amp;&amp; !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(&quot;.ui-sortable-helper&quot;).not(&#x27;.ui-sortable-placeholder&#x27;), inst]);
					}
				};
			};
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(&quot;.ui-sortable-helper&quot;).not(&#x27;.ui-sortable-placeholder&#x27;), this]);

		for (var i = queries.length - 1; i &gt;= 0; i--){
			queries[i][0].each(function() {
				items.push(this);
			});
		};

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(&quot;:data(&quot; + this.widgetName + &quot;-item)&quot;);

		for (var i=0; i &lt; this.items.length; i++) {

			for (var j=0; j &lt; list.length; j++) {
				if(list[j] == this.items[i].item[0])
					this.items.splice(i,1);
			};

		};

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];
		var items = this.items;
		var self = this;
		var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];
		var connectWith = this._connectWith();

		if(connectWith &amp;&amp; this.ready) { &#x2F;&#x2F;Shouldn&#x27;t be run the first time through due to massive slow-down
			for (var i = connectWith.length - 1; i &gt;= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j &gt;= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst &amp;&amp; inst != this &amp;&amp; !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				};
			};
		}

		for (var i = queries.length - 1; i &gt;= 0; i--) {
			var targetData = queries[i][1];
			var _queries = queries[i][0];

			for (var j=0, queriesLength = _queries.length; j &lt; queriesLength; j++) {
				var item = $(_queries[j]);

				item.data(this.widgetName + &#x27;-item&#x27;, targetData); &#x2F;&#x2F; Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			};
		};

	},

	refreshPositions: function(fast) {

		&#x2F;&#x2F;This has to be redone because due to the item being moved out&#x2F;into the offsetParent, the offsetParent&#x27;s position will change
		if(this.offsetParent &amp;&amp; this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		for (var i = this.items.length - 1; i &gt;= 0; i--){
			var item = this.items[i];

			&#x2F;&#x2F;We ignore calculating positions of all connected containers when we&#x27;re not over them
			if(item.instance != this.currentContainer &amp;&amp; this.currentContainer &amp;&amp; item.item[0] != this.currentItem[0])
				continue;

			var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			var p = t.offset();
			item.left = p.left;
			item.top = p.top;
		};

		if(this.options.custom &amp;&amp; this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (var i = this.containers.length - 1; i &gt;= 0; i--){
				var p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			};
		}

		return this;
	},

	_createPlaceholder: function(that) {

		var self = that || this, o = self.options;

		if(!o.placeholder || o.placeholder.constructor == String) {
			var className = o.placeholder;
			o.placeholder = {
				element: function() {

					var el = $(document.createElement(self.currentItem[0].nodeName))
						.addClass(className || self.currentItem[0].className+&quot; ui-sortable-placeholder&quot;)
						.removeClass(&quot;ui-sortable-helper&quot;)[0];

					if(!className)
						el.style.visibility = &quot;hidden&quot;;

					return el;
				},
				update: function(container, p) {

					&#x2F;&#x2F; 1. If a className is set as &#x27;placeholder option, we don&#x27;t force sizes - the class is responsible for that
					&#x2F;&#x2F; 2. The option &#x27;forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className &amp;&amp; !o.forcePlaceholderSize) return;

					&#x2F;&#x2F;If the element doesn&#x27;t have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(self.currentItem.innerHeight() - parseInt(self.currentItem.css(&#x27;paddingTop&#x27;)||0, 10) - parseInt(self.currentItem.css(&#x27;paddingBottom&#x27;)||0, 10)); };
					if(!p.width()) { p.width(self.currentItem.innerWidth() - parseInt(self.currentItem.css(&#x27;paddingLeft&#x27;)||0, 10) - parseInt(self.currentItem.css(&#x27;paddingRight&#x27;)||0, 10)); };
				}
			};
		}

		&#x2F;&#x2F;Create the placeholder
		self.placeholder = $(o.placeholder.element.call(self.element, self.currentItem));

		&#x2F;&#x2F;Append it after the actual current item
		self.currentItem.after(self.placeholder);

		&#x2F;&#x2F;Update the size of the placeholder (TODO: Logic to fuzzy, see line 316&#x2F;317)
		o.placeholder.update(self, self.placeholder);

	},

	_contactContainers: function(event) {
		
		&#x2F;&#x2F; get innermost container that intersects with item 
		var innermostContainer = null, innermostIndex = null;		
		
		
		for (var i = this.containers.length - 1; i &gt;= 0; i--){

			&#x2F;&#x2F; never consider a container that&#x27;s located within the item itself 
			if($.ui.contains(this.currentItem[0], this.containers[i].element[0]))
				continue;

			if(this._intersectsWith(this.containers[i].containerCache)) {

				&#x2F;&#x2F; if we&#x27;ve already found a container and it&#x27;s more &quot;inner&quot; than this, then continue 
				if(innermostContainer &amp;&amp; $.ui.contains(this.containers[i].element[0], innermostContainer.element[0]))
					continue;

				innermostContainer = this.containers[i]; 
				innermostIndex = i;
					
			} else {
				&#x2F;&#x2F; container doesn&#x27;t intersect. trigger &quot;out&quot; event if necessary 
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger(&quot;out&quot;, event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}
		
		&#x2F;&#x2F; if no intersecting containers found, return 
		if(!innermostContainer) return; 

		&#x2F;&#x2F; move the item into the container if it&#x27;s not there already
		if(this.containers.length === 1) {
			this.containers[innermostIndex]._trigger(&quot;over&quot;, event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} else if(this.currentContainer != this.containers[innermostIndex]) {

			&#x2F;&#x2F;When entering a new container, we will find the item with the least distance and append our item near it
			var dist = 10000; var itemWithLeastDistance = null; var base = this.positionAbs[this.containers[innermostIndex].floating ? &#x27;left&#x27; : &#x27;top&#x27;];
			for (var j = this.items.length - 1; j &gt;= 0; j--) {
				if(!$.ui.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue;
				var cur = this.containers[innermostIndex].floating ? this.items[j].item.offset().left : this.items[j].item.offset().top;
				if(Math.abs(cur - base) &lt; dist) {
					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
					this.direction = (cur - base &gt; 0) ? &#x27;down&#x27; : &#x27;up&#x27;;
				}
			}

			if(!itemWithLeastDistance &amp;&amp; !this.options.dropOnEmpty) &#x2F;&#x2F;Check if dropOnEmpty is enabled
				return;

			this.currentContainer = this.containers[innermostIndex];
			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
			this._trigger(&quot;change&quot;, event, this._uiHash());
			this.containers[innermostIndex]._trigger(&quot;change&quot;, event, this._uiHash(this));

			&#x2F;&#x2F;Update the placeholder
			this.options.placeholder.update(this.currentContainer, this.placeholder);

			this.containers[innermostIndex]._trigger(&quot;over&quot;, event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} 
	
		
	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == &#x27;clone&#x27; ? this.currentItem.clone() : this.currentItem);

		if(!helper.parents(&#x27;body&#x27;).length) &#x2F;&#x2F;Add the helper to the DOM if that didn&#x27;t happen already
			$(o.appendTo != &#x27;parent&#x27; ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);

		if(helper[0] == this.currentItem[0])
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css(&quot;position&quot;), top: this.currentItem.css(&quot;top&quot;), left: this.currentItem.css(&quot;left&quot;) };

		if(helper[0].style.width == &#x27;&#x27; || o.forceHelperSize) helper.width(this.currentItem.width());
		if(helper[0].style.height == &#x27;&#x27; || o.forceHelperSize) helper.height(this.currentItem.height());

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == &#x27;string&#x27;) {
			obj = obj.split(&#x27; &#x27;);
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if (&#x27;left&#x27; in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if (&#x27;right&#x27; in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if (&#x27;top&#x27; in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if (&#x27;bottom&#x27; in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		&#x2F;&#x2F;Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		&#x2F;&#x2F; This is a special case where we need to modify a offset calculated on start, since the following happened:
		&#x2F;&#x2F; 1. The position of the helper is absolute, so it&#x27;s position is calculated based on the next positioned parent
		&#x2F;&#x2F; 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn&#x27;t the document, which means that
		&#x2F;&#x2F;    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == &#x27;absolute&#x27; &amp;&amp; this.scrollParent[0] != document &amp;&amp; $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) &#x2F;&#x2F;This needs to be actually done for all browsers, since pageX&#x2F;pageY includes this information
		|| (this.offsetParent[0].tagName &amp;&amp; this.offsetParent[0].tagName.toLowerCase() == &#x27;html&#x27; &amp;&amp; $.browser.msie)) &#x2F;&#x2F;Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css(&quot;borderTopWidth&quot;),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css(&quot;borderLeftWidth&quot;),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == &quot;relative&quot;) {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css(&quot;top&quot;),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css(&quot;left&quot;),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css(&quot;marginLeft&quot;),10) || 0),
			top: (parseInt(this.currentItem.css(&quot;marginTop&quot;),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == &#x27;parent&#x27;) o.containment = this.helper[0].parentNode;
		if(o.containment == &#x27;document&#x27; || o.containment == &#x27;window&#x27;) this.containment = [
			0 - this.offset.relative.left - this.offset.parent.left,
			0 - this.offset.relative.top - this.offset.parent.top,
			$(o.containment == &#x27;document&#x27; ? document : window).width() - this.helperProportions.width - this.margins.left,
			($(o.containment == &#x27;document&#x27; ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(&#x2F;^(document|window|parent)$&#x2F;).test(o.containment)) {
			var ce = $(o.containment)[0];
			var co = $(o.containment).offset();
			var over = ($(ce).css(&quot;overflow&quot;) != &#x27;hidden&#x27;);

			this.containment = [
				co.left + (parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingLeft&quot;),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingTop&quot;),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingRight&quot;),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingBottom&quot;),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == &quot;absolute&quot; ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == &#x27;absolute&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (&#x2F;(html|body)&#x2F;i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	&#x2F;&#x2F; The absolute mouse position
				+ this.offset.relative.top * mod										&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				- ($.browser.safari &amp;&amp; this.cssPosition == &#x27;fixed&#x27; ? 0 : ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																&#x2F;&#x2F; The absolute mouse position
				+ this.offset.relative.left * mod										&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				- ($.browser.safari &amp;&amp; this.cssPosition == &#x27;fixed&#x27; ? 0 : ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == &#x27;absolute&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (&#x2F;(html|body)&#x2F;i).test(scroll[0].tagName);

		&#x2F;&#x2F; This is another very weird special case that only happens for relative elements:
		&#x2F;&#x2F; 1. If the css position is relative
		&#x2F;&#x2F; 2. and the scroll parent is the document or similar to the offset parent
		&#x2F;&#x2F; we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition == &#x27;relative&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; this.scrollParent[0] != this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		var pageX = event.pageX;
		var pageY = event.pageY;

		&#x2F;*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 *&#x2F;

		if(this.originalPosition) { &#x2F;&#x2F;If we are not dragging yet, we won&#x27;t check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left &lt; this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top &lt; this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left &gt; this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top &gt; this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				var top = this.originalPageY + Math.round((pageY - this.originalPageY) &#x2F; o.grid[1]) * o.grid[1];
				pageY = this.containment ? (!(top - this.offset.click.top &lt; this.containment[1] || top - this.offset.click.top &gt; this.containment[3]) ? top : (!(top - this.offset.click.top &lt; this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = this.originalPageX + Math.round((pageX - this.originalPageX) &#x2F; o.grid[0]) * o.grid[0];
				pageX = this.containment ? (!(left - this.offset.click.left &lt; this.containment[0] || left - this.offset.click.left &gt; this.containment[2]) ? left : (!(left - this.offset.click.left &lt; this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																&#x2F;&#x2F; The absolute mouse position
				- this.offset.click.top													&#x2F;&#x2F; Click offset (relative to the element)
				- this.offset.relative.top												&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				+ ($.browser.safari &amp;&amp; this.cssPosition == &#x27;fixed&#x27; ? 0 : ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																&#x2F;&#x2F; The absolute mouse position
				- this.offset.click.left												&#x2F;&#x2F; Click offset (relative to the element)
				- this.offset.relative.left												&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				+ ($.browser.safari &amp;&amp; this.cssPosition == &#x27;fixed&#x27; ? 0 : ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == &#x27;down&#x27; ? i.item[0] : i.item[0].nextSibling));

		&#x2F;&#x2F;Various things done here to improve the performance:
		&#x2F;&#x2F; 1. we create a setTimeout, that calls refreshPositions
		&#x2F;&#x2F; 2. on the instance, we have a counter variable, that get&#x27;s higher after every append
		&#x2F;&#x2F; 3. on the local scope, we copy the counter variable, and check in the timeout, if it&#x27;s still the same
		&#x2F;&#x2F; 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var self = this, counter = this.counter;

		window.setTimeout(function() {
			if(counter == self.counter) self.refreshPositions(!hardRefresh); &#x2F;&#x2F;Precompute after each DOM insertion, NOT on mousemove
		},0);

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		&#x2F;&#x2F; We delay all events that have to be triggered to after the point where the placeholder has been removed and
		&#x2F;&#x2F; everything else normalized again
		var delayedTriggers = [], self = this;

		&#x2F;&#x2F; We first have to update the dom position of the actual currentItem
		&#x2F;&#x2F; Note: don&#x27;t do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort &amp;&amp; this.currentItem.parent().length) this.placeholder.before(this.currentItem);
		this._noFinalSort = null;

		if(this.helper[0] == this.currentItem[0]) {
			for(var i in this._storedCSS) {
				if(this._storedCSS[i] == &#x27;auto&#x27; || this._storedCSS[i] == &#x27;static&#x27;) this._storedCSS[i] = &#x27;&#x27;;
			}
			this.currentItem.css(this._storedCSS).removeClass(&quot;ui-sortable-helper&quot;);
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside &amp;&amp; !noPropagation) delayedTriggers.push(function(event) { this._trigger(&quot;receive&quot;, event, this._uiHash(this.fromOutside)); });
		if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(&quot;.ui-sortable-helper&quot;)[0] || this.domPosition.parent != this.currentItem.parent()[0]) &amp;&amp; !noPropagation) delayedTriggers.push(function(event) { this._trigger(&quot;update&quot;, event, this._uiHash()); }); &#x2F;&#x2F;Trigger update callback if the DOM position has changed
		if(!$.ui.contains(this.element[0], this.currentItem[0])) { &#x2F;&#x2F;Node was moved out of the current element
			if(!noPropagation) delayedTriggers.push(function(event) { this._trigger(&quot;remove&quot;, event, this._uiHash()); });
			for (var i = this.containers.length - 1; i &gt;= 0; i--){
				if($.ui.contains(this.containers[i].element[0], this.currentItem[0]) &amp;&amp; !noPropagation) {
					delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;receive&quot;, event, this._uiHash(this)); };  }).call(this, this.containers[i]));
					delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;update&quot;, event, this._uiHash(this));  }; }).call(this, this.containers[i]));
				}
			};
		};

		&#x2F;&#x2F;Post events to containers
		for (var i = this.containers.length - 1; i &gt;= 0; i--){
			if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;deactivate&quot;, event, this._uiHash(this)); };  }).call(this, this.containers[i]));
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;out&quot;, event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				this.containers[i].containerCache.over = 0;
			}
		}

		&#x2F;&#x2F;Do what was originally in plugins
		if(this._storedCursor) $(&#x27;body&#x27;).css(&quot;cursor&quot;, this._storedCursor); &#x2F;&#x2F;Reset cursor
		if(this._storedOpacity) this.helper.css(&quot;opacity&quot;, this._storedOpacity); &#x2F;&#x2F;Reset opacity
		if(this._storedZIndex) this.helper.css(&quot;zIndex&quot;, this._storedZIndex == &#x27;auto&#x27; ? &#x27;&#x27; : this._storedZIndex); &#x2F;&#x2F;Reset z-index

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger(&quot;beforeStop&quot;, event, this._uiHash());
				for (var i=0; i &lt; delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; &#x2F;&#x2F;Trigger all delayed events
				this._trigger(&quot;stop&quot;, event, this._uiHash());
			}

			this.fromOutside = false;
			return false;
		}

		if(!noPropagation) this._trigger(&quot;beforeStop&quot;, event, this._uiHash());

		&#x2F;&#x2F;$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;

		if(!noPropagation) {
			for (var i=0; i &lt; delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; &#x2F;&#x2F;Trigger all delayed events
			this._trigger(&quot;stop&quot;, event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(inst) {
		var self = inst || this;
		return {
			helper: self.helper,
			placeholder: self.placeholder || $([]),
			position: self.position,
			originalPosition: self.originalPosition,
			offset: self.positionAbs,
			item: self.currentItem,
			sender: inst ? inst.element : null
		};
	}

});

$.extend($.ui.sortable, {
	version: &quot;1.8.23&quot;
});

})(jQuery);

;jQuery.effects || (function($, undefined) {

$.effects = {};



&#x2F;******************************************************************************&#x2F;
&#x2F;****************************** COLOR ANIMATIONS ******************************&#x2F;
&#x2F;******************************************************************************&#x2F;

&#x2F;&#x2F; override the animation for color styles
$.each([&#x27;backgroundColor&#x27;, &#x27;borderBottomColor&#x27;, &#x27;borderLeftColor&#x27;,
	&#x27;borderRightColor&#x27;, &#x27;borderTopColor&#x27;, &#x27;borderColor&#x27;, &#x27;color&#x27;, &#x27;outlineColor&#x27;],
function(i, attr) {
	$.fx.step[attr] = function(fx) {
		if (!fx.colorInit) {
			fx.start = getColor(fx.elem, attr);
			fx.end = getRGB(fx.end);
			fx.colorInit = true;
		}

		fx.elem.style[attr] = &#x27;rgb(&#x27; +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[0] - fx.start[0])) + fx.start[0], 10), 255), 0) + &#x27;,&#x27; +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[1] - fx.start[1])) + fx.start[1], 10), 255), 0) + &#x27;,&#x27; +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[2] - fx.start[2])) + fx.start[2], 10), 255), 0) + &#x27;)&#x27;;
	};
});

&#x2F;&#x2F; Color Conversion functions from highlightFade
&#x2F;&#x2F; By Blair Mitchelmore
&#x2F;&#x2F; http:&#x2F;&#x2F;jquery.offput.ca&#x2F;highlightFade&#x2F;

&#x2F;&#x2F; Parse strings looking for color tuples [255,255,255]
function getRGB(color) {
		var result;

		&#x2F;&#x2F; Check if we&#x27;re already dealing with an array of colors
		if ( color &amp;&amp; color.constructor == Array &amp;&amp; color.length == 3 )
				return color;

		&#x2F;&#x2F; Look for rgb(num,num,num)
		if (result = &#x2F;rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)&#x2F;.exec(color))
				return [parseInt(result[1],10), parseInt(result[2],10), parseInt(result[3],10)];

		&#x2F;&#x2F; Look for rgb(num%,num%,num%)
		if (result = &#x2F;rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)&#x2F;.exec(color))
				return [parseFloat(result[1])*2.55, parseFloat(result[2])*2.55, parseFloat(result[3])*2.55];

		&#x2F;&#x2F; Look for #a0b1c2
		if (result = &#x2F;#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})&#x2F;.exec(color))
				return [parseInt(result[1],16), parseInt(result[2],16), parseInt(result[3],16)];

		&#x2F;&#x2F; Look for #fff
		if (result = &#x2F;#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])&#x2F;.exec(color))
				return [parseInt(result[1]+result[1],16), parseInt(result[2]+result[2],16), parseInt(result[3]+result[3],16)];

		&#x2F;&#x2F; Look for rgba(0, 0, 0, 0) == transparent in Safari 3
		if (result = &#x2F;rgba\(0, 0, 0, 0\)&#x2F;.exec(color))
				return colors[&#x27;transparent&#x27;];

		&#x2F;&#x2F; Otherwise, we&#x27;re most likely dealing with a named color
		return colors[$.trim(color).toLowerCase()];
}

function getColor(elem, attr) {
		var color;

		do {
				&#x2F;&#x2F; jQuery &lt;1.4.3 uses curCSS, in 1.4.3 - 1.7.2 curCSS = css, 1.8+ only has css
				color = ($.curCSS || $.css)(elem, attr);

				&#x2F;&#x2F; Keep going until we find an element that has color, or we hit the body
				if ( color != &#x27;&#x27; &amp;&amp; color != &#x27;transparent&#x27; || $.nodeName(elem, &quot;body&quot;) )
						break;

				attr = &quot;backgroundColor&quot;;
		} while ( elem = elem.parentNode );

		return getRGB(color);
};

&#x2F;&#x2F; Some named colors to work with
&#x2F;&#x2F; From Interface by Stefan Petre
&#x2F;&#x2F; http:&#x2F;&#x2F;interface.eyecon.ro&#x2F;

var colors = {
	aqua:[0,255,255],
	azure:[240,255,255],
	beige:[245,245,220],
	black:[0,0,0],
	blue:[0,0,255],
	brown:[165,42,42],
	cyan:[0,255,255],
	darkblue:[0,0,139],
	darkcyan:[0,139,139],
	darkgrey:[169,169,169],
	darkgreen:[0,100,0],
	darkkhaki:[189,183,107],
	darkmagenta:[139,0,139],
	darkolivegreen:[85,107,47],
	darkorange:[255,140,0],
	darkorchid:[153,50,204],
	darkred:[139,0,0],
	darksalmon:[233,150,122],
	darkviolet:[148,0,211],
	fuchsia:[255,0,255],
	gold:[255,215,0],
	green:[0,128,0],
	indigo:[75,0,130],
	khaki:[240,230,140],
	lightblue:[173,216,230],
	lightcyan:[224,255,255],
	lightgreen:[144,238,144],
	lightgrey:[211,211,211],
	lightpink:[255,182,193],
	lightyellow:[255,255,224],
	lime:[0,255,0],
	magenta:[255,0,255],
	maroon:[128,0,0],
	navy:[0,0,128],
	olive:[128,128,0],
	orange:[255,165,0],
	pink:[255,192,203],
	purple:[128,0,128],
	violet:[128,0,128],
	red:[255,0,0],
	silver:[192,192,192],
	white:[255,255,255],
	yellow:[255,255,0],
	transparent: [255,255,255]
};



&#x2F;******************************************************************************&#x2F;
&#x2F;****************************** CLASS ANIMATIONS ******************************&#x2F;
&#x2F;******************************************************************************&#x2F;

var classAnimationActions = [&#x27;add&#x27;, &#x27;remove&#x27;, &#x27;toggle&#x27;],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

function getElementStyles() {
	var style = document.defaultView
			? document.defaultView.getComputedStyle(this, null)
			: this.currentStyle,
		newStyle = {},
		key,
		camelCase;

	&#x2F;&#x2F; webkit enumerates style porperties
	if (style &amp;&amp; style.length &amp;&amp; style[0] &amp;&amp; style[style[0]]) {
		var len = style.length;
		while (len--) {
			key = style[len];
			if (typeof style[key] == &#x27;string&#x27;) {
				camelCase = key.replace(&#x2F;\-(\w)&#x2F;g, function(all, letter){
					return letter.toUpperCase();
				});
				newStyle[camelCase] = style[key];
			}
		}
	} else {
		for (key in style) {
			if (typeof style[key] === &#x27;string&#x27;) {
				newStyle[key] = style[key];
			}
		}
	}
	
	return newStyle;
}

function filterStyles(styles) {
	var name, value;
	for (name in styles) {
		value = styles[name];
		if (
			&#x2F;&#x2F; ignore null and undefined values
			value == null ||
			&#x2F;&#x2F; ignore functions (when does this occur?)
			$.isFunction(value) ||
			&#x2F;&#x2F; shorthand styles that need to be expanded
			name in shorthandStyles ||
			&#x2F;&#x2F; ignore scrollbars (break in IE)
			(&#x2F;scrollbar&#x2F;).test(name) ||

			&#x2F;&#x2F; only colors or values that can be converted to numbers
			(!(&#x2F;color&#x2F;i).test(name) &amp;&amp; isNaN(parseFloat(value)))
		) {
			delete styles[name];
		}
	}
	
	return styles;
}

function styleDifference(oldStyle, newStyle) {
	var diff = { _: 0 }, &#x2F;&#x2F; http:&#x2F;&#x2F;dev.jquery.com&#x2F;ticket&#x2F;5459
		name;

	for (name in newStyle) {
		if (oldStyle[name] != newStyle[name]) {
			diff[name] = newStyle[name];
		}
	}

	return diff;
}

$.effects.animateClass = function(value, duration, easing, callback) {
	if ($.isFunction(easing)) {
		callback = easing;
		easing = null;
	}

	return this.queue(function() {
		var that = $(this),
			originalStyleAttr = that.attr(&#x27;style&#x27;) || &#x27; &#x27;,
			originalStyle = filterStyles(getElementStyles.call(this)),
			newStyle,
			className = that.attr(&#x27;class&#x27;) || &quot;&quot;;

		$.each(classAnimationActions, function(i, action) {
			if (value[action]) {
				that[action + &#x27;Class&#x27;](value[action]);
			}
		});
		newStyle = filterStyles(getElementStyles.call(this));
		that.attr(&#x27;class&#x27;, className);

		that.animate(styleDifference(originalStyle, newStyle), {
			queue: false,
			duration: duration,
			easing: easing,
			complete: function() {
				$.each(classAnimationActions, function(i, action) {
					if (value[action]) { that[action + &#x27;Class&#x27;](value[action]); }
				});
				&#x2F;&#x2F; work around bug in IE by clearing the cssText before setting it
				if (typeof that.attr(&#x27;style&#x27;) == &#x27;object&#x27;) {
					that.attr(&#x27;style&#x27;).cssText = &#x27;&#x27;;
					that.attr(&#x27;style&#x27;).cssText = originalStyleAttr;
				} else {
					that.attr(&#x27;style&#x27;, originalStyleAttr);
				}
				if (callback) { callback.apply(this, arguments); }
				$.dequeue( this );
			}
		});
	});
};

$.fn.extend({
	_addClass: $.fn.addClass,
	addClass: function(classNames, speed, easing, callback) {
		return speed ? $.effects.animateClass.apply(this, [{ add: classNames },speed,easing,callback]) : this._addClass(classNames);
	},

	_removeClass: $.fn.removeClass,
	removeClass: function(classNames,speed,easing,callback) {
		return speed ? $.effects.animateClass.apply(this, [{ remove: classNames },speed,easing,callback]) : this._removeClass(classNames);
	},

	_toggleClass: $.fn.toggleClass,
	toggleClass: function(classNames, force, speed, easing, callback) {
		if ( typeof force == &quot;boolean&quot; || force === undefined ) {
			if ( !speed ) {
				&#x2F;&#x2F; without speed parameter;
				return this._toggleClass(classNames, force);
			} else {
				return $.effects.animateClass.apply(this, [(force?{add:classNames}:{remove:classNames}),speed,easing,callback]);
			}
		} else {
			&#x2F;&#x2F; without switch parameter;
			return $.effects.animateClass.apply(this, [{ toggle: classNames },force,speed,easing]);
		}
	},

	switchClass: function(remove,add,speed,easing,callback) {
		return $.effects.animateClass.apply(this, [{ add: add, remove: remove },speed,easing,callback]);
	}
});



&#x2F;******************************************************************************&#x2F;
&#x2F;*********************************** EFFECTS **********************************&#x2F;
&#x2F;******************************************************************************&#x2F;

$.extend($.effects, {
	version: &quot;1.8.23&quot;,

	&#x2F;&#x2F; Saves a set of properties in a data storage
	save: function(element, set) {
		for(var i=0; i &lt; set.length; i++) {
			if(set[i] !== null) element.data(&quot;ec.storage.&quot;+set[i], element[0].style[set[i]]);
		}
	},

	&#x2F;&#x2F; Restores a set of previously saved properties from a data storage
	restore: function(element, set) {
		for(var i=0; i &lt; set.length; i++) {
			if(set[i] !== null) element.css(set[i], element.data(&quot;ec.storage.&quot;+set[i]));
		}
	},

	setMode: function(el, mode) {
		if (mode == &#x27;toggle&#x27;) mode = el.is(&#x27;:hidden&#x27;) ? &#x27;show&#x27; : &#x27;hide&#x27;; &#x2F;&#x2F; Set for toggle
		return mode;
	},

	getBaseline: function(origin, original) { &#x2F;&#x2F; Translates a [top,left] array into a baseline value
		&#x2F;&#x2F; this should be a little more flexible in the future to handle a string &amp; hash
		var y, x;
		switch (origin[0]) {
			case &#x27;top&#x27;: y = 0; break;
			case &#x27;middle&#x27;: y = 0.5; break;
			case &#x27;bottom&#x27;: y = 1; break;
			default: y = origin[0] &#x2F; original.height;
		};
		switch (origin[1]) {
			case &#x27;left&#x27;: x = 0; break;
			case &#x27;center&#x27;: x = 0.5; break;
			case &#x27;right&#x27;: x = 1; break;
			default: x = origin[1] &#x2F; original.width;
		};
		return {x: x, y: y};
	},

	&#x2F;&#x2F; Wraps the element around a wrapper that copies position properties
	createWrapper: function(element) {

		&#x2F;&#x2F; if the element is already wrapped, return it
		if (element.parent().is(&#x27;.ui-effects-wrapper&#x27;)) {
			return element.parent();
		}

		&#x2F;&#x2F; wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				&#x27;float&#x27;: element.css(&#x27;float&#x27;)
			},
			wrapper = $(&#x27;&lt;div&gt;&lt;&#x2F;div&gt;&#x27;)
				.addClass(&#x27;ui-effects-wrapper&#x27;)
				.css({
					fontSize: &#x27;100%&#x27;,
					background: &#x27;transparent&#x27;,
					border: &#x27;none&#x27;,
					margin: 0,
					padding: 0
				}),
			active = document.activeElement;

		&#x2F;&#x2F; support: Firefox
		&#x2F;&#x2F; Firefox incorrectly exposes anonymous content
		&#x2F;&#x2F; https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		&#x2F;&#x2F; Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}
		
		wrapper = element.parent(); &#x2F;&#x2F;Hotfix for jQuery 1.4 since some change in wrap() seems to actually loose the reference to the wrapped element

		&#x2F;&#x2F; transfer positioning properties to the wrapper
		if (element.css(&#x27;position&#x27;) == &#x27;static&#x27;) {
			wrapper.css({ position: &#x27;relative&#x27; });
			element.css({ position: &#x27;relative&#x27; });
		} else {
			$.extend(props, {
				position: element.css(&#x27;position&#x27;),
				zIndex: element.css(&#x27;z-index&#x27;)
			});
			$.each([&#x27;top&#x27;, &#x27;left&#x27;, &#x27;bottom&#x27;, &#x27;right&#x27;], function(i, pos) {
				props[pos] = element.css(pos);
				if (isNaN(parseInt(props[pos], 10))) {
					props[pos] = &#x27;auto&#x27;;
				}
			});
			element.css({position: &#x27;relative&#x27;, top: 0, left: 0, right: &#x27;auto&#x27;, bottom: &#x27;auto&#x27; });
		}

		return wrapper.css(props).show();
	},

	removeWrapper: function(element) {
		var parent,
			active = document.activeElement;
		
		if (element.parent().is(&#x27;.ui-effects-wrapper&#x27;)) {
			parent = element.parent().replaceWith(element);
			&#x2F;&#x2F; Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
			return parent;
		}
			
		return element;
	},

	setTransition: function(element, list, factor, value) {
		value = value || {};
		$.each(list, function(i, x){
			var unit = element.cssUnit(x);
			if (unit[0] &gt; 0) value[x] = unit[0] * factor + unit[1];
		});
		return value;
	}
});


function _normalizeArguments(effect, options, speed, callback) {
	&#x2F;&#x2F; shift params for method overloading
	if (typeof effect == &#x27;object&#x27;) {
		callback = options;
		speed = null;
		options = effect;
		effect = options.effect;
	}
	if ($.isFunction(options)) {
		callback = options;
		speed = null;
		options = {};
	}
        if (typeof options == &#x27;number&#x27; || $.fx.speeds[options]) {
		callback = speed;
		speed = options;
		options = {};
	}
	if ($.isFunction(speed)) {
		callback = speed;
		speed = null;
	}

	options = options || {};

	speed = speed || options.duration;
	speed = $.fx.off ? 0 : typeof speed == &#x27;number&#x27;
		? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;

	callback = callback || options.complete;

	return [effect, options, speed, callback];
}

function standardSpeed( speed ) {
	&#x2F;&#x2F; valid standard speeds
	if ( !speed || typeof speed === &quot;number&quot; || $.fx.speeds[ speed ] ) {
		return true;
	}
	
	&#x2F;&#x2F; invalid strings - treat as &quot;normal&quot; speed
	if ( typeof speed === &quot;string&quot; &amp;&amp; !$.effects[ speed ] ) {
		return true;
	}
	
	return false;
}

$.fn.extend({
	effect: function(effect, options, speed, callback) {
		var args = _normalizeArguments.apply(this, arguments),
			&#x2F;&#x2F; TODO: make effects take actual parameters instead of a hash
			args2 = {
				options: args[1],
				duration: args[2],
				callback: args[3]
			},
			mode = args2.options.mode,
			effectMethod = $.effects[effect];
		
		if ( $.fx.off || !effectMethod ) {
			&#x2F;&#x2F; delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args2.duration, args2.callback );
			} else {
				return this.each(function() {
					if ( args2.callback ) {
						args2.callback.call( this );
					}
				});
			}
		}
		
		return effectMethod.call(this, args2);
	},

	_show: $.fn.show,
	show: function(speed) {
		if ( standardSpeed( speed ) ) {
			return this._show.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = &#x27;show&#x27;;
			return this.effect.apply(this, args);
		}
	},

	_hide: $.fn.hide,
	hide: function(speed) {
		if ( standardSpeed( speed ) ) {
			return this._hide.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = &#x27;hide&#x27;;
			return this.effect.apply(this, args);
		}
	},

	&#x2F;&#x2F; jQuery core overloads toggle and creates _toggle
	__toggle: $.fn.toggle,
	toggle: function(speed) {
		if ( standardSpeed( speed ) || typeof speed === &quot;boolean&quot; || $.isFunction( speed ) ) {
			return this.__toggle.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = &#x27;toggle&#x27;;
			return this.effect.apply(this, args);
		}
	},

	&#x2F;&#x2F; helper functions
	cssUnit: function(key) {
		var style = this.css(key), val = [];
		$.each( [&#x27;em&#x27;,&#x27;px&#x27;,&#x27;%&#x27;,&#x27;pt&#x27;], function(i, unit){
			if(style.indexOf(unit) &gt; 0)
				val = [parseFloat(style), unit];
		});
		return val;
	}
});



&#x2F;******************************************************************************&#x2F;
&#x2F;*********************************** EASING ***********************************&#x2F;
&#x2F;******************************************************************************&#x2F;

&#x2F;&#x2F; based on easing equations from Robert Penner (http:&#x2F;&#x2F;www.robertpenner.com&#x2F;easing)

var baseEasings = {};

$.each( [ &quot;Quad&quot;, &quot;Cubic&quot;, &quot;Quart&quot;, &quot;Quint&quot;, &quot;Expo&quot; ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function ( p ) {
		return 1 - Math.cos( p * Math.PI &#x2F; 2 );
	},
	Circ: function ( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI &#x2F; 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function ( p ) {
		var pow2,
			bounce = 4;

		while ( p &lt; ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) &#x2F; 11 ) {}
		return 1 &#x2F; Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) &#x2F; 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ &quot;easeIn&quot; + name ] = easeIn;
	$.easing[ &quot;easeOut&quot; + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ &quot;easeInOut&quot; + name ] = function( p ) {
		return p &lt; .5 ?
			easeIn( p * 2 ) &#x2F; 2 :
			easeIn( p * -2 + 2 ) &#x2F; -2 + 1;
	};
});

})(jQuery);

(function( $, undefined ) {

$.effects.blind = function(o) {

	return this.queue(function() {

		&#x2F;&#x2F; Create element
		var el = $(this), props = [&#x27;position&#x27;,&#x27;top&#x27;,&#x27;bottom&#x27;,&#x27;left&#x27;,&#x27;right&#x27;];

		&#x2F;&#x2F; Set options
		var mode = $.effects.setMode(el, o.options.mode || &#x27;hide&#x27;); &#x2F;&#x2F; Set Mode
		var direction = o.options.direction || &#x27;vertical&#x27;; &#x2F;&#x2F; Default direction

		&#x2F;&#x2F; Adjust
		$.effects.save(el, props); el.show(); &#x2F;&#x2F; Save &amp; Show
		var wrapper = $.effects.createWrapper(el).css({overflow:&#x27;hidden&#x27;}); &#x2F;&#x2F; Create Wrapper
		var ref = (direction == &#x27;vertical&#x27;) ? &#x27;height&#x27; : &#x27;width&#x27;;
		var distance = (direction == &#x27;vertical&#x27;) ? wrapper.height() : wrapper.width();
		if(mode == &#x27;show&#x27;) wrapper.css(ref, 0); &#x2F;&#x2F; Shift

		&#x2F;&#x2F; Animation
		var animation = {};
		animation[ref] = mode == &#x27;show&#x27; ? distance : 0;

		&#x2F;&#x2F; Animate
		wrapper.animate(animation, o.duration, o.options.easing, function() {
			if(mode == &#x27;hide&#x27;) el.hide(); &#x2F;&#x2F; Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); &#x2F;&#x2F; Restore
			if(o.callback) o.callback.apply(el[0], arguments); &#x2F;&#x2F; Callback
			el.dequeue();
		});

	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.bounce = function(o) {

	return this.queue(function() {

		&#x2F;&#x2F; Create element
		var el = $(this), props = [&#x27;position&#x27;,&#x27;top&#x27;,&#x27;bottom&#x27;,&#x27;left&#x27;,&#x27;right&#x27;];

		&#x2F;&#x2F; Set options
		var mode = $.effects.setMode(el, o.options.mode || &#x27;effect&#x27;); &#x2F;&#x2F; Set Mode
		var direction = o.options.direction || &#x27;up&#x27;; &#x2F;&#x2F; Default direction
		var distance = o.options.distance || 20; &#x2F;&#x2F; Default distance
		var times = o.options.times || 5; &#x2F;&#x2F; Default # of times
		var speed = o.duration || 250; &#x2F;&#x2F; Default speed per bounce
		if (&#x2F;show|hide&#x2F;.test(mode)) props.push(&#x27;opacity&#x27;); &#x2F;&#x2F; Avoid touching opacity to prevent clearType and PNG issues in IE

		&#x2F;&#x2F; Adjust
		$.effects.save(el, props); el.show(); &#x2F;&#x2F; Save &amp; Show
		$.effects.createWrapper(el); &#x2F;&#x2F; Create Wrapper
		var ref = (direction == &#x27;up&#x27; || direction == &#x27;down&#x27;) ? &#x27;top&#x27; : &#x27;left&#x27;;
		var motion = (direction == &#x27;up&#x27; || direction == &#x27;left&#x27;) ? &#x27;pos&#x27; : &#x27;neg&#x27;;
		var distance = o.options.distance || (ref == &#x27;top&#x27; ? el.outerHeight(true) &#x2F; 3 : el.outerWidth(true) &#x2F; 3);
		if (mode == &#x27;show&#x27;) el.css(&#x27;opacity&#x27;, 0).css(ref, motion == &#x27;pos&#x27; ? -distance : distance); &#x2F;&#x2F; Shift
		if (mode == &#x27;hide&#x27;) distance = distance &#x2F; (times * 2);
		if (mode != &#x27;hide&#x27;) times--;

		&#x2F;&#x2F; Animate
		if (mode == &#x27;show&#x27;) { &#x2F;&#x2F; Show Bounce
			var animation = {opacity: 1};
			animation[ref] = (motion == &#x27;pos&#x27; ? &#x27;+=&#x27; : &#x27;-=&#x27;) + distance;
			el.animate(animation, speed &#x2F; 2, o.options.easing);
			distance = distance &#x2F; 2;
			times--;
		};
		for (var i = 0; i &lt; times; i++) { &#x2F;&#x2F; Bounces
			var animation1 = {}, animation2 = {};
			animation1[ref] = (motion == &#x27;pos&#x27; ? &#x27;-=&#x27; : &#x27;+=&#x27;) + distance;
			animation2[ref] = (motion == &#x27;pos&#x27; ? &#x27;+=&#x27; : &#x27;-=&#x27;) + distance;
			el.animate(animation1, speed &#x2F; 2, o.options.easing).animate(animation2, speed &#x2F; 2, o.options.easing);
			distance = (mode == &#x27;hide&#x27;) ? distance * 2 : distance &#x2F; 2;
		};
		if (mode == &#x27;hide&#x27;) { &#x2F;&#x2F; Last Bounce
			var animation = {opacity: 0};
			animation[ref] = (motion == &#x27;pos&#x27; ? &#x27;-=&#x27; : &#x27;+=&#x27;)  + distance;
			el.animate(animation, speed &#x2F; 2, o.options.easing, function(){
				el.hide(); &#x2F;&#x2F; Hide
				$.effects.restore(el, props); $.effects.removeWrapper(el); &#x2F;&#x2F; Restore
				if(o.callback) o.callback.apply(this, arguments); &#x2F;&#x2F; Callback
			});
		} else {
			var animation1 = {}, animation2 = {};
			animation1[ref] = (motion == &#x27;pos&#x27; ? &#x27;-=&#x27; : &#x27;+=&#x27;) + distance;
			animation2[ref] = (motion == &#x27;pos&#x27; ? &#x27;+=&#x27; : &#x27;-=&#x27;) + distance;
			el.animate(animation1, speed &#x2F; 2, o.options.easing).animate(animation2, speed &#x2F; 2, o.options.easing, function(){
				$.effects.restore(el, props); $.effects.removeWrapper(el); &#x2F;&#x2F; Restore
				if(o.callback) o.callback.apply(this, arguments); &#x2F;&#x2F; Callback
			});
		};
		el.queue(&#x27;fx&#x27;, function() { el.dequeue(); });
		el.dequeue();
	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.clip = function(o) {

	return this.queue(function() {

		&#x2F;&#x2F; Create element
		var el = $(this), props = [&#x27;position&#x27;,&#x27;top&#x27;,&#x27;bottom&#x27;,&#x27;left&#x27;,&#x27;right&#x27;,&#x27;height&#x27;,&#x27;width&#x27;];

		&#x2F;&#x2F; Set options
		var mode = $.effects.setMode(el, o.options.mode || &#x27;hide&#x27;); &#x2F;&#x2F; Set Mode
		var direction = o.options.direction || &#x27;vertical&#x27;; &#x2F;&#x2F; Default direction

		&#x2F;&#x2F; Adjust
		$.effects.save(el, props); el.show(); &#x2F;&#x2F; Save &amp; Show
		var wrapper = $.effects.createWrapper(el).css({overflow:&#x27;hidden&#x27;}); &#x2F;&#x2F; Create Wrapper
		var animate = el[0].tagName == &#x27;IMG&#x27; ? wrapper : el;
		var ref = {
			size: (direction == &#x27;vertical&#x27;) ? &#x27;height&#x27; : &#x27;width&#x27;,
			position: (direction == &#x27;vertical&#x27;) ? &#x27;top&#x27; : &#x27;left&#x27;
		};
		var distance = (direction == &#x27;vertical&#x27;) ? animate.height() : animate.width();
		if(mode == &#x27;show&#x27;) { animate.css(ref.size, 0); animate.css(ref.position, distance &#x2F; 2); } &#x2F;&#x2F; Shift

		&#x2F;&#x2F; Animation
		var animation = {};
		animation[ref.size] = mode == &#x27;show&#x27; ? distance : 0;
		animation[ref.position] = mode == &#x27;show&#x27; ? 0 : distance &#x2F; 2;

		&#x2F;&#x2F; Animate
		animate.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == &#x27;hide&#x27;) el.hide(); &#x2F;&#x2F; Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); &#x2F;&#x2F; Restore
			if(o.callback) o.callback.apply(el[0], arguments); &#x2F;&#x2F; Callback
			el.dequeue();
		}});

	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.drop = function(o) {

	return this.queue(function() {

		&#x2F;&#x2F; Create element
		var el = $(this), props = [&#x27;position&#x27;,&#x27;top&#x27;,&#x27;bottom&#x27;,&#x27;left&#x27;,&#x27;right&#x27;,&#x27;opacity&#x27;];

		&#x2F;&#x2F; Set options
		var mode = $.effects.setMode(el, o.options.mode || &#x27;hide&#x27;); &#x2F;&#x2F; Set Mode
		var direction = o.options.direction || &#x27;left&#x27;; &#x2F;&#x2F; Default Direction

		&#x2F;&#x2F; Adjust
		$.effects.save(el, props); el.show(); &#x2F;&#x2F; Save &amp; Show
		$.effects.createWrapper(el); &#x2F;&#x2F; Create Wrapper
		var ref = (direction == &#x27;up&#x27; || direction == &#x27;down&#x27;) ? &#x27;top&#x27; : &#x27;left&#x27;;
		var motion = (direction == &#x27;up&#x27; || direction == &#x27;left&#x27;) ? &#x27;pos&#x27; : &#x27;neg&#x27;;
		var distance = o.options.distance || (ref == &#x27;top&#x27; ? el.outerHeight( true ) &#x2F; 2 : el.outerWidth( true ) &#x2F; 2);
		if (mode == &#x27;show&#x27;) el.css(&#x27;opacity&#x27;, 0).css(ref, motion == &#x27;pos&#x27; ? -distance : distance); &#x2F;&#x2F; Shift

		&#x2F;&#x2F; Animation
		var animation = {opacity: mode == &#x27;show&#x27; ? 1 : 0};
		animation[ref] = (mode == &#x27;show&#x27; ? (motion == &#x27;pos&#x27; ? &#x27;+=&#x27; : &#x27;-=&#x27;) : (motion == &#x27;pos&#x27; ? &#x27;-=&#x27; : &#x27;+=&#x27;)) + distance;

		&#x2F;&#x2F; Animate
		el.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == &#x27;hide&#x27;) el.hide(); &#x2F;&#x2F; Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); &#x2F;&#x2F; Restore
			if(o.callback) o.callback.apply(this, arguments); &#x2F;&#x2F; Callback
			el.dequeue();
		}});

	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.explode = function(o) {

	return this.queue(function() {

	var rows = o.options.pieces ? Math.round(Math.sqrt(o.options.pieces)) : 3;
	var cells = o.options.pieces ? Math.round(Math.sqrt(o.options.pieces)) : 3;

	o.options.mode = o.options.mode == &#x27;toggle&#x27; ? ($(this).is(&#x27;:visible&#x27;) ? &#x27;hide&#x27; : &#x27;show&#x27;) : o.options.mode;
	var el = $(this).show().css(&#x27;visibility&#x27;, &#x27;hidden&#x27;);
	var offset = el.offset();

	&#x2F;&#x2F;Substract the margins - not fixing the problem yet.
	offset.top -= parseInt(el.css(&quot;marginTop&quot;),10) || 0;
	offset.left -= parseInt(el.css(&quot;marginLeft&quot;),10) || 0;

	var width = el.outerWidth(true);
	var height = el.outerHeight(true);

	for(var i=0;i&lt;rows;i++) { &#x2F;&#x2F; =
		for(var j=0;j&lt;cells;j++) { &#x2F;&#x2F; ||
			el
				.clone()
				.appendTo(&#x27;body&#x27;)
				.wrap(&#x27;&lt;div&gt;&lt;&#x2F;div&gt;&#x27;)
				.css({
					position: &#x27;absolute&#x27;,
					visibility: &#x27;visible&#x27;,
					left: -j*(width&#x2F;cells),
					top: -i*(height&#x2F;rows)
				})
				.parent()
				.addClass(&#x27;ui-effects-explode&#x27;)
				.css({
					position: &#x27;absolute&#x27;,
					overflow: &#x27;hidden&#x27;,
					width: width&#x2F;cells,
					height: height&#x2F;rows,
					left: offset.left + j*(width&#x2F;cells) + (o.options.mode == &#x27;show&#x27; ? (j-Math.floor(cells&#x2F;2))*(width&#x2F;cells) : 0),
					top: offset.top + i*(height&#x2F;rows) + (o.options.mode == &#x27;show&#x27; ? (i-Math.floor(rows&#x2F;2))*(height&#x2F;rows) : 0),
					opacity: o.options.mode == &#x27;show&#x27; ? 0 : 1
				}).animate({
					left: offset.left + j*(width&#x2F;cells) + (o.options.mode == &#x27;show&#x27; ? 0 : (j-Math.floor(cells&#x2F;2))*(width&#x2F;cells)),
					top: offset.top + i*(height&#x2F;rows) + (o.options.mode == &#x27;show&#x27; ? 0 : (i-Math.floor(rows&#x2F;2))*(height&#x2F;rows)),
					opacity: o.options.mode == &#x27;show&#x27; ? 1 : 0
				}, o.duration || 500);
		}
	}

	&#x2F;&#x2F; Set a timeout, to call the callback approx. when the other animations have finished
	setTimeout(function() {

		o.options.mode == &#x27;show&#x27; ? el.css({ visibility: &#x27;visible&#x27; }) : el.css({ visibility: &#x27;visible&#x27; }).hide();
				if(o.callback) o.callback.apply(el[0]); &#x2F;&#x2F; Callback
				el.dequeue();

				$(&#x27;div.ui-effects-explode&#x27;).remove();

	}, o.duration || 500);


	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.fade = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || &#x27;hide&#x27;);

		elem.animate({ opacity: mode }, {
			queue: false,
			duration: o.duration,
			easing: o.options.easing,
			complete: function() {
				(o.callback &amp;&amp; o.callback.apply(this, arguments));
				elem.dequeue();
			}
		});
	});
};

})(jQuery);

(function( $, undefined ) {

$.effects.fold = function(o) {

	return this.queue(function() {

		&#x2F;&#x2F; Create element
		var el = $(this), props = [&#x27;position&#x27;,&#x27;top&#x27;,&#x27;bottom&#x27;,&#x27;left&#x27;,&#x27;right&#x27;];

		&#x2F;&#x2F; Set options
		var mode = $.effects.setMode(el, o.options.mode || &#x27;hide&#x27;); &#x2F;&#x2F; Set Mode
		var size = o.options.size || 15; &#x2F;&#x2F; Default fold size
		var horizFirst = !(!o.options.horizFirst); &#x2F;&#x2F; Ensure a boolean value
		var duration = o.duration ? o.duration &#x2F; 2 : $.fx.speeds._default &#x2F; 2;

		&#x2F;&#x2F; Adjust
		$.effects.save(el, props); el.show(); &#x2F;&#x2F; Save &amp; Show
		var wrapper = $.effects.createWrapper(el).css({overflow:&#x27;hidden&#x27;}); &#x2F;&#x2F; Create Wrapper
		var widthFirst = ((mode == &#x27;show&#x27;) != horizFirst);
		var ref = widthFirst ? [&#x27;width&#x27;, &#x27;height&#x27;] : [&#x27;height&#x27;, &#x27;width&#x27;];
		var distance = widthFirst ? [wrapper.width(), wrapper.height()] : [wrapper.height(), wrapper.width()];
		var percent = &#x2F;([0-9]+)%&#x2F;.exec(size);
		if(percent) size = parseInt(percent[1],10) &#x2F; 100 * distance[mode == &#x27;hide&#x27; ? 0 : 1];
		if(mode == &#x27;show&#x27;) wrapper.css(horizFirst ? {height: 0, width: size} : {height: size, width: 0}); &#x2F;&#x2F; Shift

		&#x2F;&#x2F; Animation
		var animation1 = {}, animation2 = {};
		animation1[ref[0]] = mode == &#x27;show&#x27; ? distance[0] : size;
		animation2[ref[1]] = mode == &#x27;show&#x27; ? distance[1] : 0;

		&#x2F;&#x2F; Animate
		wrapper.animate(animation1, duration, o.options.easing)
		.animate(animation2, duration, o.options.easing, function() {
			if(mode == &#x27;hide&#x27;) el.hide(); &#x2F;&#x2F; Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); &#x2F;&#x2F; Restore
			if(o.callback) o.callback.apply(el[0], arguments); &#x2F;&#x2F; Callback
			el.dequeue();
		});

	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.highlight = function(o) {
	return this.queue(function() {
		var elem = $(this),
			props = [&#x27;backgroundImage&#x27;, &#x27;backgroundColor&#x27;, &#x27;opacity&#x27;],
			mode = $.effects.setMode(elem, o.options.mode || &#x27;show&#x27;),
			animation = {
				backgroundColor: elem.css(&#x27;backgroundColor&#x27;)
			};

		if (mode == &#x27;hide&#x27;) {
			animation.opacity = 0;
		}

		$.effects.save(elem, props);
		elem
			.show()
			.css({
				backgroundImage: &#x27;none&#x27;,
				backgroundColor: o.options.color || &#x27;#ffff99&#x27;
			})
			.animate(animation, {
				queue: false,
				duration: o.duration,
				easing: o.options.easing,
				complete: function() {
					(mode == &#x27;hide&#x27; &amp;&amp; elem.hide());
					$.effects.restore(elem, props);
					(mode == &#x27;show&#x27; &amp;&amp; !$.support.opacity &amp;&amp; this.style.removeAttribute(&#x27;filter&#x27;));
					(o.callback &amp;&amp; o.callback.apply(this, arguments));
					elem.dequeue();
				}
			});
	});
};

})(jQuery);

(function( $, undefined ) {

$.effects.pulsate = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || &#x27;show&#x27;),
			times = ((o.options.times || 5) * 2) - 1,
			duration = o.duration ? o.duration &#x2F; 2 : $.fx.speeds._default &#x2F; 2,
			isVisible = elem.is(&#x27;:visible&#x27;),
			animateTo = 0;

		if (!isVisible) {
			elem.css(&#x27;opacity&#x27;, 0).show();
			animateTo = 1;
		}

		if ((mode == &#x27;hide&#x27; &amp;&amp; isVisible) || (mode == &#x27;show&#x27; &amp;&amp; !isVisible)) {
			times--;
		}

		for (var i = 0; i &lt; times; i++) {
			elem.animate({ opacity: animateTo }, duration, o.options.easing);
			animateTo = (animateTo + 1) % 2;
		}

		elem.animate({ opacity: animateTo }, duration, o.options.easing, function() {
			if (animateTo == 0) {
				elem.hide();
			}
			(o.callback &amp;&amp; o.callback.apply(this, arguments));
		});

		elem
			.queue(&#x27;fx&#x27;, function() { elem.dequeue(); })
			.dequeue();
	});
};

})(jQuery);

(function( $, undefined ) {

$.effects.puff = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || &#x27;hide&#x27;),
			percent = parseInt(o.options.percent, 10) || 150,
			factor = percent &#x2F; 100,
			original = { height: elem.height(), width: elem.width() };

		$.extend(o.options, {
			fade: true,
			mode: mode,
			percent: mode == &#x27;hide&#x27; ? percent : 100,
			from: mode == &#x27;hide&#x27;
				? original
				: {
					height: original.height * factor,
					width: original.width * factor
				}
		});

		elem.effect(&#x27;scale&#x27;, o.options, o.duration, o.callback);
		elem.dequeue();
	});
};

$.effects.scale = function(o) {

	return this.queue(function() {

		&#x2F;&#x2F; Create element
		var el = $(this);

		&#x2F;&#x2F; Set options
		var options = $.extend(true, {}, o.options);
		var mode = $.effects.setMode(el, o.options.mode || &#x27;effect&#x27;); &#x2F;&#x2F; Set Mode
		var percent = parseInt(o.options.percent,10) || (parseInt(o.options.percent,10) == 0 ? 0 : (mode == &#x27;hide&#x27; ? 0 : 100)); &#x2F;&#x2F; Set default scaling percent
		var direction = o.options.direction || &#x27;both&#x27;; &#x2F;&#x2F; Set default axis
		var origin = o.options.origin; &#x2F;&#x2F; The origin of the scaling
		if (mode != &#x27;effect&#x27;) { &#x2F;&#x2F; Set default origin and restore for show&#x2F;hide
			options.origin = origin || [&#x27;middle&#x27;,&#x27;center&#x27;];
			options.restore = true;
		}
		var original = {height: el.height(), width: el.width()}; &#x2F;&#x2F; Save original
		el.from = o.options.from || (mode == &#x27;show&#x27; ? {height: 0, width: 0} : original); &#x2F;&#x2F; Default from state

		&#x2F;&#x2F; Adjust
		var factor = { &#x2F;&#x2F; Set scaling factor
			y: direction != &#x27;horizontal&#x27; ? (percent &#x2F; 100) : 1,
			x: direction != &#x27;vertical&#x27; ? (percent &#x2F; 100) : 1
		};
		el.to = {height: original.height * factor.y, width: original.width * factor.x}; &#x2F;&#x2F; Set to state

		if (o.options.fade) { &#x2F;&#x2F; Fade option to support puff
			if (mode == &#x27;show&#x27;) {el.from.opacity = 0; el.to.opacity = 1;};
			if (mode == &#x27;hide&#x27;) {el.from.opacity = 1; el.to.opacity = 0;};
		};

		&#x2F;&#x2F; Animation
		options.from = el.from; options.to = el.to; options.mode = mode;

		&#x2F;&#x2F; Animate
		el.effect(&#x27;size&#x27;, options, o.duration, o.callback);
		el.dequeue();
	});

};

$.effects.size = function(o) {

	return this.queue(function() {

		&#x2F;&#x2F; Create element
		var el = $(this), props = [&#x27;position&#x27;,&#x27;top&#x27;,&#x27;bottom&#x27;,&#x27;left&#x27;,&#x27;right&#x27;,&#x27;width&#x27;,&#x27;height&#x27;,&#x27;overflow&#x27;,&#x27;opacity&#x27;];
		var props1 = [&#x27;position&#x27;,&#x27;top&#x27;,&#x27;bottom&#x27;,&#x27;left&#x27;,&#x27;right&#x27;,&#x27;overflow&#x27;,&#x27;opacity&#x27;]; &#x2F;&#x2F; Always restore
		var props2 = [&#x27;width&#x27;,&#x27;height&#x27;,&#x27;overflow&#x27;]; &#x2F;&#x2F; Copy for children
		var cProps = [&#x27;fontSize&#x27;];
		var vProps = [&#x27;borderTopWidth&#x27;, &#x27;borderBottomWidth&#x27;, &#x27;paddingTop&#x27;, &#x27;paddingBottom&#x27;];
		var hProps = [&#x27;borderLeftWidth&#x27;, &#x27;borderRightWidth&#x27;, &#x27;paddingLeft&#x27;, &#x27;paddingRight&#x27;];

		&#x2F;&#x2F; Set options
		var mode = $.effects.setMode(el, o.options.mode || &#x27;effect&#x27;); &#x2F;&#x2F; Set Mode
		var restore = o.options.restore || false; &#x2F;&#x2F; Default restore
		var scale = o.options.scale || &#x27;both&#x27;; &#x2F;&#x2F; Default scale mode
		var origin = o.options.origin; &#x2F;&#x2F; The origin of the sizing
		var original = {height: el.height(), width: el.width()}; &#x2F;&#x2F; Save original
		el.from = o.options.from || original; &#x2F;&#x2F; Default from state
		el.to = o.options.to || original; &#x2F;&#x2F; Default to state
		&#x2F;&#x2F; Adjust
		if (origin) { &#x2F;&#x2F; Calculate baseline shifts
			var baseline = $.effects.getBaseline(origin, original);
			el.from.top = (original.height - el.from.height) * baseline.y;
			el.from.left = (original.width - el.from.width) * baseline.x;
			el.to.top = (original.height - el.to.height) * baseline.y;
			el.to.left = (original.width - el.to.width) * baseline.x;
		};
		var factor = { &#x2F;&#x2F; Set scaling factor
			from: {y: el.from.height &#x2F; original.height, x: el.from.width &#x2F; original.width},
			to: {y: el.to.height &#x2F; original.height, x: el.to.width &#x2F; original.width}
		};
		if (scale == &#x27;box&#x27; || scale == &#x27;both&#x27;) { &#x2F;&#x2F; Scale the css box
			if (factor.from.y != factor.to.y) { &#x2F;&#x2F; Vertical props scaling
				props = props.concat(vProps);
				el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
				el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
			};
			if (factor.from.x != factor.to.x) { &#x2F;&#x2F; Horizontal props scaling
				props = props.concat(hProps);
				el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
				el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
			};
		};
		if (scale == &#x27;content&#x27; || scale == &#x27;both&#x27;) { &#x2F;&#x2F; Scale the content
			if (factor.from.y != factor.to.y) { &#x2F;&#x2F; Vertical props scaling
				props = props.concat(cProps);
				el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
				el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
			};
		};
		$.effects.save(el, restore ? props : props1); el.show(); &#x2F;&#x2F; Save &amp; Show
		$.effects.createWrapper(el); &#x2F;&#x2F; Create Wrapper
		el.css(&#x27;overflow&#x27;,&#x27;hidden&#x27;).css(el.from); &#x2F;&#x2F; Shift

		&#x2F;&#x2F; Animate
		if (scale == &#x27;content&#x27; || scale == &#x27;both&#x27;) { &#x2F;&#x2F; Scale the children
			vProps = vProps.concat([&#x27;marginTop&#x27;,&#x27;marginBottom&#x27;]).concat(cProps); &#x2F;&#x2F; Add margins&#x2F;font-size
			hProps = hProps.concat([&#x27;marginLeft&#x27;,&#x27;marginRight&#x27;]); &#x2F;&#x2F; Add margins
			props2 = props.concat(vProps).concat(hProps); &#x2F;&#x2F; Concat
			el.find(&quot;*[width]&quot;).each(function(){
				var child = $(this);
				if (restore) $.effects.save(child, props2);
				var c_original = {height: child.height(), width: child.width()}; &#x2F;&#x2F; Save original
				child.from = {height: c_original.height * factor.from.y, width: c_original.width * factor.from.x};
				child.to = {height: c_original.height * factor.to.y, width: c_original.width * factor.to.x};
				if (factor.from.y != factor.to.y) { &#x2F;&#x2F; Vertical props scaling
					child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
					child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
				};
				if (factor.from.x != factor.to.x) { &#x2F;&#x2F; Horizontal props scaling
					child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
					child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
				};
				child.css(child.from); &#x2F;&#x2F; Shift children
				child.animate(child.to, o.duration, o.options.easing, function(){
					if (restore) $.effects.restore(child, props2); &#x2F;&#x2F; Restore children
				}); &#x2F;&#x2F; Animate children
			});
		};

		&#x2F;&#x2F; Animate
		el.animate(el.to, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if (el.to.opacity === 0) {
				el.css(&#x27;opacity&#x27;, el.from.opacity);
			}
			if(mode == &#x27;hide&#x27;) el.hide(); &#x2F;&#x2F; Hide
			$.effects.restore(el, restore ? props : props1); $.effects.removeWrapper(el); &#x2F;&#x2F; Restore
			if(o.callback) o.callback.apply(this, arguments); &#x2F;&#x2F; Callback
			el.dequeue();
		}});

	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.shake = function(o) {

	return this.queue(function() {

		&#x2F;&#x2F; Create element
		var el = $(this), props = [&#x27;position&#x27;,&#x27;top&#x27;,&#x27;bottom&#x27;,&#x27;left&#x27;,&#x27;right&#x27;];

		&#x2F;&#x2F; Set options
		var mode = $.effects.setMode(el, o.options.mode || &#x27;effect&#x27;); &#x2F;&#x2F; Set Mode
		var direction = o.options.direction || &#x27;left&#x27;; &#x2F;&#x2F; Default direction
		var distance = o.options.distance || 20; &#x2F;&#x2F; Default distance
		var times = o.options.times || 3; &#x2F;&#x2F; Default # of times
		var speed = o.duration || o.options.duration || 140; &#x2F;&#x2F; Default speed per shake

		&#x2F;&#x2F; Adjust
		$.effects.save(el, props); el.show(); &#x2F;&#x2F; Save &amp; Show
		$.effects.createWrapper(el); &#x2F;&#x2F; Create Wrapper
		var ref = (direction == &#x27;up&#x27; || direction == &#x27;down&#x27;) ? &#x27;top&#x27; : &#x27;left&#x27;;
		var motion = (direction == &#x27;up&#x27; || direction == &#x27;left&#x27;) ? &#x27;pos&#x27; : &#x27;neg&#x27;;

		&#x2F;&#x2F; Animation
		var animation = {}, animation1 = {}, animation2 = {};
		animation[ref] = (motion == &#x27;pos&#x27; ? &#x27;-=&#x27; : &#x27;+=&#x27;)  + distance;
		animation1[ref] = (motion == &#x27;pos&#x27; ? &#x27;+=&#x27; : &#x27;-=&#x27;)  + distance * 2;
		animation2[ref] = (motion == &#x27;pos&#x27; ? &#x27;-=&#x27; : &#x27;+=&#x27;)  + distance * 2;

		&#x2F;&#x2F; Animate
		el.animate(animation, speed, o.options.easing);
		for (var i = 1; i &lt; times; i++) { &#x2F;&#x2F; Shakes
			el.animate(animation1, speed, o.options.easing).animate(animation2, speed, o.options.easing);
		};
		el.animate(animation1, speed, o.options.easing).
		animate(animation, speed &#x2F; 2, o.options.easing, function(){ &#x2F;&#x2F; Last shake
			$.effects.restore(el, props); $.effects.removeWrapper(el); &#x2F;&#x2F; Restore
			if(o.callback) o.callback.apply(this, arguments); &#x2F;&#x2F; Callback
		});
		el.queue(&#x27;fx&#x27;, function() { el.dequeue(); });
		el.dequeue();
	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.slide = function(o) {

	return this.queue(function() {

		&#x2F;&#x2F; Create element
		var el = $(this), props = [&#x27;position&#x27;,&#x27;top&#x27;,&#x27;bottom&#x27;,&#x27;left&#x27;,&#x27;right&#x27;];

		&#x2F;&#x2F; Set options
		var mode = $.effects.setMode(el, o.options.mode || &#x27;show&#x27;); &#x2F;&#x2F; Set Mode
		var direction = o.options.direction || &#x27;left&#x27;; &#x2F;&#x2F; Default Direction

		&#x2F;&#x2F; Adjust
		$.effects.save(el, props); el.show(); &#x2F;&#x2F; Save &amp; Show
		$.effects.createWrapper(el).css({overflow:&#x27;hidden&#x27;}); &#x2F;&#x2F; Create Wrapper
		var ref = (direction == &#x27;up&#x27; || direction == &#x27;down&#x27;) ? &#x27;top&#x27; : &#x27;left&#x27;;
		var motion = (direction == &#x27;up&#x27; || direction == &#x27;left&#x27;) ? &#x27;pos&#x27; : &#x27;neg&#x27;;
		var distance = o.options.distance || (ref == &#x27;top&#x27; ? el.outerHeight( true ) : el.outerWidth( true ));
		if (mode == &#x27;show&#x27;) el.css(ref, motion == &#x27;pos&#x27; ? (isNaN(distance) ? &quot;-&quot; + distance : -distance) : distance); &#x2F;&#x2F; Shift

		&#x2F;&#x2F; Animation
		var animation = {};
		animation[ref] = (mode == &#x27;show&#x27; ? (motion == &#x27;pos&#x27; ? &#x27;+=&#x27; : &#x27;-=&#x27;) : (motion == &#x27;pos&#x27; ? &#x27;-=&#x27; : &#x27;+=&#x27;)) + distance;

		&#x2F;&#x2F; Animate
		el.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == &#x27;hide&#x27;) el.hide(); &#x2F;&#x2F; Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); &#x2F;&#x2F; Restore
			if(o.callback) o.callback.apply(this, arguments); &#x2F;&#x2F; Callback
			el.dequeue();
		}});

	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.transfer = function(o) {
	return this.queue(function() {
		var elem = $(this),
			target = $(o.options.to),
			endPosition = target.offset(),
			animation = {
				top: endPosition.top,
				left: endPosition.left,
				height: target.innerHeight(),
				width: target.innerWidth()
			},
			startPosition = elem.offset(),
			transfer = $(&#x27;&lt;div class=&quot;ui-effects-transfer&quot;&gt;&lt;&#x2F;div&gt;&#x27;)
				.appendTo(document.body)
				.addClass(o.options.className)
				.css({
					top: startPosition.top,
					left: startPosition.left,
					height: elem.innerHeight(),
					width: elem.innerWidth(),
					position: &#x27;absolute&#x27;
				})
				.animate(animation, o.duration, o.options.easing, function() {
					transfer.remove();
					(o.callback &amp;&amp; o.callback.apply(elem[0], arguments));
					elem.dequeue();
				});
	});
};

})(jQuery);

(function( $, undefined ) {

$.widget( &quot;ui.accordion&quot;, {
	options: {
		active: 0,
		animated: &quot;slide&quot;,
		autoHeight: true,
		clearStyle: false,
		collapsible: false,
		event: &quot;click&quot;,
		fillSpace: false,
		header: &quot;&gt; li &gt; :first-child,&gt; :not(li):even&quot;,
		icons: {
			header: &quot;ui-icon-triangle-1-e&quot;,
			headerSelected: &quot;ui-icon-triangle-1-s&quot;
		},
		navigation: false,
		navigationFilter: function() {
			return this.href.toLowerCase() === location.href.toLowerCase();
		}
	},

	_create: function() {
		var self = this,
			options = self.options;

		self.running = 0;

		self.element
			.addClass( &quot;ui-accordion ui-widget ui-helper-reset&quot; )
			&#x2F;&#x2F; in lack of child-selectors in CSS
			&#x2F;&#x2F; we need to mark top-LIs in a UL-accordion for some IE-fix
			.children( &quot;li&quot; )
				.addClass( &quot;ui-accordion-li-fix&quot; );

		self.headers = self.element.find( options.header )
			.addClass( &quot;ui-accordion-header ui-helper-reset ui-state-default ui-corner-all&quot; )
			.bind( &quot;mouseenter.accordion&quot;, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( &quot;ui-state-hover&quot; );
			})
			.bind( &quot;mouseleave.accordion&quot;, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( &quot;ui-state-hover&quot; );
			})
			.bind( &quot;focus.accordion&quot;, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( &quot;ui-state-focus&quot; );
			})
			.bind( &quot;blur.accordion&quot;, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( &quot;ui-state-focus&quot; );
			});

		self.headers.next()
			.addClass( &quot;ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom&quot; );

		if ( options.navigation ) {
			var current = self.element.find( &quot;a&quot; ).filter( options.navigationFilter ).eq( 0 );
			if ( current.length ) {
				var header = current.closest( &quot;.ui-accordion-header&quot; );
				if ( header.length ) {
					&#x2F;&#x2F; anchor within header
					self.active = header;
				} else {
					&#x2F;&#x2F; anchor within content
					self.active = current.closest( &quot;.ui-accordion-content&quot; ).prev();
				}
			}
		}

		self.active = self._findActive( self.active || options.active )
			.addClass( &quot;ui-state-default ui-state-active&quot; )
			.toggleClass( &quot;ui-corner-all&quot; )
			.toggleClass( &quot;ui-corner-top&quot; );
		self.active.next().addClass( &quot;ui-accordion-content-active&quot; );

		self._createIcons();
		self.resize();
		
		&#x2F;&#x2F; ARIA
		self.element.attr( &quot;role&quot;, &quot;tablist&quot; );

		self.headers
			.attr( &quot;role&quot;, &quot;tab&quot; )
			.bind( &quot;keydown.accordion&quot;, function( event ) {
				return self._keydown( event );
			})
			.next()
				.attr( &quot;role&quot;, &quot;tabpanel&quot; );

		self.headers
			.not( self.active || &quot;&quot; )
			.attr({
				&quot;aria-expanded&quot;: &quot;false&quot;,
				&quot;aria-selected&quot;: &quot;false&quot;,
				tabIndex: -1
			})
			.next()
				.hide();

		&#x2F;&#x2F; make sure at least one header is in the tab order
		if ( !self.active.length ) {
			self.headers.eq( 0 ).attr( &quot;tabIndex&quot;, 0 );
		} else {
			self.active
				.attr({
					&quot;aria-expanded&quot;: &quot;true&quot;,
					&quot;aria-selected&quot;: &quot;true&quot;,
					tabIndex: 0
				});
		}

		&#x2F;&#x2F; only need links in tab order for Safari
		if ( !$.browser.safari ) {
			self.headers.find( &quot;a&quot; ).attr( &quot;tabIndex&quot;, -1 );
		}

		if ( options.event ) {
			self.headers.bind( options.event.split(&quot; &quot;).join(&quot;.accordion &quot;) + &quot;.accordion&quot;, function(event) {
				self._clickHandler.call( self, event, this );
				event.preventDefault();
			});
		}
	},

	_createIcons: function() {
		var options = this.options;
		if ( options.icons ) {
			$( &quot;&lt;span&gt;&lt;&#x2F;span&gt;&quot; )
				.addClass( &quot;ui-icon &quot; + options.icons.header )
				.prependTo( this.headers );
			this.active.children( &quot;.ui-icon&quot; )
				.toggleClass(options.icons.header)
				.toggleClass(options.icons.headerSelected);
			this.element.addClass( &quot;ui-accordion-icons&quot; );
		}
	},

	_destroyIcons: function() {
		this.headers.children( &quot;.ui-icon&quot; ).remove();
		this.element.removeClass( &quot;ui-accordion-icons&quot; );
	},

	destroy: function() {
		var options = this.options;

		this.element
			.removeClass( &quot;ui-accordion ui-widget ui-helper-reset&quot; )
			.removeAttr( &quot;role&quot; );

		this.headers
			.unbind( &quot;.accordion&quot; )
			.removeClass( &quot;ui-accordion-header ui-accordion-disabled ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top&quot; )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-expanded&quot; )
			.removeAttr( &quot;aria-selected&quot; )
			.removeAttr( &quot;tabIndex&quot; );

		this.headers.find( &quot;a&quot; ).removeAttr( &quot;tabIndex&quot; );
		this._destroyIcons();
		var contents = this.headers.next()
			.css( &quot;display&quot;, &quot;&quot; )
			.removeAttr( &quot;role&quot; )
			.removeClass( &quot;ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-accordion-disabled ui-state-disabled&quot; );
		if ( options.autoHeight || options.fillHeight ) {
			contents.css( &quot;height&quot;, &quot;&quot; );
		}

		return $.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );
			
		if ( key == &quot;active&quot; ) {
			this.activate( value );
		}
		if ( key == &quot;icons&quot; ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}
		&#x2F;&#x2F; #5332 - opacity doesn&#x27;t cascade to positioned elements in IE
		&#x2F;&#x2F; so we need to add the disabled class to the headers and panels
		if ( key == &quot;disabled&quot; ) {
			this.headers.add(this.headers.next())
				[ value ? &quot;addClass&quot; : &quot;removeClass&quot; ](
					&quot;ui-accordion-disabled ui-state-disabled&quot; );
		}
	},

	_keydown: function( event ) {
		if ( this.options.disabled || event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._clickHandler( { target: event.target }, event.target );
				event.preventDefault();
		}

		if ( toFocus ) {
			$( event.target ).attr( &quot;tabIndex&quot;, -1 );
			$( toFocus ).attr( &quot;tabIndex&quot;, 0 );
			toFocus.focus();
			return false;
		}

		return true;
	},

	resize: function() {
		var options = this.options,
			maxHeight;

		if ( options.fillSpace ) {
			if ( $.browser.msie ) {
				var defOverflow = this.element.parent().css( &quot;overflow&quot; );
				this.element.parent().css( &quot;overflow&quot;, &quot;hidden&quot;);
			}
			maxHeight = this.element.parent().height();
			if ($.browser.msie) {
				this.element.parent().css( &quot;overflow&quot;, defOverflow );
			}

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( &quot;overflow&quot;, &quot;auto&quot; );
		} else if ( options.autoHeight ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).height( &quot;&quot; ).height() );
				})
				.height( maxHeight );
		}

		return this;
	},

	activate: function( index ) {
		&#x2F;&#x2F; TODO this gets called on init, changing the option without an explicit call for that
		this.options.active = index;
		&#x2F;&#x2F; call clickHandler with custom event
		var active = this._findActive( index )[ 0 ];
		this._clickHandler( { target: active }, active );

		return this;
	},

	_findActive: function( selector ) {
		return selector
			? typeof selector === &quot;number&quot;
				? this.headers.filter( &quot;:eq(&quot; + selector + &quot;)&quot; )
				: this.headers.not( this.headers.not( selector ) )
			: selector === false
				? $( [] )
				: this.headers.filter( &quot;:eq(0)&quot; );
	},

	&#x2F;&#x2F; TODO isn&#x27;t event.target enough? why the separate target argument?
	_clickHandler: function( event, target ) {
		var options = this.options;
		if ( options.disabled ) {
			return;
		}

		&#x2F;&#x2F; called only when using activate(false) to close all parts programmatically
		if ( !event.target ) {
			if ( !options.collapsible ) {
				return;
			}
			this.active
				.removeClass( &quot;ui-state-active ui-corner-top&quot; )
				.addClass( &quot;ui-state-default ui-corner-all&quot; )
				.children( &quot;.ui-icon&quot; )
					.removeClass( options.icons.headerSelected )
					.addClass( options.icons.header );
			this.active.next().addClass( &quot;ui-accordion-content-active&quot; );
			var toHide = this.active.next(),
				data = {
					options: options,
					newHeader: $( [] ),
					oldHeader: options.active,
					newContent: $( [] ),
					oldContent: toHide
				},
				toShow = ( this.active = $( [] ) );
			this._toggle( toShow, toHide, data );
			return;
		}

		&#x2F;&#x2F; get the click target
		var clicked = $( event.currentTarget || target ),
			clickedIsActive = clicked[0] === this.active[0];

		&#x2F;&#x2F; TODO the option is changed, is that correct?
		&#x2F;&#x2F; TODO if it is correct, shouldn&#x27;t that happen after determining that the click is valid?
		options.active = options.collapsible &amp;&amp; clickedIsActive ?
			false :
			this.headers.index( clicked );

		&#x2F;&#x2F; if animations are still active, or the active header is the target, ignore click
		if ( this.running || ( !options.collapsible &amp;&amp; clickedIsActive ) ) {
			return;
		}

		&#x2F;&#x2F; find elements to show and hide
		var active = this.active,
			toShow = clicked.next(),
			toHide = this.active.next(),
			data = {
				options: options,
				newHeader: clickedIsActive &amp;&amp; options.collapsible ? $([]) : clicked,
				oldHeader: this.active,
				newContent: clickedIsActive &amp;&amp; options.collapsible ? $([]) : toShow,
				oldContent: toHide
			},
			down = this.headers.index( this.active[0] ) &gt; this.headers.index( clicked[0] );

		&#x2F;&#x2F; when the call to ._toggle() comes after the class changes
		&#x2F;&#x2F; it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $([]) : clicked;
		this._toggle( toShow, toHide, data, clickedIsActive, down );

		&#x2F;&#x2F; switch classes
		active
			.removeClass( &quot;ui-state-active ui-corner-top&quot; )
			.addClass( &quot;ui-state-default ui-corner-all&quot; )
			.children( &quot;.ui-icon&quot; )
				.removeClass( options.icons.headerSelected )
				.addClass( options.icons.header );
		if ( !clickedIsActive ) {
			clicked
				.removeClass( &quot;ui-state-default ui-corner-all&quot; )
				.addClass( &quot;ui-state-active ui-corner-top&quot; )
				.children( &quot;.ui-icon&quot; )
					.removeClass( options.icons.header )
					.addClass( options.icons.headerSelected );
			clicked
				.next()
				.addClass( &quot;ui-accordion-content-active&quot; );
		}

		return;
	},

	_toggle: function( toShow, toHide, data, clickedIsActive, down ) {
		var self = this,
			options = self.options;

		self.toShow = toShow;
		self.toHide = toHide;
		self.data = data;

		var complete = function() {
			if ( !self ) {
				return;
			}
			return self._completed.apply( self, arguments );
		};

		&#x2F;&#x2F; trigger changestart event
		self._trigger( &quot;changestart&quot;, null, self.data );

		&#x2F;&#x2F; count elements to animate
		self.running = toHide.size() === 0 ? toShow.size() : toHide.size();

		if ( options.animated ) {
			var animOptions = {};

			if ( options.collapsible &amp;&amp; clickedIsActive ) {
				animOptions = {
					toShow: $( [] ),
					toHide: toHide,
					complete: complete,
					down: down,
					autoHeight: options.autoHeight || options.fillSpace
				};
			} else {
				animOptions = {
					toShow: toShow,
					toHide: toHide,
					complete: complete,
					down: down,
					autoHeight: options.autoHeight || options.fillSpace
				};
			}

			if ( !options.proxied ) {
				options.proxied = options.animated;
			}

			if ( !options.proxiedDuration ) {
				options.proxiedDuration = options.duration;
			}

			options.animated = $.isFunction( options.proxied ) ?
				options.proxied( animOptions ) :
				options.proxied;

			options.duration = $.isFunction( options.proxiedDuration ) ?
				options.proxiedDuration( animOptions ) :
				options.proxiedDuration;

			var animations = $.ui.accordion.animations,
				duration = options.duration,
				easing = options.animated;

			if ( easing &amp;&amp; !animations[ easing ] &amp;&amp; !$.easing[ easing ] ) {
				easing = &quot;slide&quot;;
			}
			if ( !animations[ easing ] ) {
				animations[ easing ] = function( options ) {
					this.slide( options, {
						easing: easing,
						duration: duration || 700
					});
				};
			}

			animations[ easing ]( animOptions );
		} else {
			if ( options.collapsible &amp;&amp; clickedIsActive ) {
				toShow.toggle();
			} else {
				toHide.hide();
				toShow.show();
			}

			complete( true );
		}

		&#x2F;&#x2F; TODO assert that the blur and focus triggers are really necessary, remove otherwise
		toHide.prev()
			.attr({
				&quot;aria-expanded&quot;: &quot;false&quot;,
				&quot;aria-selected&quot;: &quot;false&quot;,
				tabIndex: -1
			})
			.blur();
		toShow.prev()
			.attr({
				&quot;aria-expanded&quot;: &quot;true&quot;,
				&quot;aria-selected&quot;: &quot;true&quot;,
				tabIndex: 0
			})
			.focus();
	},

	_completed: function( cancel ) {
		this.running = cancel ? 0 : --this.running;
		if ( this.running ) {
			return;
		}

		if ( this.options.clearStyle ) {
			this.toShow.add( this.toHide ).css({
				height: &quot;&quot;,
				overflow: &quot;&quot;
			});
		}

		&#x2F;&#x2F; other classes are removed before the animation; this one needs to stay until completed
		this.toHide.removeClass( &quot;ui-accordion-content-active&quot; );
		&#x2F;&#x2F; Work around for rendering bug in IE (#5421)
		if ( this.toHide.length ) {
			this.toHide.parent()[0].className = this.toHide.parent()[0].className;
		}

		this._trigger( &quot;change&quot;, null, this.data );
	}
});

$.extend( $.ui.accordion, {
	version: &quot;1.8.23&quot;,
	animations: {
		slide: function( options, additions ) {
			options = $.extend({
				easing: &quot;swing&quot;,
				duration: 300
			}, options, additions );
			if ( !options.toHide.size() ) {
				options.toShow.animate({
					height: &quot;show&quot;,
					paddingTop: &quot;show&quot;,
					paddingBottom: &quot;show&quot;
				}, options );
				return;
			}
			if ( !options.toShow.size() ) {
				options.toHide.animate({
					height: &quot;hide&quot;,
					paddingTop: &quot;hide&quot;,
					paddingBottom: &quot;hide&quot;
				}, options );
				return;
			}
			var overflow = options.toShow.css( &quot;overflow&quot; ),
				percentDone = 0,
				showProps = {},
				hideProps = {},
				fxAttrs = [ &quot;height&quot;, &quot;paddingTop&quot;, &quot;paddingBottom&quot; ],
				originalWidth;
			&#x2F;&#x2F; fix width before calculating height of hidden element
			var s = options.toShow;
			originalWidth = s[0].style.width;
			s.width( s.parent().width()
				- parseFloat( s.css( &quot;paddingLeft&quot; ) )
				- parseFloat( s.css( &quot;paddingRight&quot; ) )
				- ( parseFloat( s.css( &quot;borderLeftWidth&quot; ) ) || 0 )
				- ( parseFloat( s.css( &quot;borderRightWidth&quot; ) ) || 0 ) );

			$.each( fxAttrs, function( i, prop ) {
				hideProps[ prop ] = &quot;hide&quot;;

				var parts = ( &quot;&quot; + $.css( options.toShow[0], prop ) ).match( &#x2F;^([\d+-.]+)(.*)$&#x2F; );
				showProps[ prop ] = {
					value: parts[ 1 ],
					unit: parts[ 2 ] || &quot;px&quot;
				};
			});
			options.toShow.css({ height: 0, overflow: &quot;hidden&quot; }).show();
			options.toHide
				.filter( &quot;:hidden&quot; )
					.each( options.complete )
				.end()
				.filter( &quot;:visible&quot; )
				.animate( hideProps, {
				step: function( now, settings ) {
					&#x2F;&#x2F; only calculate the percent when animating height
					&#x2F;&#x2F; IE gets very inconsistent results when animating elements
					&#x2F;&#x2F; with small values, which is common for padding
					if ( settings.prop == &quot;height&quot; ) {
						percentDone = ( settings.end - settings.start === 0 ) ? 0 :
							( settings.now - settings.start ) &#x2F; ( settings.end - settings.start );
					}

					options.toShow[ 0 ].style[ settings.prop ] =
						( percentDone * showProps[ settings.prop ].value )
						+ showProps[ settings.prop ].unit;
				},
				duration: options.duration,
				easing: options.easing,
				complete: function() {
					if ( !options.autoHeight ) {
						options.toShow.css( &quot;height&quot;, &quot;&quot; );
					}
					options.toShow.css({
						width: originalWidth,
						overflow: overflow
					});
					options.complete();
				}
			});
		},
		bounceslide: function( options ) {
			this.slide( options, {
				easing: options.down ? &quot;easeOutBounce&quot; : &quot;swing&quot;,
				duration: options.down ? 1000 : 200
			});
		}
	}
});

})( jQuery );

(function( $, undefined ) {

&#x2F;&#x2F; used to prevent race conditions with remote data sources
var requestIndex = 0;

$.widget( &quot;ui.autocomplete&quot;, {
	options: {
		appendTo: &quot;body&quot;,
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: &quot;left top&quot;,
			at: &quot;left bottom&quot;,
			collision: &quot;none&quot;
		},
		source: null
	},

	pending: 0,

	_create: function() {
		var self = this,
			doc = this.element[ 0 ].ownerDocument,
			suppressKeyPress;
		this.isMultiLine = this.element.is( &quot;textarea&quot; );

		this.element
			.addClass( &quot;ui-autocomplete-input&quot; )
			.attr( &quot;autocomplete&quot;, &quot;off&quot; )
			&#x2F;&#x2F; TODO verify these actually work as intended
			.attr({
				role: &quot;textbox&quot;,
				&quot;aria-autocomplete&quot;: &quot;list&quot;,
				&quot;aria-haspopup&quot;: &quot;true&quot;
			})
			.bind( &quot;keydown.autocomplete&quot;, function( event ) {
				if ( self.options.disabled || self.element.propAttr( &quot;readOnly&quot; ) ) {
					return;
				}

				suppressKeyPress = false;
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					self._move( &quot;previousPage&quot;, event );
					break;
				case keyCode.PAGE_DOWN:
					self._move( &quot;nextPage&quot;, event );
					break;
				case keyCode.UP:
					self._keyEvent( &quot;previous&quot;, event );
					break;
				case keyCode.DOWN:
					self._keyEvent( &quot;next&quot;, event );
					break;
				case keyCode.ENTER:
				case keyCode.NUMPAD_ENTER:
					&#x2F;&#x2F; when menu is open and has focus
					if ( self.menu.active ) {
						&#x2F;&#x2F; #6055 - Opera still allows the keypress to occur
						&#x2F;&#x2F; which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
					}
					&#x2F;&#x2F;passthrough - ENTER and TAB both select the current element
				case keyCode.TAB:
					if ( !self.menu.active ) {
						return;
					}
					self.menu.select( event );
					break;
				case keyCode.ESCAPE:
					self.element.val( self.term );
					self.close( event );
					break;
				default:
					&#x2F;&#x2F; keypress is triggered before the input value is changed
					clearTimeout( self.searching );
					self.searching = setTimeout(function() {
						&#x2F;&#x2F; only search if the value has changed
						if ( self.term != self.element.val() ) {
							self.selectedItem = null;
							self.search( null, event );
						}
					}, self.options.delay );
					break;
				}
			})
			.bind( &quot;keypress.autocomplete&quot;, function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					event.preventDefault();
				}
			})
			.bind( &quot;focus.autocomplete&quot;, function() {
				if ( self.options.disabled ) {
					return;
				}

				self.selectedItem = null;
				self.previous = self.element.val();
			})
			.bind( &quot;blur.autocomplete&quot;, function( event ) {
				if ( self.options.disabled ) {
					return;
				}

				clearTimeout( self.searching );
				&#x2F;&#x2F; clicks on the menu (or a button to trigger a search) will cause a blur event
				self.closing = setTimeout(function() {
					self.close( event );
					self._change( event );
				}, 150 );
			});
		this._initSource();
		this.menu = $( &quot;&lt;ul&gt;&lt;&#x2F;ul&gt;&quot; )
			.addClass( &quot;ui-autocomplete&quot; )
			.appendTo( $( this.options.appendTo || &quot;body&quot;, doc )[0] )
			&#x2F;&#x2F; prevent the close-on-blur in case of a &quot;slow&quot; click on the menu (long mousedown)
			.mousedown(function( event ) {
				&#x2F;&#x2F; clicking on the scrollbar causes focus to shift to the body
				&#x2F;&#x2F; but we can&#x27;t detect a mouseup or a click immediately afterward
				&#x2F;&#x2F; so we have to track the next mousedown and close the menu if
				&#x2F;&#x2F; the user clicks somewhere outside of the autocomplete
				var menuElement = self.menu.element[ 0 ];
				if ( !$( event.target ).closest( &quot;.ui-menu-item&quot; ).length ) {
					setTimeout(function() {
						$( document ).one( &#x27;mousedown&#x27;, function( event ) {
							if ( event.target !== self.element[ 0 ] &amp;&amp;
								event.target !== menuElement &amp;&amp;
								!$.ui.contains( menuElement, event.target ) ) {
								self.close();
							}
						});
					}, 1 );
				}

				&#x2F;&#x2F; use another timeout to make sure the blur-event-handler on the input was already triggered
				setTimeout(function() {
					clearTimeout( self.closing );
				}, 13);
			})
			.menu({
				focus: function( event, ui ) {
					var item = ui.item.data( &quot;item.autocomplete&quot; );
					if ( false !== self._trigger( &quot;focus&quot;, event, { item: item } ) ) {
						&#x2F;&#x2F; use value to match what will end up in the input, if it was a key event
						if ( &#x2F;^key&#x2F;.test(event.originalEvent.type) ) {
							self.element.val( item.value );
						}
					}
				},
				selected: function( event, ui ) {
					var item = ui.item.data( &quot;item.autocomplete&quot; ),
						previous = self.previous;

					&#x2F;&#x2F; only trigger when focus was lost (click on menu)
					if ( self.element[0] !== doc.activeElement ) {
						self.element.focus();
						self.previous = previous;
						&#x2F;&#x2F; #6109 - IE triggers two focus events and the second
						&#x2F;&#x2F; is asynchronous, so we need to reset the previous
						&#x2F;&#x2F; term synchronously and asynchronously :-(
						setTimeout(function() {
							self.previous = previous;
							self.selectedItem = item;
						}, 1);
					}

					if ( false !== self._trigger( &quot;select&quot;, event, { item: item } ) ) {
						self.element.val( item.value );
					}
					&#x2F;&#x2F; reset the term after the select event
					&#x2F;&#x2F; this allows custom select handling to work properly
					self.term = self.element.val();

					self.close( event );
					self.selectedItem = item;
				},
				blur: function( event, ui ) {
					&#x2F;&#x2F; don&#x27;t set the value of the text field if it&#x27;s already correct
					&#x2F;&#x2F; this prevents moving the cursor unnecessarily
					if ( self.menu.element.is(&quot;:visible&quot;) &amp;&amp;
						( self.element.val() !== self.term ) ) {
						self.element.val( self.term );
					}
				}
			})
			.zIndex( this.element.zIndex() + 1 )
			&#x2F;&#x2F; workaround for jQuery bug #5781 http:&#x2F;&#x2F;dev.jquery.com&#x2F;ticket&#x2F;5781
			.css({ top: 0, left: 0 })
			.hide()
			.data( &quot;menu&quot; );
		if ( $.fn.bgiframe ) {
			 this.menu.element.bgiframe();
		}
		&#x2F;&#x2F; turning off autocomplete prevents the browser from remembering the
		&#x2F;&#x2F; value when navigating through history, so we re-enable autocomplete
		&#x2F;&#x2F; if the page is unloaded before the widget is destroyed. #7790
		self.beforeunloadHandler = function() {
			self.element.removeAttr( &quot;autocomplete&quot; );
		};
		$( window ).bind( &quot;beforeunload&quot;, self.beforeunloadHandler );
	},

	destroy: function() {
		this.element
			.removeClass( &quot;ui-autocomplete-input&quot; )
			.removeAttr( &quot;autocomplete&quot; )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-autocomplete&quot; )
			.removeAttr( &quot;aria-haspopup&quot; );
		this.menu.element.remove();
		$( window ).unbind( &quot;beforeunload&quot;, this.beforeunloadHandler );
		$.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );
		if ( key === &quot;source&quot; ) {
			this._initSource();
		}
		if ( key === &quot;appendTo&quot; ) {
			this.menu.element.appendTo( $( value || &quot;body&quot;, this.element[0].ownerDocument )[0] )
		}
		if ( key === &quot;disabled&quot; &amp;&amp; value &amp;&amp; this.xhr ) {
			this.xhr.abort();
		}
	},

	_initSource: function() {
		var self = this,
			array,
			url;
		if ( $.isArray(this.options.source) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter(array, request.term) );
			};
		} else if ( typeof this.options.source === &quot;string&quot; ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( self.xhr ) {
					self.xhr.abort();
				}
				self.xhr = $.ajax({
					url: url,
					data: request,
					dataType: &quot;json&quot;,
					success: function( data, status ) {
						response( data );
					},
					error: function() {
						response( [] );
					}
				});
			};
		} else {
			this.source = this.options.source;
		}
	},

	search: function( value, event ) {
		value = value != null ? value : this.element.val();

		&#x2F;&#x2F; always save the actual value, not the one passed as an argument
		this.term = this.element.val();

		if ( value.length &lt; this.options.minLength ) {
			return this.close( event );
		}

		clearTimeout( this.closing );
		if ( this._trigger( &quot;search&quot;, event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this.element.addClass( &quot;ui-autocomplete-loading&quot; );

		this.source( { term: value }, this._response() );
	},

	_response: function() {
		var that = this,
			index = ++requestIndex;

		return function( content ) {
			if ( index === requestIndex ) {
				that.__response( content );
			}

			that.pending--;
			if ( !that.pending ) {
				that.element.removeClass( &quot;ui-autocomplete-loading&quot; );
			}
		};
	},

	__response: function( content ) {
		if ( !this.options.disabled &amp;&amp; content &amp;&amp; content.length ) {
			content = this._normalize( content );
			this._suggest( content );
			this._trigger( &quot;open&quot; );
		} else {
			this.close();
		}
	},

	close: function( event ) {
		clearTimeout( this.closing );
		if ( this.menu.element.is(&quot;:visible&quot;) ) {
			this.menu.element.hide();
			this.menu.deactivate();
			this._trigger( &quot;close&quot;, event );
		}
	},
	
	_change: function( event ) {
		if ( this.previous !== this.element.val() ) {
			this._trigger( &quot;change&quot;, event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		&#x2F;&#x2F; assume all items have the right format when the first item is complete
		if ( items.length &amp;&amp; items[0].label &amp;&amp; items[0].value ) {
			return items;
		}
		return $.map( items, function(item) {
			if ( typeof item === &quot;string&quot; ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend({
				label: item.label || item.value,
				value: item.value || item.label
			}, item );
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element
			.empty()
			.zIndex( this.element.zIndex() + 1 );
		this._renderMenu( ul, items );
		&#x2F;&#x2F; TODO refresh should check if the active item is still in the dom, removing the need for a manual deactivate
		this.menu.deactivate();
		this.menu.refresh();

		&#x2F;&#x2F; size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend({
			of: this.element
		}, this.options.position ));

		if ( this.options.autoFocus ) {
			this.menu.next( new $.Event(&quot;mouseover&quot;) );
		}
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(
			&#x2F;&#x2F; Firefox wraps long text (possibly a rounding bug)
			&#x2F;&#x2F; so we add 1px to avoid the wrapping (#7513)
			ul.width( &quot;&quot; ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var self = this;
		$.each( items, function( index, item ) {
			self._renderItem( ul, item );
		});
	},

	_renderItem: function( ul, item) {
		return $( &quot;&lt;li&gt;&lt;&#x2F;li&gt;&quot; )
			.data( &quot;item.autocomplete&quot;, item )
			.append( $( &quot;&lt;a&gt;&lt;&#x2F;a&gt;&quot; ).text( item.label ) )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is(&quot;:visible&quot;) ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.first() &amp;&amp; &#x2F;^previous&#x2F;.test(direction) ||
				this.menu.last() &amp;&amp; &#x2F;^next&#x2F;.test(direction) ) {
			this.element.val( this.term );
			this.menu.deactivate();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	},
	_keyEvent: function( keyEvent, event ) {
		if ( !this.isMultiLine || this.menu.element.is( &quot;:visible&quot; ) ) {
			this._move( keyEvent, event );

			&#x2F;&#x2F; prevents moving cursor to beginning&#x2F;end of the text field in some browsers
			event.preventDefault();
		}
	}
});

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace(&#x2F;[-[\]{}()*+?.,\\^$|#\s]&#x2F;g, &quot;\\$&amp;&quot;);
	},
	filter: function(array, term) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), &quot;i&quot; );
		return $.grep( array, function(value) {
			return matcher.test( value.label || value.value || value );
		});
	}
});

}( jQuery ));

&#x2F;*
 * jQuery UI Menu (not officially released)
 * 
 * This widget isn&#x27;t yet finished and the API is subject to change. We plan to finish
 * it for the next release. You&#x27;re welcome to give it a try anyway and give us feedback,
 * as long as you&#x27;re okay with migrating your code later on. We can help with that, too.
 *
 * Copyright 2010, AUTHORS.txt (http:&#x2F;&#x2F;jqueryui.com&#x2F;about)
 * Licensed under the MIT license.
 * http:&#x2F;&#x2F;jquery.org&#x2F;license
 *
 * http:&#x2F;&#x2F;docs.jquery.com&#x2F;UI&#x2F;Menu
 *
 * Depends:
 *	jquery.ui.core.js
 *  jquery.ui.widget.js
 *&#x2F;
(function($) {

$.widget(&quot;ui.menu&quot;, {
	_create: function() {
		var self = this;
		this.element
			.addClass(&quot;ui-menu ui-widget ui-widget-content ui-corner-all&quot;)
			.attr({
				role: &quot;listbox&quot;,
				&quot;aria-activedescendant&quot;: &quot;ui-active-menuitem&quot;
			})
			.click(function( event ) {
				if ( !$( event.target ).closest( &quot;.ui-menu-item a&quot; ).length ) {
					return;
				}
				&#x2F;&#x2F; temporary
				event.preventDefault();
				self.select( event );
			});
		this.refresh();
	},
	
	refresh: function() {
		var self = this;

		&#x2F;&#x2F; don&#x27;t refresh list items that are already adapted
		var items = this.element.children(&quot;li:not(.ui-menu-item):has(a)&quot;)
			.addClass(&quot;ui-menu-item&quot;)
			.attr(&quot;role&quot;, &quot;menuitem&quot;);
		
		items.children(&quot;a&quot;)
			.addClass(&quot;ui-corner-all&quot;)
			.attr(&quot;tabindex&quot;, -1)
			&#x2F;&#x2F; mouseenter doesn&#x27;t work with event delegation
			.mouseenter(function( event ) {
				self.activate( event, $(this).parent() );
			})
			.mouseleave(function() {
				self.deactivate();
			});
	},

	activate: function( event, item ) {
		this.deactivate();
		if (this.hasScroll()) {
			var offset = item.offset().top - this.element.offset().top,
				scroll = this.element.scrollTop(),
				elementHeight = this.element.height();
			if (offset &lt; 0) {
				this.element.scrollTop( scroll + offset);
			} else if (offset &gt;= elementHeight) {
				this.element.scrollTop( scroll + offset - elementHeight + item.height());
			}
		}
		this.active = item.eq(0)
			.children(&quot;a&quot;)
				.addClass(&quot;ui-state-hover&quot;)
				.attr(&quot;id&quot;, &quot;ui-active-menuitem&quot;)
			.end();
		this._trigger(&quot;focus&quot;, event, { item: item });
	},

	deactivate: function() {
		if (!this.active) { return; }

		this.active.children(&quot;a&quot;)
			.removeClass(&quot;ui-state-hover&quot;)
			.removeAttr(&quot;id&quot;);
		this._trigger(&quot;blur&quot;);
		this.active = null;
	},

	next: function(event) {
		this.move(&quot;next&quot;, &quot;.ui-menu-item:first&quot;, event);
	},

	previous: function(event) {
		this.move(&quot;prev&quot;, &quot;.ui-menu-item:last&quot;, event);
	},

	first: function() {
		return this.active &amp;&amp; !this.active.prevAll(&quot;.ui-menu-item&quot;).length;
	},

	last: function() {
		return this.active &amp;&amp; !this.active.nextAll(&quot;.ui-menu-item&quot;).length;
	},

	move: function(direction, edge, event) {
		if (!this.active) {
			this.activate(event, this.element.children(edge));
			return;
		}
		var next = this.active[direction + &quot;All&quot;](&quot;.ui-menu-item&quot;).eq(0);
		if (next.length) {
			this.activate(event, next);
		} else {
			this.activate(event, this.element.children(edge));
		}
	},

	&#x2F;&#x2F; TODO merge with previousPage
	nextPage: function(event) {
		if (this.hasScroll()) {
			&#x2F;&#x2F; TODO merge with no-scroll-else
			if (!this.active || this.last()) {
				this.activate(event, this.element.children(&quot;.ui-menu-item:first&quot;));
				return;
			}
			var base = this.active.offset().top,
				height = this.element.height(),
				result = this.element.children(&quot;.ui-menu-item&quot;).filter(function() {
					var close = $(this).offset().top - base - height + $(this).height();
					&#x2F;&#x2F; TODO improve approximation
					return close &lt; 10 &amp;&amp; close &gt; -10;
				});

			&#x2F;&#x2F; TODO try to catch this earlier when scrollTop indicates the last page anyway
			if (!result.length) {
				result = this.element.children(&quot;.ui-menu-item:last&quot;);
			}
			this.activate(event, result);
		} else {
			this.activate(event, this.element.children(&quot;.ui-menu-item&quot;)
				.filter(!this.active || this.last() ? &quot;:first&quot; : &quot;:last&quot;));
		}
	},

	&#x2F;&#x2F; TODO merge with nextPage
	previousPage: function(event) {
		if (this.hasScroll()) {
			&#x2F;&#x2F; TODO merge with no-scroll-else
			if (!this.active || this.first()) {
				this.activate(event, this.element.children(&quot;.ui-menu-item:last&quot;));
				return;
			}

			var base = this.active.offset().top,
				height = this.element.height(),
				result = this.element.children(&quot;.ui-menu-item&quot;).filter(function() {
					var close = $(this).offset().top - base + height - $(this).height();
					&#x2F;&#x2F; TODO improve approximation
					return close &lt; 10 &amp;&amp; close &gt; -10;
				});

			&#x2F;&#x2F; TODO try to catch this earlier when scrollTop indicates the last page anyway
			if (!result.length) {
				result = this.element.children(&quot;.ui-menu-item:first&quot;);
			}
			this.activate(event, result);
		} else {
			this.activate(event, this.element.children(&quot;.ui-menu-item&quot;)
				.filter(!this.active || this.first() ? &quot;:last&quot; : &quot;:first&quot;));
		}
	},

	hasScroll: function() {
		return this.element.height() &lt; this.element[ $.fn.prop ? &quot;prop&quot; : &quot;attr&quot; ](&quot;scrollHeight&quot;);
	},

	select: function( event ) {
		this._trigger(&quot;selected&quot;, event, { item: this.active });
	}
});

}(jQuery));

(function( $, undefined ) {

var lastActive, startXPos, startYPos, clickDragged,
	baseClasses = &quot;ui-button ui-widget ui-state-default ui-corner-all&quot;,
	stateClasses = &quot;ui-state-hover ui-state-active &quot;,
	typeClasses = &quot;ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only&quot;,
	formResetHandler = function() {
		var buttons = $( this ).find( &quot;:ui-button&quot; );
		setTimeout(function() {
			buttons.button( &quot;refresh&quot; );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			if ( form ) {
				radios = $( form ).find( &quot;[name=&#x27;&quot; + name + &quot;&#x27;]&quot; );
			} else {
				radios = $( &quot;[name=&#x27;&quot; + name + &quot;&#x27;]&quot;, radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( &quot;ui.button&quot;, {
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( &quot;form&quot; )
			.unbind( &quot;reset.button&quot; )
			.bind( &quot;reset.button&quot;, formResetHandler );

		if ( typeof this.options.disabled !== &quot;boolean&quot; ) {
			this.options.disabled = !!this.element.propAttr( &quot;disabled&quot; );
		} else {
			this.element.propAttr( &quot;disabled&quot;, this.options.disabled );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( &quot;title&quot; );

		var self = this,
			options = this.options,
			toggleButton = this.type === &quot;checkbox&quot; || this.type === &quot;radio&quot;,
			hoverClass = &quot;ui-state-hover&quot; + ( !toggleButton ? &quot; ui-state-active&quot; : &quot;&quot; ),
			focusClass = &quot;ui-state-focus&quot;;

		if ( options.label === null ) {
			options.label = this.buttonElement.html();
		}

		this.buttonElement
			.addClass( baseClasses )
			.attr( &quot;role&quot;, &quot;button&quot; )
			.bind( &quot;mouseenter.button&quot;, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( &quot;ui-state-hover&quot; );
				if ( this === lastActive ) {
					$( this ).addClass( &quot;ui-state-active&quot; );
				}
			})
			.bind( &quot;mouseleave.button&quot;, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( hoverClass );
			})
			.bind( &quot;click.button&quot;, function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		this.element
			.bind( &quot;focus.button&quot;, function() {
				&#x2F;&#x2F; no need to check disabled, focus won&#x27;t be triggered anyway
				self.buttonElement.addClass( focusClass );
			})
			.bind( &quot;blur.button&quot;, function() {
				self.buttonElement.removeClass( focusClass );
			});

		if ( toggleButton ) {
			this.element.bind( &quot;change.button&quot;, function() {
				if ( clickDragged ) {
					return;
				}
				self.refresh();
			});
			&#x2F;&#x2F; if mouse moves between mousedown and mouseup (drag) set clickDragged flag
			&#x2F;&#x2F; prevents issue where button state changes but checkbox&#x2F;radio checked state
			&#x2F;&#x2F; does not in Firefox (see ticket #6970)
			this.buttonElement
				.bind( &quot;mousedown.button&quot;, function( event ) {
					if ( options.disabled ) {
						return;
					}
					clickDragged = false;
					startXPos = event.pageX;
					startYPos = event.pageY;
				})
				.bind( &quot;mouseup.button&quot;, function( event ) {
					if ( options.disabled ) {
						return;
					}
					if ( startXPos !== event.pageX || startYPos !== event.pageY ) {
						clickDragged = true;
					}
			});
		}

		if ( this.type === &quot;checkbox&quot; ) {
			this.buttonElement.bind( &quot;click.button&quot;, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).toggleClass( &quot;ui-state-active&quot; );
				self.buttonElement.attr( &quot;aria-pressed&quot;, self.element[0].checked );
			});
		} else if ( this.type === &quot;radio&quot; ) {
			this.buttonElement.bind( &quot;click.button&quot;, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).addClass( &quot;ui-state-active&quot; );
				self.buttonElement.attr( &quot;aria-pressed&quot;, &quot;true&quot; );

				var radio = self.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( &quot;widget&quot; )[ 0 ];
					})
					.removeClass( &quot;ui-state-active&quot; )
					.attr( &quot;aria-pressed&quot;, &quot;false&quot; );
			});
		} else {
			this.buttonElement
				.bind( &quot;mousedown.button&quot;, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( &quot;ui-state-active&quot; );
					lastActive = this;
					$( document ).one( &quot;mouseup&quot;, function() {
						lastActive = null;
					});
				})
				.bind( &quot;mouseup.button&quot;, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( &quot;ui-state-active&quot; );
				})
				.bind( &quot;keydown.button&quot;, function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode == $.ui.keyCode.SPACE || event.keyCode == $.ui.keyCode.ENTER ) {
						$( this ).addClass( &quot;ui-state-active&quot; );
					}
				})
				.bind( &quot;keyup.button&quot;, function() {
					$( this ).removeClass( &quot;ui-state-active&quot; );
				});

			if ( this.buttonElement.is(&quot;a&quot;) ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						&#x2F;&#x2F; TODO pass through original event correctly (just as 2nd argument doesn&#x27;t work)
						$( this ).click();
					}
				});
			}
		}

		&#x2F;&#x2F; TODO: pull out $.Widget&#x27;s handling for the disabled option into
		&#x2F;&#x2F; $.Widget.prototype._setOptionDisabled so it&#x27;s easy to proxy and can
		&#x2F;&#x2F; be overridden by individual plugins
		this._setOption( &quot;disabled&quot;, options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {

		if ( this.element.is(&quot;:checkbox&quot;) ) {
			this.type = &quot;checkbox&quot;;
		} else if ( this.element.is(&quot;:radio&quot;) ) {
			this.type = &quot;radio&quot;;
		} else if ( this.element.is(&quot;input&quot;) ) {
			this.type = &quot;input&quot;;
		} else {
			this.type = &quot;button&quot;;
		}

		if ( this.type === &quot;checkbox&quot; || this.type === &quot;radio&quot; ) {
			&#x2F;&#x2F; we don&#x27;t search against the document in case the element
			&#x2F;&#x2F; is disconnected from the DOM
			var ancestor = this.element.parents().filter(&quot;:last&quot;),
				labelSelector = &quot;label[for=&#x27;&quot; + this.element.attr(&quot;id&quot;) + &quot;&#x27;]&quot;;
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( &quot;ui-helper-hidden-accessible&quot; );

			var checked = this.element.is( &quot;:checked&quot; );
			if ( checked ) {
				this.buttonElement.addClass( &quot;ui-state-active&quot; );
			}
			this.buttonElement.attr( &quot;aria-pressed&quot;, checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	destroy: function() {
		this.element
			.removeClass( &quot;ui-helper-hidden-accessible&quot; );
		this.buttonElement
			.removeClass( baseClasses + &quot; &quot; + stateClasses + &quot; &quot; + typeClasses )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-pressed&quot; )
			.html( this.buttonElement.find(&quot;.ui-button-text&quot;).html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( &quot;title&quot; );
		}

		$.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );
		if ( key === &quot;disabled&quot; ) {
			if ( value ) {
				this.element.propAttr( &quot;disabled&quot;, true );
			} else {
				this.element.propAttr( &quot;disabled&quot;, false );
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		var isDisabled = this.element.is( &quot;:disabled&quot; );
		if ( isDisabled !== this.options.disabled ) {
			this._setOption( &quot;disabled&quot;, isDisabled );
		}
		if ( this.type === &quot;radio&quot; ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( &quot;:checked&quot; ) ) {
					$( this ).button( &quot;widget&quot; )
						.addClass( &quot;ui-state-active&quot; )
						.attr( &quot;aria-pressed&quot;, &quot;true&quot; );
				} else {
					$( this ).button( &quot;widget&quot; )
						.removeClass( &quot;ui-state-active&quot; )
						.attr( &quot;aria-pressed&quot;, &quot;false&quot; );
				}
			});
		} else if ( this.type === &quot;checkbox&quot; ) {
			if ( this.element.is( &quot;:checked&quot; ) ) {
				this.buttonElement
					.addClass( &quot;ui-state-active&quot; )
					.attr( &quot;aria-pressed&quot;, &quot;true&quot; );
			} else {
				this.buttonElement
					.removeClass( &quot;ui-state-active&quot; )
					.attr( &quot;aria-pressed&quot;, &quot;false&quot; );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === &quot;input&quot; ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( &quot;&lt;span&gt;&lt;&#x2F;span&gt;&quot;, this.element[0].ownerDocument )
				.addClass( &quot;ui-button-text&quot; )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary &amp;&amp; icons.secondary,
			buttonClasses = [];  

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( &quot;ui-button-text-icon&quot; + ( multipleIcons ? &quot;s&quot; : ( icons.primary ? &quot;-primary&quot; : &quot;-secondary&quot; ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( &quot;&lt;span class=&#x27;ui-button-icon-primary ui-icon &quot; + icons.primary + &quot;&#x27;&gt;&lt;&#x2F;span&gt;&quot; );
			}

			if ( icons.secondary ) {
				buttonElement.append( &quot;&lt;span class=&#x27;ui-button-icon-secondary ui-icon &quot; + icons.secondary + &quot;&#x27;&gt;&lt;&#x2F;span&gt;&quot; );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? &quot;ui-button-icons-only&quot; : &quot;ui-button-icon-only&quot; );

				if ( !this.hasTitle ) {
					buttonElement.attr( &quot;title&quot;, buttonText );
				}
			}
		} else {
			buttonClasses.push( &quot;ui-button-text-only&quot; );
		}
		buttonElement.addClass( buttonClasses.join( &quot; &quot; ) );
	}
});

$.widget( &quot;ui.buttonset&quot;, {
	options: {
		items: &quot;:button, :submit, :reset, :checkbox, :radio, a, :data(button)&quot;
	},

	_create: function() {
		this.element.addClass( &quot;ui-buttonset&quot; );
	},
	
	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === &quot;disabled&quot; ) {
			this.buttons.button( &quot;option&quot;, key, value );
		}

		$.Widget.prototype._setOption.apply( this, arguments );
	},
	
	refresh: function() {
		var rtl = this.element.css( &quot;direction&quot; ) === &quot;rtl&quot;;
		
		this.buttons = this.element.find( this.options.items )
			.filter( &quot;:ui-button&quot; )
				.button( &quot;refresh&quot; )
			.end()
			.not( &quot;:ui-button&quot; )
				.button()
			.end()
			.map(function() {
				return $( this ).button( &quot;widget&quot; )[ 0 ];
			})
				.removeClass( &quot;ui-corner-all ui-corner-left ui-corner-right&quot; )
				.filter( &quot;:first&quot; )
					.addClass( rtl ? &quot;ui-corner-right&quot; : &quot;ui-corner-left&quot; )
				.end()
				.filter( &quot;:last&quot; )
					.addClass( rtl ? &quot;ui-corner-left&quot; : &quot;ui-corner-right&quot; )
				.end()
			.end();
	},

	destroy: function() {
		this.element.removeClass( &quot;ui-buttonset&quot; );
		this.buttons
			.map(function() {
				return $( this ).button( &quot;widget&quot; )[ 0 ];
			})
				.removeClass( &quot;ui-corner-left ui-corner-right&quot; )
			.end()
			.button( &quot;destroy&quot; );

		$.Widget.prototype.destroy.call( this );
	}
});

}( jQuery ) );

(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: &quot;1.8.23&quot; } });

var PROP_NAME = &#x27;datepicker&#x27;;
var dpuuid = new Date().getTime();
var instActive;

&#x2F;* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. *&#x2F;

function Datepicker() {
	this.debug = false; &#x2F;&#x2F; Change this to true to start debugging
	this._curInst = null; &#x2F;&#x2F; The current instance in use
	this._keyEvent = false; &#x2F;&#x2F; If the last event was a key event
	this._disabledInputs = []; &#x2F;&#x2F; List of date picker inputs that have been disabled
	this._datepickerShowing = false; &#x2F;&#x2F; True if the popup picker is showing , false if not
	this._inDialog = false; &#x2F;&#x2F; True if showing within a &quot;dialog&quot;, false if not
	this._mainDivId = &#x27;ui-datepicker-div&#x27;; &#x2F;&#x2F; The ID of the main datepicker division
	this._inlineClass = &#x27;ui-datepicker-inline&#x27;; &#x2F;&#x2F; The name of the inline marker class
	this._appendClass = &#x27;ui-datepicker-append&#x27;; &#x2F;&#x2F; The name of the append marker class
	this._triggerClass = &#x27;ui-datepicker-trigger&#x27;; &#x2F;&#x2F; The name of the trigger marker class
	this._dialogClass = &#x27;ui-datepicker-dialog&#x27;; &#x2F;&#x2F; The name of the dialog marker class
	this._disableClass = &#x27;ui-datepicker-disabled&#x27;; &#x2F;&#x2F; The name of the disabled covering marker class
	this._unselectableClass = &#x27;ui-datepicker-unselectable&#x27;; &#x2F;&#x2F; The name of the unselectable cell marker class
	this._currentClass = &#x27;ui-datepicker-current-day&#x27;; &#x2F;&#x2F; The name of the current day marker class
	this._dayOverClass = &#x27;ui-datepicker-days-cell-over&#x27;; &#x2F;&#x2F; The name of the day hover marker class
	this.regional = []; &#x2F;&#x2F; Available regional settings, indexed by language code
	this.regional[&#x27;&#x27;] = { &#x2F;&#x2F; Default regional settings
		closeText: &#x27;Done&#x27;, &#x2F;&#x2F; Display text for close link
		prevText: &#x27;Prev&#x27;, &#x2F;&#x2F; Display text for previous month link
		nextText: &#x27;Next&#x27;, &#x2F;&#x2F; Display text for next month link
		currentText: &#x27;Today&#x27;, &#x2F;&#x2F; Display text for current month link
		monthNames: [&#x27;January&#x27;,&#x27;February&#x27;,&#x27;March&#x27;,&#x27;April&#x27;,&#x27;May&#x27;,&#x27;June&#x27;,
			&#x27;July&#x27;,&#x27;August&#x27;,&#x27;September&#x27;,&#x27;October&#x27;,&#x27;November&#x27;,&#x27;December&#x27;], &#x2F;&#x2F; Names of months for drop-down and formatting
		monthNamesShort: [&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;Mar&#x27;, &#x27;Apr&#x27;, &#x27;May&#x27;, &#x27;Jun&#x27;, &#x27;Jul&#x27;, &#x27;Aug&#x27;, &#x27;Sep&#x27;, &#x27;Oct&#x27;, &#x27;Nov&#x27;, &#x27;Dec&#x27;], &#x2F;&#x2F; For formatting
		dayNames: [&#x27;Sunday&#x27;, &#x27;Monday&#x27;, &#x27;Tuesday&#x27;, &#x27;Wednesday&#x27;, &#x27;Thursday&#x27;, &#x27;Friday&#x27;, &#x27;Saturday&#x27;], &#x2F;&#x2F; For formatting
		dayNamesShort: [&#x27;Sun&#x27;, &#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;], &#x2F;&#x2F; For formatting
		dayNamesMin: [&#x27;Su&#x27;,&#x27;Mo&#x27;,&#x27;Tu&#x27;,&#x27;We&#x27;,&#x27;Th&#x27;,&#x27;Fr&#x27;,&#x27;Sa&#x27;], &#x2F;&#x2F; Column headings for days starting at Sunday
		weekHeader: &#x27;Wk&#x27;, &#x2F;&#x2F; Column header for week of the year
		dateFormat: &#x27;mm&#x2F;dd&#x2F;yy&#x27;, &#x2F;&#x2F; See format options on parseDate
		firstDay: 0, &#x2F;&#x2F; The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, &#x2F;&#x2F; True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, &#x2F;&#x2F; True if the year select precedes month, false for month then year
		yearSuffix: &#x27;&#x27; &#x2F;&#x2F; Additional text to append to the year in the month headers
	};
	this._defaults = { &#x2F;&#x2F; Global defaults for all the date picker instances
		showOn: &#x27;focus&#x27;, &#x2F;&#x2F; &#x27;focus&#x27; for popup on focus,
			&#x2F;&#x2F; &#x27;button&#x27; for trigger button, or &#x27;both&#x27; for either
		showAnim: &#x27;fadeIn&#x27;, &#x2F;&#x2F; Name of jQuery animation for popup
		showOptions: {}, &#x2F;&#x2F; Options for enhanced animations
		defaultDate: null, &#x2F;&#x2F; Used when field is blank: actual date,
			&#x2F;&#x2F; +&#x2F;-number for offset from today, null for today
		appendText: &#x27;&#x27;, &#x2F;&#x2F; Display text following the input box, e.g. showing the format
		buttonText: &#x27;...&#x27;, &#x2F;&#x2F; Text for trigger button
		buttonImage: &#x27;&#x27;, &#x2F;&#x2F; URL for trigger button image
		buttonImageOnly: false, &#x2F;&#x2F; True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, &#x2F;&#x2F; True to hide next&#x2F;previous month links
			&#x2F;&#x2F; if not applicable, false to just disable them
		navigationAsDateFormat: false, &#x2F;&#x2F; True if date formatting applied to prev&#x2F;today&#x2F;next links
		gotoCurrent: false, &#x2F;&#x2F; True if today link goes back to current selection instead
		changeMonth: false, &#x2F;&#x2F; True if month can be selected directly, false if only prev&#x2F;next
		changeYear: false, &#x2F;&#x2F; True if year can be selected directly, false if only prev&#x2F;next
		yearRange: &#x27;c-10:c+10&#x27;, &#x2F;&#x2F; Range of years to display in drop-down,
			&#x2F;&#x2F; either relative to today&#x27;s year (-nn:+nn), relative to currently displayed year
			&#x2F;&#x2F; (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, &#x2F;&#x2F; True to show dates in other months, false to leave blank
		selectOtherMonths: false, &#x2F;&#x2F; True to allow selection of dates in other months, false for unselectable
		showWeek: false, &#x2F;&#x2F; True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, &#x2F;&#x2F; How to calculate the week of the year,
			&#x2F;&#x2F; takes a Date and returns the number of the week for it
		shortYearCutoff: &#x27;+10&#x27;, &#x2F;&#x2F; Short year values &lt; this are in the current century,
			&#x2F;&#x2F; &gt; this are in the previous century,
			&#x2F;&#x2F; string value starting with &#x27;+&#x27; for current year + value
		minDate: null, &#x2F;&#x2F; The earliest selectable date, or null for no limit
		maxDate: null, &#x2F;&#x2F; The latest selectable date, or null for no limit
		duration: &#x27;fast&#x27;, &#x2F;&#x2F; Duration of display&#x2F;closure
		beforeShowDay: null, &#x2F;&#x2F; Function that takes a date and returns an array with
			&#x2F;&#x2F; [0] = true if selectable, false if not, [1] = custom CSS class name(s) or &#x27;&#x27;,
			&#x2F;&#x2F; [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, &#x2F;&#x2F; Function that takes an input field and
			&#x2F;&#x2F; returns a set of custom settings for the date picker
		onSelect: null, &#x2F;&#x2F; Define a callback function when a date is selected
		onChangeMonthYear: null, &#x2F;&#x2F; Define a callback function when the month or year is changed
		onClose: null, &#x2F;&#x2F; Define a callback function when the datepicker is closed
		numberOfMonths: 1, &#x2F;&#x2F; Number of months to show at a time
		showCurrentAtPos: 0, &#x2F;&#x2F; The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, &#x2F;&#x2F; Number of months to step back&#x2F;forward
		stepBigMonths: 12, &#x2F;&#x2F; Number of months to step back&#x2F;forward for the big links
		altField: &#x27;&#x27;, &#x2F;&#x2F; Selector for an alternate field to store selected dates into
		altFormat: &#x27;&#x27;, &#x2F;&#x2F; The date format to use for the alternate field
		constrainInput: true, &#x2F;&#x2F; The input is constrained by the current date format
		showButtonPanel: false, &#x2F;&#x2F; True to show button panel, false to not show it
		autoSize: false, &#x2F;&#x2F; True to size the input for the date format, false to leave as is
		disabled: false &#x2F;&#x2F; The initial disabled state
	};
	$.extend(this._defaults, this.regional[&#x27;&#x27;]);
	this.dpDiv = bindHover($(&#x27;&lt;div id=&quot;&#x27; + this._mainDivId + &#x27;&quot; class=&quot;ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all&quot;&gt;&lt;&#x2F;div&gt;&#x27;));
}

$.extend(Datepicker.prototype, {
	&#x2F;* Class name added to elements to indicate already configured with a date picker. *&#x2F;
	markerClassName: &#x27;hasDatepicker&#x27;,
	
	&#x2F;&#x2F;Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	&#x2F;* Debug logging (if enabled). *&#x2F;
	log: function () {
		if (this.debug)
			console.log.apply(&#x27;&#x27;, arguments);
	},
	
	&#x2F;&#x2F; TODO rename to &quot;widget&quot; when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	&#x2F;* Override the default settings for all instances of the date picker.
	   @param  settings  object - the new settings to use as defaults (anonymous object)
	   @return the manager object *&#x2F;
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	&#x2F;* Attach the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span
	   @param  settings  object - the new settings to use for this date picker instance (anonymous) *&#x2F;
	_attachDatepicker: function(target, settings) {
		&#x2F;&#x2F; check for settings on the control itself - in namespace &#x27;date:&#x27;
		var inlineSettings = null;
		for (var attrName in this._defaults) {
			var attrValue = target.getAttribute(&#x27;date:&#x27; + attrName);
			if (attrValue) {
				inlineSettings = inlineSettings || {};
				try {
					inlineSettings[attrName] = eval(attrValue);
				} catch (err) {
					inlineSettings[attrName] = attrValue;
				}
			}
		}
		var nodeName = target.nodeName.toLowerCase();
		var inline = (nodeName == &#x27;div&#x27; || nodeName == &#x27;span&#x27;);
		if (!target.id) {
			this.uuid += 1;
			target.id = &#x27;dp&#x27; + this.uuid;
		}
		var inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {}, inlineSettings || {});
		if (nodeName == &#x27;input&#x27;) {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	&#x2F;* Create a new instance object. *&#x2F;
	_newInst: function(target, inline) {
		var id = target[0].id.replace(&#x2F;([^A-Za-z0-9_-])&#x2F;g, &#x27;\\\\$1&#x27;); &#x2F;&#x2F; escape jQuery meta chars
		return {id: id, input: target, &#x2F;&#x2F; associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, &#x2F;&#x2F; current selection
			drawMonth: 0, drawYear: 0, &#x2F;&#x2F; month being drawn
			inline: inline, &#x2F;&#x2F; is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : &#x2F;&#x2F; presentation div
			bindHover($(&#x27;&lt;div class=&quot;&#x27; + this._inlineClass + &#x27; ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all&quot;&gt;&lt;&#x2F;div&gt;&#x27;)))};
	},

	&#x2F;* Attach the date picker to an input field. *&#x2F;
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName))
			return;
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp).
			bind(&quot;setData.datepicker&quot;, function(event, key, value) {
				inst.settings[key] = value;
			}).bind(&quot;getData.datepicker&quot;, function(event, key) {
				return this._get(inst, key);
			});
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		&#x2F;&#x2F;If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	&#x2F;* Make attachments based on settings. *&#x2F;
	_attachments: function(input, inst) {
		var appendText = this._get(inst, &#x27;appendText&#x27;);
		var isRTL = this._get(inst, &#x27;isRTL&#x27;);
		if (inst.append)
			inst.append.remove();
		if (appendText) {
			inst.append = $(&#x27;&lt;span class=&quot;&#x27; + this._appendClass + &#x27;&quot;&gt;&#x27; + appendText + &#x27;&lt;&#x2F;span&gt;&#x27;);
			input[isRTL ? &#x27;before&#x27; : &#x27;after&#x27;](inst.append);
		}
		input.unbind(&#x27;focus&#x27;, this._showDatepicker);
		if (inst.trigger)
			inst.trigger.remove();
		var showOn = this._get(inst, &#x27;showOn&#x27;);
		if (showOn == &#x27;focus&#x27; || showOn == &#x27;both&#x27;) &#x2F;&#x2F; pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		if (showOn == &#x27;button&#x27; || showOn == &#x27;both&#x27;) { &#x2F;&#x2F; pop-up date picker when button clicked
			var buttonText = this._get(inst, &#x27;buttonText&#x27;);
			var buttonImage = this._get(inst, &#x27;buttonImage&#x27;);
			inst.trigger = $(this._get(inst, &#x27;buttonImageOnly&#x27;) ?
				$(&#x27;&lt;img&#x2F;&gt;&#x27;).addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$(&#x27;&lt;button type=&quot;button&quot;&gt;&lt;&#x2F;button&gt;&#x27;).addClass(this._triggerClass).
					html(buttonImage == &#x27;&#x27; ? buttonText : $(&#x27;&lt;img&#x2F;&gt;&#x27;).attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? &#x27;before&#x27; : &#x27;after&#x27;](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing &amp;&amp; $.datepicker._lastInput == input[0])
					$.datepicker._hideDatepicker();
				else if ($.datepicker._datepickerShowing &amp;&amp; $.datepicker._lastInput != input[0]) {
					$.datepicker._hideDatepicker(); 
					$.datepicker._showDatepicker(input[0]);
				} else
					$.datepicker._showDatepicker(input[0]);
				return false;
			});
		}
	},

	&#x2F;* Apply the maximum length for the date format. *&#x2F;
	_autoSize: function(inst) {
		if (this._get(inst, &#x27;autoSize&#x27;) &amp;&amp; !inst.inline) {
			var date = new Date(2009, 12 - 1, 20); &#x2F;&#x2F; Ensure double digits
			var dateFormat = this._get(inst, &#x27;dateFormat&#x27;);
			if (dateFormat.match(&#x2F;[DM]&#x2F;)) {
				var findMax = function(names) {
					var max = 0;
					var maxI = 0;
					for (var i = 0; i &lt; names.length; i++) {
						if (names[i].length &gt; max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(&#x2F;MM&#x2F;) ?
					&#x27;monthNames&#x27; : &#x27;monthNamesShort&#x27;))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(&#x2F;DD&#x2F;) ?
					&#x27;dayNames&#x27; : &#x27;dayNamesShort&#x27;))) + 20 - date.getDay());
			}
			inst.input.attr(&#x27;size&#x27;, this._formatDate(inst, date).length);
		}
	},

	&#x2F;* Attach an inline date picker to a div. *&#x2F;
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName))
			return;
		divSpan.addClass(this.markerClassName).append(inst.dpDiv).
			bind(&quot;setData.datepicker&quot;, function(event, key, value){
				inst.settings[key] = value;
			}).bind(&quot;getData.datepicker&quot;, function(event, key){
				return this._get(inst, key);
			});
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		&#x2F;&#x2F;If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		&#x2F;&#x2F; Set display:block in place of inst.dpDiv.show() which won&#x27;t work on disconnected elements
		&#x2F;&#x2F; http:&#x2F;&#x2F;bugs.jqueryui.com&#x2F;ticket&#x2F;7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( &quot;display&quot;, &quot;block&quot; );
	},

	&#x2F;* Pop-up the date picker in a &quot;dialog&quot; box.
	   @param  input     element - ignored
	   @param  date      string or Date - the initial date to display
	   @param  onSelect  function - the function to call when a date is selected
	   @param  settings  object - update the dialog date picker instance&#x27;s settings (anonymous object)
	   @param  pos       int[2] - coordinates for the dialog&#x27;s position within the screen or
	                     event - with x&#x2F;y coordinates or
	                     leave empty for default (screen centre)
	   @return the manager object *&#x2F;
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var inst = this._dialogInst; &#x2F;&#x2F; internal instance
		if (!inst) {
			this.uuid += 1;
			var id = &#x27;dp&#x27; + this.uuid;
			this._dialogInput = $(&#x27;&lt;input type=&quot;text&quot; id=&quot;&#x27; + id +
				&#x27;&quot; style=&quot;position: absolute; top: -100px; width: 0px;&quot;&#x2F;&gt;&#x27;);
			this._dialogInput.keydown(this._doKeyDown);
			$(&#x27;body&#x27;).append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date &amp;&amp; date.constructor == Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			var browserWidth = document.documentElement.clientWidth;
			var browserHeight = document.documentElement.clientHeight;
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = &#x2F;&#x2F; should use actual width&#x2F;height below
				[(browserWidth &#x2F; 2) - 100 + scrollX, (browserHeight &#x2F; 2) - 150 + scrollY];
		}

		&#x2F;&#x2F; move input on screen for focus, but hidden behind dialog
		this._dialogInput.css(&#x27;left&#x27;, (this._pos[0] + 20) + &#x27;px&#x27;).css(&#x27;top&#x27;, this._pos[1] + &#x27;px&#x27;);
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI)
			$.blockUI(this.dpDiv);
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	&#x2F;* Detach a datepicker from its control.
	   @param  target    element - the target input field or division or span *&#x2F;
	_destroyDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName == &#x27;input&#x27;) {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind(&#x27;focus&#x27;, this._showDatepicker).
				unbind(&#x27;keydown&#x27;, this._doKeyDown).
				unbind(&#x27;keypress&#x27;, this._doKeyPress).
				unbind(&#x27;keyup&#x27;, this._doKeyUp);
		} else if (nodeName == &#x27;div&#x27; || nodeName == &#x27;span&#x27;)
			$target.removeClass(this.markerClassName).empty();
	},

	&#x2F;* Enable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span *&#x2F;
	_enableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == &#x27;input&#x27;) {
			target.disabled = false;
			inst.trigger.filter(&#x27;button&#x27;).
				each(function() { this.disabled = false; }).end().
				filter(&#x27;img&#x27;).css({opacity: &#x27;1.0&#x27;, cursor: &#x27;&#x27;});
		}
		else if (nodeName == &#x27;div&#x27; || nodeName == &#x27;span&#x27;) {
			var inline = $target.children(&#x27;.&#x27; + this._inlineClass);
			inline.children().removeClass(&#x27;ui-state-disabled&#x27;);
			inline.find(&quot;select.ui-datepicker-month, select.ui-datepicker-year&quot;).
				removeAttr(&quot;disabled&quot;);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); &#x2F;&#x2F; delete entry
	},

	&#x2F;* Disable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span *&#x2F;
	_disableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == &#x27;input&#x27;) {
			target.disabled = true;
			inst.trigger.filter(&#x27;button&#x27;).
				each(function() { this.disabled = true; }).end().
				filter(&#x27;img&#x27;).css({opacity: &#x27;0.5&#x27;, cursor: &#x27;default&#x27;});
		}
		else if (nodeName == &#x27;div&#x27; || nodeName == &#x27;span&#x27;) {
			var inline = $target.children(&#x27;.&#x27; + this._inlineClass);
			inline.children().addClass(&#x27;ui-state-disabled&#x27;);
			inline.find(&quot;select.ui-datepicker-month, select.ui-datepicker-year&quot;).
				attr(&quot;disabled&quot;, &quot;disabled&quot;);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); &#x2F;&#x2F; delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	&#x2F;* Is the first field in a jQuery collection disabled as a datepicker?
	   @param  target    element - the target input field or division or span
	   @return boolean - true if disabled, false if enabled *&#x2F;
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i &lt; this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] == target)
				return true;
		}
		return false;
	},

	&#x2F;* Retrieve the instance data for the target control.
	   @param  target  element - the target input field or division or span
	   @return  object - the associated instance data
	   @throws  error if a jQuery problem getting data *&#x2F;
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw &#x27;Missing instance data for this datepicker&#x27;;
		}
	},

	&#x2F;* Update or retrieve the settings for a date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span
	   @param  name    object - the new settings to update or
	                   string - the name of the setting to change or retrieve,
	                   when retrieving also &#x27;all&#x27; for all instance settings or
	                   &#x27;defaults&#x27; for all global defaults
	   @param  value   any - the new value for the setting
	                   (omit if above is an object or to retrieve a value) *&#x2F;
	_optionDatepicker: function(target, name, value) {
		var inst = this._getInst(target);
		if (arguments.length == 2 &amp;&amp; typeof name == &#x27;string&#x27;) {
			return (name == &#x27;defaults&#x27; ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name == &#x27;all&#x27; ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}
		var settings = name || {};
		if (typeof name == &#x27;string&#x27;) {
			settings = {};
			settings[name] = value;
		}
		if (inst) {
			if (this._curInst == inst) {
				this._hideDatepicker();
			}
			var date = this._getDateDatepicker(target, true);
			var minDate = this._getMinMaxDate(inst, &#x27;min&#x27;);
			var maxDate = this._getMinMaxDate(inst, &#x27;max&#x27;);
			extendRemove(inst.settings, settings);
			&#x2F;&#x2F; reformat the old minDate&#x2F;maxDate values if dateFormat changes and a new minDate&#x2F;maxDate isn&#x27;t provided
			if (minDate !== null &amp;&amp; settings[&#x27;dateFormat&#x27;] !== undefined &amp;&amp; settings[&#x27;minDate&#x27;] === undefined)
				inst.settings.minDate = this._formatDate(inst, minDate);
			if (maxDate !== null &amp;&amp; settings[&#x27;dateFormat&#x27;] !== undefined &amp;&amp; settings[&#x27;maxDate&#x27;] === undefined)
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	&#x2F;&#x2F; change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	&#x2F;* Redraw the date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span *&#x2F;
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	&#x2F;* Set the dates for a jQuery selection.
	   @param  target   element - the target input field or division or span
	   @param  date     Date - the new date *&#x2F;
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	&#x2F;* Get the date(s) for the first entry in a jQuery selection.
	   @param  target     element - the target input field or division or span
	   @param  noDefault  boolean - true if no default date is to be used
	   @return Date - the current date *&#x2F;
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst &amp;&amp; !inst.inline)
			this._setDateFromField(inst, noDefault);
		return (inst ? this._getDate(inst) : null);
	},

	&#x2F;* Handle keystrokes. *&#x2F;
	_doKeyDown: function(event) {
		var inst = $.datepicker._getInst(event.target);
		var handled = true;
		var isRTL = inst.dpDiv.is(&#x27;.ui-datepicker-rtl&#x27;);
		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing)
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; &#x2F;&#x2F; hide on tab out
				case 13: var sel = $(&#x27;td.&#x27; + $.datepicker._dayOverClass + &#x27;:not(.&#x27; + 
									$.datepicker._currentClass + &#x27;)&#x27;, inst.dpDiv);
						if (sel[0])
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
							var onSelect = $.datepicker._get(inst, &#x27;onSelect&#x27;);
							if (onSelect) {
								var dateStr = $.datepicker._formatDate(inst);

								&#x2F;&#x2F; trigger custom callback
								onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
							}
						else
							$.datepicker._hideDatepicker();
						return false; &#x2F;&#x2F; don&#x27;t submit the form
						break; &#x2F;&#x2F; select the value on enter
				case 27: $.datepicker._hideDatepicker();
						break; &#x2F;&#x2F; hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, &#x27;stepBigMonths&#x27;) :
							-$.datepicker._get(inst, &#x27;stepMonths&#x27;)), &#x27;M&#x27;);
						break; &#x2F;&#x2F; previous month&#x2F;year on page up&#x2F;+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, &#x27;stepBigMonths&#x27;) :
							+$.datepicker._get(inst, &#x27;stepMonths&#x27;)), &#x27;M&#x27;);
						break; &#x2F;&#x2F; next month&#x2F;year on page down&#x2F;+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) $.datepicker._clearDate(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; &#x2F;&#x2F; clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) $.datepicker._gotoToday(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; &#x2F;&#x2F; current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), &#x27;D&#x27;);
						handled = event.ctrlKey || event.metaKey;
						&#x2F;&#x2F; -1 day on ctrl or command +left
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									-$.datepicker._get(inst, &#x27;stepBigMonths&#x27;) :
									-$.datepicker._get(inst, &#x27;stepMonths&#x27;)), &#x27;M&#x27;);
						&#x2F;&#x2F; next month&#x2F;year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, -7, &#x27;D&#x27;);
						handled = event.ctrlKey || event.metaKey;
						break; &#x2F;&#x2F; -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), &#x27;D&#x27;);
						handled = event.ctrlKey || event.metaKey;
						&#x2F;&#x2F; +1 day on ctrl or command +right
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									+$.datepicker._get(inst, &#x27;stepBigMonths&#x27;) :
									+$.datepicker._get(inst, &#x27;stepMonths&#x27;)), &#x27;M&#x27;);
						&#x2F;&#x2F; next month&#x2F;year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, +7, &#x27;D&#x27;);
						handled = event.ctrlKey || event.metaKey;
						break; &#x2F;&#x2F; +1 week on ctrl or command +down
				default: handled = false;
			}
		else if (event.keyCode == 36 &amp;&amp; event.ctrlKey) &#x2F;&#x2F; display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		else {
			handled = false;
		}
		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	&#x2F;* Filter entered characters - based on date format. *&#x2F;
	_doKeyPress: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if ($.datepicker._get(inst, &#x27;constrainInput&#x27;)) {
			var chars = $.datepicker._possibleChars($.datepicker._get(inst, &#x27;dateFormat&#x27;));
			var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr &lt; &#x27; &#x27; || !chars || chars.indexOf(chr) &gt; -1);
		}
	},

	&#x2F;* Synchronise manual entry and field&#x2F;alternate field. *&#x2F;
	_doKeyUp: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if (inst.input.val() != inst.lastVal) {
			try {
				var date = $.datepicker.parseDate($.datepicker._get(inst, &#x27;dateFormat&#x27;),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));
				if (date) { &#x2F;&#x2F; only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
				$.datepicker.log(err);
			}
		}
		return true;
	},

	&#x2F;* Pop-up the date picker for a given input field.
       If false returned from beforeShow event handler do not show. 
	   @param  input  element - the input field attached to the date picker or
	                  event - if triggered by focus *&#x2F;
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() != &#x27;input&#x27;) &#x2F;&#x2F; find from button&#x2F;image trigger
			input = $(&#x27;input&#x27;, input.parentNode)[0];
		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput == input) &#x2F;&#x2F; already here
			return;
		var inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst &amp;&amp; $.datepicker._curInst != inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst &amp;&amp; $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}
		var beforeShow = $.datepicker._get(inst, &#x27;beforeShow&#x27;);
		var beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
            &#x2F;&#x2F;false
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);
		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);
		if ($.datepicker._inDialog) &#x2F;&#x2F; hide cursor
			input.value = &#x27;&#x27;;
		if (!$.datepicker._pos) { &#x2F;&#x2F; position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; &#x2F;&#x2F; add the height
		}
		var isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css(&#x27;position&#x27;) == &#x27;fixed&#x27;;
			return !isFixed;
		});
		if (isFixed &amp;&amp; $.browser.opera) { &#x2F;&#x2F; correction for Opera when fixed and scrolled
			$.datepicker._pos[0] -= document.documentElement.scrollLeft;
			$.datepicker._pos[1] -= document.documentElement.scrollTop;
		}
		var offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		&#x2F;&#x2F;to avoid flashes on Firefox
		inst.dpDiv.empty();
		&#x2F;&#x2F; determine sizing offscreen
		inst.dpDiv.css({position: &#x27;absolute&#x27;, display: &#x27;block&#x27;, top: &#x27;-1000px&#x27;});
		$.datepicker._updateDatepicker(inst);
		&#x2F;&#x2F; fix width for dynamic number of date pickers
		&#x2F;&#x2F; and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog &amp;&amp; $.blockUI ?
			&#x27;static&#x27; : (isFixed ? &#x27;fixed&#x27; : &#x27;absolute&#x27;)), display: &#x27;none&#x27;,
			left: offset.left + &#x27;px&#x27;, top: offset.top + &#x27;px&#x27;});
		if (!inst.inline) {
			var showAnim = $.datepicker._get(inst, &#x27;showAnim&#x27;);
			var duration = $.datepicker._get(inst, &#x27;duration&#x27;);
			var postProcess = function() {
				var cover = inst.dpDiv.find(&#x27;iframe.ui-datepicker-cover&#x27;); &#x2F;&#x2F; IE6- only
				if( !! cover.length ){
					var borders = $.datepicker._getBorders(inst.dpDiv);
					cover.css({left: -borders[0], top: -borders[1],
						width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()});
				}
			};
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;
			if ($.effects &amp;&amp; $.effects[showAnim])
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, &#x27;showOptions&#x27;), duration, postProcess);
			else
				inst.dpDiv[showAnim || &#x27;show&#x27;]((showAnim ? duration : null), postProcess);
			if (!showAnim || !duration)
				postProcess();
			if (inst.input.is(&#x27;:visible&#x27;) &amp;&amp; !inst.input.is(&#x27;:disabled&#x27;))
				inst.input.focus();
			$.datepicker._curInst = inst;
		}
	},

	&#x2F;* Generate the date picker content. *&#x2F;
	_updateDatepicker: function(inst) {
		var self = this;
		self.maxRows = 4; &#x2F;&#x2F;Reset the max number of rows being displayed (see #7043)
		var borders = $.datepicker._getBorders(inst.dpDiv);
		instActive = inst; &#x2F;&#x2F; for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);
		var cover = inst.dpDiv.find(&#x27;iframe.ui-datepicker-cover&#x27;); &#x2F;&#x2F; IE6- only
		if( !!cover.length ){ &#x2F;&#x2F;avoid call to outerXXXX() when not in IE6
			cover.css({left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()})
		}
		inst.dpDiv.find(&#x27;.&#x27; + this._dayOverClass + &#x27; a&#x27;).mouseover();
		var numMonths = this._getNumberOfMonths(inst);
		var cols = numMonths[1];
		var width = 17;
		inst.dpDiv.removeClass(&#x27;ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4&#x27;).width(&#x27;&#x27;);
		if (cols &gt; 1)
			inst.dpDiv.addClass(&#x27;ui-datepicker-multi-&#x27; + cols).css(&#x27;width&#x27;, (width * cols) + &#x27;em&#x27;);
		inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? &#x27;add&#x27; : &#x27;remove&#x27;) +
			&#x27;Class&#x27;](&#x27;ui-datepicker-multi&#x27;);
		inst.dpDiv[(this._get(inst, &#x27;isRTL&#x27;) ? &#x27;add&#x27; : &#x27;remove&#x27;) +
			&#x27;Class&#x27;](&#x27;ui-datepicker-rtl&#x27;);
		if (inst == $.datepicker._curInst &amp;&amp; $.datepicker._datepickerShowing &amp;&amp; inst.input &amp;&amp;
				&#x2F;&#x2F; #6694 - don&#x27;t focus the input if it&#x27;s already focused
				&#x2F;&#x2F; this breaks the change event in IE
				inst.input.is(&#x27;:visible&#x27;) &amp;&amp; !inst.input.is(&#x27;:disabled&#x27;) &amp;&amp; inst.input[0] != document.activeElement)
			inst.input.focus();
		&#x2F;&#x2F; deffered render of the years select (to avoid flashes on Firefox) 
		if( inst.yearshtml ){
			var origyearshtml = inst.yearshtml;
			setTimeout(function(){
				&#x2F;&#x2F;assure that inst.yearshtml didn&#x27;t change.
				if( origyearshtml === inst.yearshtml &amp;&amp; inst.yearshtml ){
					inst.dpDiv.find(&#x27;select.ui-datepicker-year:first&#x27;).replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	&#x2F;* Retrieve the size of left and top borders for an element.
	   @param  elem  (jQuery object) the element of interest
	   @return  (number[2]) the left and top borders *&#x2F;
	_getBorders: function(elem) {
		var convert = function(value) {
			return {thin: 1, medium: 2, thick: 3}[value] || value;
		};
		return [parseFloat(convert(elem.css(&#x27;border-left-width&#x27;))),
			parseFloat(convert(elem.css(&#x27;border-top-width&#x27;)))];
	},

	&#x2F;* Check positioning to remain on screen. *&#x2F;
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth();
		var dpHeight = inst.dpDiv.outerHeight();
		var inputWidth = inst.input ? inst.input.outerWidth() : 0;
		var inputHeight = inst.input ? inst.input.outerHeight() : 0;
		var viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft());
		var viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, &#x27;isRTL&#x27;) ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed &amp;&amp; offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed &amp;&amp; offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		&#x2F;&#x2F; now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth &gt; viewWidth &amp;&amp; viewWidth &gt; dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight &gt; viewHeight &amp;&amp; viewHeight &gt; dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	&#x2F;* Find an object&#x27;s position on the screen. *&#x2F;
	_findPos: function(obj) {
		var inst = this._getInst(obj);
		var isRTL = this._get(inst, &#x27;isRTL&#x27;);
        while (obj &amp;&amp; (obj.type == &#x27;hidden&#x27; || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
            obj = obj[isRTL ? &#x27;previousSibling&#x27; : &#x27;nextSibling&#x27;];
        }
        var position = $(obj).offset();
	    return [position.left, position.top];
	},

	&#x2F;* Hide the date picker from view.
	   @param  input  element - the input field attached to the date picker *&#x2F;
	_hideDatepicker: function(input) {
		var inst = this._curInst;
		if (!inst || (input &amp;&amp; inst != $.data(input, PROP_NAME)))
			return;
		if (this._datepickerShowing) {
			var showAnim = this._get(inst, &#x27;showAnim&#x27;);
			var duration = this._get(inst, &#x27;duration&#x27;);
			var postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};
			if ($.effects &amp;&amp; $.effects[showAnim])
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, &#x27;showOptions&#x27;), duration, postProcess);
			else
				inst.dpDiv[(showAnim == &#x27;slideDown&#x27; ? &#x27;slideUp&#x27; :
					(showAnim == &#x27;fadeIn&#x27; ? &#x27;fadeOut&#x27; : &#x27;hide&#x27;))]((showAnim ? duration : null), postProcess);
			if (!showAnim)
				postProcess();
			this._datepickerShowing = false;
			var onClose = this._get(inst, &#x27;onClose&#x27;);
			if (onClose)
				onClose.apply((inst.input ? inst.input[0] : null),
					[(inst.input ? inst.input.val() : &#x27;&#x27;), inst]);
			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: &#x27;absolute&#x27;, left: &#x27;0&#x27;, top: &#x27;-100px&#x27; });
				if ($.blockUI) {
					$.unblockUI();
					$(&#x27;body&#x27;).append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	&#x2F;* Tidy up after a dialog display. *&#x2F;
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind(&#x27;.ui-datepicker-calendar&#x27;);
	},

	&#x2F;* Close date picker if clicked elsewhere. *&#x2F;
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst)
			return;

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id != $.datepicker._mainDivId &amp;&amp;
				$target.parents(&#x27;#&#x27; + $.datepicker._mainDivId).length == 0 &amp;&amp;
				!$target.hasClass($.datepicker.markerClassName) &amp;&amp;
				!$target.closest(&quot;.&quot; + $.datepicker._triggerClass).length &amp;&amp;
				$.datepicker._datepickerShowing &amp;&amp; !($.datepicker._inDialog &amp;&amp; $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) &amp;&amp; $.datepicker._curInst != inst ) )
			$.datepicker._hideDatepicker();
	},

	&#x2F;* Adjust one of the date sub-fields. *&#x2F;
	_adjustDate: function(id, offset, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period == &#x27;M&#x27; ? this._get(inst, &#x27;showCurrentAtPos&#x27;) : 0), &#x2F;&#x2F; undo positioning
			period);
		this._updateDatepicker(inst);
	},

	&#x2F;* Action for current link. *&#x2F;
	_gotoToday: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._get(inst, &#x27;gotoCurrent&#x27;) &amp;&amp; inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		}
		else {
			var date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	&#x2F;* Action for selecting a new month&#x2F;year. *&#x2F;
	_selectMonthYear: function(id, select, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		inst[&#x27;selected&#x27; + (period == &#x27;M&#x27; ? &#x27;Month&#x27; : &#x27;Year&#x27;)] =
		inst[&#x27;draw&#x27; + (period == &#x27;M&#x27; ? &#x27;Month&#x27; : &#x27;Year&#x27;)] =
			parseInt(select.options[select.selectedIndex].value,10);
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	&#x2F;* Action for selecting a day. *&#x2F;
	_selectDay: function(id, month, year, td) {
		var target = $(id);
		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}
		var inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $(&#x27;a&#x27;, td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	&#x2F;* Erase the input field and hide the date picker. *&#x2F;
	_clearDate: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		this._selectDate(target, &#x27;&#x27;);
	},

	&#x2F;* Update the input field with the selected date. *&#x2F;
	_selectDate: function(id, dateStr) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input)
			inst.input.val(dateStr);
		this._updateAlternate(inst);
		var onSelect = this._get(inst, &#x27;onSelect&#x27;);
		if (onSelect)
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  &#x2F;&#x2F; trigger custom callback
		else if (inst.input)
			inst.input.trigger(&#x27;change&#x27;); &#x2F;&#x2F; fire the change event
		if (inst.inline)
			this._updateDatepicker(inst);
		else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) != &#x27;object&#x27;)
				inst.input.focus(); &#x2F;&#x2F; restore focus
			this._lastInput = null;
		}
	},

	&#x2F;* Update any alternate field to synchronise with the main field. *&#x2F;
	_updateAlternate: function(inst) {
		var altField = this._get(inst, &#x27;altField&#x27;);
		if (altField) { &#x2F;&#x2F; update alternate field too
			var altFormat = this._get(inst, &#x27;altFormat&#x27;) || this._get(inst, &#x27;dateFormat&#x27;);
			var date = this._getDate(inst);
			var dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	&#x2F;* Set as beforeShowDay function to prevent selection of weekends.
	   @param  date  Date - the date to customise
	   @return [boolean, string] - is this date selectable?, what is its CSS class? *&#x2F;
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day &gt; 0 &amp;&amp; day &lt; 6), &#x27;&#x27;];
	},

	&#x2F;* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	   @param  date  Date - the date to get the week for
	   @return  number - the number of the week within the year that contains this date *&#x2F;
	iso8601Week: function(date) {
		var checkDate = new Date(date.getTime());
		&#x2F;&#x2F; Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
		var time = checkDate.getTime();
		checkDate.setMonth(0); &#x2F;&#x2F; Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) &#x2F; 86400000) &#x2F; 7) + 1;
	},

	&#x2F;* Parse a string value into a date object.
	   See formatDate below for the possible formats.

	   @param  format    string - the expected format of the date
	   @param  value     string - the date in the above format
	   @param  settings  Object - attributes include:
	                     shortYearCutoff  number - the cutoff year for determining the century (optional)
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  Date - the extracted date value or null if value is blank *&#x2F;
	parseDate: function (format, value, settings) {
		if (format == null || value == null)
			throw &#x27;Invalid arguments&#x27;;
		value = (typeof value == &#x27;object&#x27; ? value.toString() : value + &#x27;&#x27;);
		if (value == &#x27;&#x27;)
			return null;
		var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;
		shortYearCutoff = (typeof shortYearCutoff != &#x27;string&#x27; ? shortYearCutoff :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		var year = -1;
		var month = -1;
		var day = -1;
		var doy = -1;
		var literal = false;
		&#x2F;&#x2F; Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 &lt; format.length &amp;&amp; format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		&#x2F;&#x2F; Extract a number from the string value
		var getNumber = function(match) {
			var isDoubled = lookAhead(match);
			var size = (match == &#x27;@&#x27; ? 14 : (match == &#x27;!&#x27; ? 20 :
				(match == &#x27;y&#x27; &amp;&amp; isDoubled ? 4 : (match == &#x27;o&#x27; ? 3 : 2))));
			var digits = new RegExp(&#x27;^\\d{1,&#x27; + size + &#x27;}&#x27;);
			var num = value.substring(iValue).match(digits);
			if (!num)
				throw &#x27;Missing number at position &#x27; + iValue;
			iValue += num[0].length;
			return parseInt(num[0], 10);
		};
		&#x2F;&#x2F; Extract a name from the string value and convert to an index
		var getName = function(match, shortNames, longNames) {
			var names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
				return [ [k, v] ];
			}).sort(function (a, b) {
				return -(a[1].length - b[1].length);
			});
			var index = -1;
			$.each(names, function (i, pair) {
				var name = pair[1];
				if (value.substr(iValue, name.length).toLowerCase() == name.toLowerCase()) {
					index = pair[0];
					iValue += name.length;
					return false;
				}
			});
			if (index != -1)
				return index + 1;
			else
				throw &#x27;Unknown name at position &#x27; + iValue;
		};
		&#x2F;&#x2F; Confirm that a literal character matches the string value
		var checkLiteral = function() {
			if (value.charAt(iValue) != format.charAt(iFormat))
				throw &#x27;Unexpected literal at position &#x27; + iValue;
			iValue++;
		};
		var iValue = 0;
		for (var iFormat = 0; iFormat &lt; format.length; iFormat++) {
			if (literal)
				if (format.charAt(iFormat) == &quot;&#x27;&quot; &amp;&amp; !lookAhead(&quot;&#x27;&quot;))
					literal = false;
				else
					checkLiteral();
			else
				switch (format.charAt(iFormat)) {
					case &#x27;d&#x27;:
						day = getNumber(&#x27;d&#x27;);
						break;
					case &#x27;D&#x27;:
						getName(&#x27;D&#x27;, dayNamesShort, dayNames);
						break;
					case &#x27;o&#x27;:
						doy = getNumber(&#x27;o&#x27;);
						break;
					case &#x27;m&#x27;:
						month = getNumber(&#x27;m&#x27;);
						break;
					case &#x27;M&#x27;:
						month = getName(&#x27;M&#x27;, monthNamesShort, monthNames);
						break;
					case &#x27;y&#x27;:
						year = getNumber(&#x27;y&#x27;);
						break;
					case &#x27;@&#x27;:
						var date = new Date(getNumber(&#x27;@&#x27;));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case &#x27;!&#x27;:
						var date = new Date((getNumber(&#x27;!&#x27;) - this._ticksTo1970) &#x2F; 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case &quot;&#x27;&quot;:
						if (lookAhead(&quot;&#x27;&quot;))
							checkLiteral();
						else
							literal = true;
						break;
					default:
						checkLiteral();
				}
		}
		if (iValue &lt; value.length){
			throw &quot;Extra&#x2F;unparsed characters found in date: &quot; + value.substring(iValue);
		}
		if (year == -1)
			year = new Date().getFullYear();
		else if (year &lt; 100)
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year &lt;= shortYearCutoff ? 0 : -100);
		if (doy &gt; -1) {
			month = 1;
			day = doy;
			do {
				var dim = this._getDaysInMonth(year, month - 1);
				if (day &lt;= dim)
					break;
				month++;
				day -= dim;
			} while (true);
		}
		var date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day)
			throw &#x27;Invalid date&#x27;; &#x2F;&#x2F; E.g. 31&#x2F;02&#x2F;00
		return date;
	},

	&#x2F;* Standard date formats. *&#x2F;
	ATOM: &#x27;yy-mm-dd&#x27;, &#x2F;&#x2F; RFC 3339 (ISO 8601)
	COOKIE: &#x27;D, dd M yy&#x27;,
	ISO_8601: &#x27;yy-mm-dd&#x27;,
	RFC_822: &#x27;D, d M y&#x27;,
	RFC_850: &#x27;DD, dd-M-y&#x27;,
	RFC_1036: &#x27;D, d M y&#x27;,
	RFC_1123: &#x27;D, d M yy&#x27;,
	RFC_2822: &#x27;D, d M yy&#x27;,
	RSS: &#x27;D, d M y&#x27;, &#x2F;&#x2F; RFC 822
	TICKS: &#x27;!&#x27;,
	TIMESTAMP: &#x27;@&#x27;,
	W3C: &#x27;yy-mm-dd&#x27;, &#x2F;&#x2F; ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 &#x2F; 4) - Math.floor(1970 &#x2F; 100) +
		Math.floor(1970 &#x2F; 400)) * 24 * 60 * 60 * 10000000),

	&#x2F;* Format a date object into a string value.
	   The format can be combinations of the following:
	   d  - day of month (no leading zero)
	   dd - day of month (two digit)
	   o  - day of year (no leading zeros)
	   oo - day of year (three digit)
	   D  - day name short
	   DD - day name long
	   m  - month of year (no leading zero)
	   mm - month of year (two digit)
	   M  - month name short
	   MM - month name long
	   y  - year (two digit)
	   yy - year (four digit)
	   @ - Unix timestamp (ms since 01&#x2F;01&#x2F;1970)
	   ! - Windows ticks (100ns since 01&#x2F;01&#x2F;0001)
	   &#x27;...&#x27; - literal text
	   &#x27;&#x27; - single quote

	   @param  format    string - the desired format of the date
	   @param  date      Date - the date value to format
	   @param  settings  Object - attributes include:
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  string - the date in the above format *&#x2F;
	formatDate: function (format, date, settings) {
		if (!date)
			return &#x27;&#x27;;
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		&#x2F;&#x2F; Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 &lt; format.length &amp;&amp; format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		&#x2F;&#x2F; Format a number, with leading zero if necessary
		var formatNumber = function(match, value, len) {
			var num = &#x27;&#x27; + value;
			if (lookAhead(match))
				while (num.length &lt; len)
					num = &#x27;0&#x27; + num;
			return num;
		};
		&#x2F;&#x2F; Format a name, short or long as requested
		var formatName = function(match, value, shortNames, longNames) {
			return (lookAhead(match) ? longNames[value] : shortNames[value]);
		};
		var output = &#x27;&#x27;;
		var literal = false;
		if (date)
			for (var iFormat = 0; iFormat &lt; format.length; iFormat++) {
				if (literal)
					if (format.charAt(iFormat) == &quot;&#x27;&quot; &amp;&amp; !lookAhead(&quot;&#x27;&quot;))
						literal = false;
					else
						output += format.charAt(iFormat);
				else
					switch (format.charAt(iFormat)) {
						case &#x27;d&#x27;:
							output += formatNumber(&#x27;d&#x27;, date.getDate(), 2);
							break;
						case &#x27;D&#x27;:
							output += formatName(&#x27;D&#x27;, date.getDay(), dayNamesShort, dayNames);
							break;
						case &#x27;o&#x27;:
							output += formatNumber(&#x27;o&#x27;,
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) &#x2F; 86400000), 3);
							break;
						case &#x27;m&#x27;:
							output += formatNumber(&#x27;m&#x27;, date.getMonth() + 1, 2);
							break;
						case &#x27;M&#x27;:
							output += formatName(&#x27;M&#x27;, date.getMonth(), monthNamesShort, monthNames);
							break;
						case &#x27;y&#x27;:
							output += (lookAhead(&#x27;y&#x27;) ? date.getFullYear() :
								(date.getYear() % 100 &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27;) + date.getYear() % 100);
							break;
						case &#x27;@&#x27;:
							output += date.getTime();
							break;
						case &#x27;!&#x27;:
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case &quot;&#x27;&quot;:
							if (lookAhead(&quot;&#x27;&quot;))
								output += &quot;&#x27;&quot;;
							else
								literal = true;
							break;
						default:
							output += format.charAt(iFormat);
					}
			}
		return output;
	},

	&#x2F;* Extract all possible characters from the date format. *&#x2F;
	_possibleChars: function (format) {
		var chars = &#x27;&#x27;;
		var literal = false;
		&#x2F;&#x2F; Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 &lt; format.length &amp;&amp; format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		for (var iFormat = 0; iFormat &lt; format.length; iFormat++)
			if (literal)
				if (format.charAt(iFormat) == &quot;&#x27;&quot; &amp;&amp; !lookAhead(&quot;&#x27;&quot;))
					literal = false;
				else
					chars += format.charAt(iFormat);
			else
				switch (format.charAt(iFormat)) {
					case &#x27;d&#x27;: case &#x27;m&#x27;: case &#x27;y&#x27;: case &#x27;@&#x27;:
						chars += &#x27;0123456789&#x27;;
						break;
					case &#x27;D&#x27;: case &#x27;M&#x27;:
						return null; &#x2F;&#x2F; Accept anything
					case &quot;&#x27;&quot;:
						if (lookAhead(&quot;&#x27;&quot;))
							chars += &quot;&#x27;&quot;;
						else
							literal = true;
						break;
					default:
						chars += format.charAt(iFormat);
				}
		return chars;
	},

	&#x2F;* Get a setting value, defaulting if necessary. *&#x2F;
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	&#x2F;* Parse existing date and initialise date picker. *&#x2F;
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() == inst.lastVal) {
			return;
		}
		var dateFormat = this._get(inst, &#x27;dateFormat&#x27;);
		var dates = inst.lastVal = inst.input ? inst.input.val() : null;
		var date, defaultDate;
		date = defaultDate = this._getDefaultDate(inst);
		var settings = this._getFormatConfig(inst);
		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			this.log(event);
			dates = (noDefault ? &#x27;&#x27; : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	&#x2F;* Retrieve the default date shown on opening. *&#x2F;
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, &#x27;defaultDate&#x27;), new Date()));
	},

	&#x2F;* A date may be specified as an exact value or a relative one. *&#x2F;
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
			var date = new Date();
			date.setDate(date.getDate() + offset);
			return date;
		};
		var offsetString = function(offset) {
			try {
				return $.datepicker.parseDate($.datepicker._get(inst, &#x27;dateFormat&#x27;),
					offset, $.datepicker._getFormatConfig(inst));
			}
			catch (e) {
				&#x2F;&#x2F; Ignore
			}
			var date = (offset.toLowerCase().match(&#x2F;^c&#x2F;) ?
				$.datepicker._getDate(inst) : null) || new Date();
			var year = date.getFullYear();
			var month = date.getMonth();
			var day = date.getDate();
			var pattern = &#x2F;([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?&#x2F;g;
			var matches = pattern.exec(offset);
			while (matches) {
				switch (matches[2] || &#x27;d&#x27;) {
					case &#x27;d&#x27; : case &#x27;D&#x27; :
						day += parseInt(matches[1],10); break;
					case &#x27;w&#x27; : case &#x27;W&#x27; :
						day += parseInt(matches[1],10) * 7; break;
					case &#x27;m&#x27; : case &#x27;M&#x27; :
						month += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
					case &#x27;y&#x27;: case &#x27;Y&#x27; :
						year += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
				}
				matches = pattern.exec(offset);
			}
			return new Date(year, month, day);
		};
		var newDate = (date == null || date === &#x27;&#x27; ? defaultDate : (typeof date == &#x27;string&#x27; ? offsetString(date) :
			(typeof date == &#x27;number&#x27; ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
		newDate = (newDate &amp;&amp; newDate.toString() == &#x27;Invalid Date&#x27; ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	&#x2F;* Handle switch to&#x2F;from daylight saving.
	   Hours may be non-zero on daylight saving cut-over:
	   &gt; 12 when midnight changeover, but then cannot generate
	   midnight datetime, so jump to 1AM, otherwise reset.
	   @param  date  (Date) the date to check
	   @return  (Date) the corrected date *&#x2F;
	_daylightSavingAdjust: function(date) {
		if (!date) return null;
		date.setHours(date.getHours() &gt; 12 ? date.getHours() + 2 : 0);
		return date;
	},

	&#x2F;* Set the date(s) directly. *&#x2F;
	_setDate: function(inst, date, noChange) {
		var clear = !date;
		var origMonth = inst.selectedMonth;
		var origYear = inst.selectedYear;
		var newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) &amp;&amp; !noChange)
			this._notifyChange(inst);
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? &#x27;&#x27; : this._formatDate(inst));
		}
	},

	&#x2F;* Retrieve the date(s) directly. *&#x2F;
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input &amp;&amp; inst.input.val() == &#x27;&#x27;) ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	&#x2F;* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 *&#x2F;
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, &#x27;stepMonths&#x27;);
		var id = &#x27;#&#x27; + inst.id.replace( &#x2F;\\\\&#x2F;g, &quot;\\&quot; );
		inst.dpDiv.find(&#x27;[data-handler]&#x27;).map(function () {
			var handler = {
				prev: function () {
					window[&#x27;DP_jQuery_&#x27; + dpuuid].datepicker._adjustDate(id, -stepMonths, &#x27;M&#x27;);
				},
				next: function () {
					window[&#x27;DP_jQuery_&#x27; + dpuuid].datepicker._adjustDate(id, +stepMonths, &#x27;M&#x27;);
				},
				hide: function () {
					window[&#x27;DP_jQuery_&#x27; + dpuuid].datepicker._hideDatepicker();
				},
				today: function () {
					window[&#x27;DP_jQuery_&#x27; + dpuuid].datepicker._gotoToday(id);
				},
				selectDay: function () {
					window[&#x27;DP_jQuery_&#x27; + dpuuid].datepicker._selectDay(id, +this.getAttribute(&#x27;data-month&#x27;), +this.getAttribute(&#x27;data-year&#x27;), this);
					return false;
				},
				selectMonth: function () {
					window[&#x27;DP_jQuery_&#x27; + dpuuid].datepicker._selectMonthYear(id, this, &#x27;M&#x27;);
					return false;
				},
				selectYear: function () {
					window[&#x27;DP_jQuery_&#x27; + dpuuid].datepicker._selectMonthYear(id, this, &#x27;Y&#x27;);
					return false;
				}
			};
			$(this).bind(this.getAttribute(&#x27;data-event&#x27;), handler[this.getAttribute(&#x27;data-handler&#x27;)]);
		});
	},
	
	&#x2F;* Generate the HTML for the current state of the date picker. *&#x2F;
	_generateHTML: function(inst) {
		var today = new Date();
		today = this._daylightSavingAdjust(
			new Date(today.getFullYear(), today.getMonth(), today.getDate())); &#x2F;&#x2F; clear time
		var isRTL = this._get(inst, &#x27;isRTL&#x27;);
		var showButtonPanel = this._get(inst, &#x27;showButtonPanel&#x27;);
		var hideIfNoPrevNext = this._get(inst, &#x27;hideIfNoPrevNext&#x27;);
		var navigationAsDateFormat = this._get(inst, &#x27;navigationAsDateFormat&#x27;);
		var numMonths = this._getNumberOfMonths(inst);
		var showCurrentAtPos = this._get(inst, &#x27;showCurrentAtPos&#x27;);
		var stepMonths = this._get(inst, &#x27;stepMonths&#x27;);
		var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);
		var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
			new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		var minDate = this._getMinMaxDate(inst, &#x27;min&#x27;);
		var maxDate = this._getMinMaxDate(inst, &#x27;max&#x27;);
		var drawMonth = inst.drawMonth - showCurrentAtPos;
		var drawYear = inst.drawYear;
		if (drawMonth &lt; 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate &amp;&amp; maxDraw &lt; minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) &gt; maxDraw) {
				drawMonth--;
				if (drawMonth &lt; 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;
		var prevText = this._get(inst, &#x27;prevText&#x27;);
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));
		var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			&#x27;&lt;a class=&quot;ui-datepicker-prev ui-corner-all&quot; data-handler=&quot;prev&quot; data-event=&quot;click&quot;&#x27; +
			&#x27; title=&quot;&#x27; + prevText + &#x27;&quot;&gt;&lt;span class=&quot;ui-icon ui-icon-circle-triangle-&#x27; + ( isRTL ? &#x27;e&#x27; : &#x27;w&#x27;) + &#x27;&quot;&gt;&#x27; + prevText + &#x27;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&#x27; :
			(hideIfNoPrevNext ? &#x27;&#x27; : &#x27;&lt;a class=&quot;ui-datepicker-prev ui-corner-all ui-state-disabled&quot; title=&quot;&#x27;+ prevText +&#x27;&quot;&gt;&lt;span class=&quot;ui-icon ui-icon-circle-triangle-&#x27; + ( isRTL ? &#x27;e&#x27; : &#x27;w&#x27;) + &#x27;&quot;&gt;&#x27; + prevText + &#x27;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&#x27;));
		var nextText = this._get(inst, &#x27;nextText&#x27;);
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));
		var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			&#x27;&lt;a class=&quot;ui-datepicker-next ui-corner-all&quot; data-handler=&quot;next&quot; data-event=&quot;click&quot;&#x27; +
			&#x27; title=&quot;&#x27; + nextText + &#x27;&quot;&gt;&lt;span class=&quot;ui-icon ui-icon-circle-triangle-&#x27; + ( isRTL ? &#x27;w&#x27; : &#x27;e&#x27;) + &#x27;&quot;&gt;&#x27; + nextText + &#x27;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&#x27; :
			(hideIfNoPrevNext ? &#x27;&#x27; : &#x27;&lt;a class=&quot;ui-datepicker-next ui-corner-all ui-state-disabled&quot; title=&quot;&#x27;+ nextText + &#x27;&quot;&gt;&lt;span class=&quot;ui-icon ui-icon-circle-triangle-&#x27; + ( isRTL ? &#x27;w&#x27; : &#x27;e&#x27;) + &#x27;&quot;&gt;&#x27; + nextText + &#x27;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&#x27;));
		var currentText = this._get(inst, &#x27;currentText&#x27;);
		var gotoDate = (this._get(inst, &#x27;gotoCurrent&#x27;) &amp;&amp; inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
		var controls = (!inst.inline ? &#x27;&lt;button type=&quot;button&quot; class=&quot;ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all&quot; data-handler=&quot;hide&quot; data-event=&quot;click&quot;&gt;&#x27; +
			this._get(inst, &#x27;closeText&#x27;) + &#x27;&lt;&#x2F;button&gt;&#x27; : &#x27;&#x27;);
		var buttonPanel = (showButtonPanel) ? &#x27;&lt;div class=&quot;ui-datepicker-buttonpane ui-widget-content&quot;&gt;&#x27; + (isRTL ? controls : &#x27;&#x27;) +
			(this._isInRange(inst, gotoDate) ? &#x27;&lt;button type=&quot;button&quot; class=&quot;ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all&quot; data-handler=&quot;today&quot; data-event=&quot;click&quot;&#x27; +
			&#x27;&gt;&#x27; + currentText + &#x27;&lt;&#x2F;button&gt;&#x27; : &#x27;&#x27;) + (isRTL ? &#x27;&#x27; : controls) + &#x27;&lt;&#x2F;div&gt;&#x27; : &#x27;&#x27;;
		var firstDay = parseInt(this._get(inst, &#x27;firstDay&#x27;),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);
		var showWeek = this._get(inst, &#x27;showWeek&#x27;);
		var dayNames = this._get(inst, &#x27;dayNames&#x27;);
		var dayNamesShort = this._get(inst, &#x27;dayNamesShort&#x27;);
		var dayNamesMin = this._get(inst, &#x27;dayNamesMin&#x27;);
		var monthNames = this._get(inst, &#x27;monthNames&#x27;);
		var monthNamesShort = this._get(inst, &#x27;monthNamesShort&#x27;);
		var beforeShowDay = this._get(inst, &#x27;beforeShowDay&#x27;);
		var showOtherMonths = this._get(inst, &#x27;showOtherMonths&#x27;);
		var selectOtherMonths = this._get(inst, &#x27;selectOtherMonths&#x27;);
		var calculateWeek = this._get(inst, &#x27;calculateWeek&#x27;) || this.iso8601Week;
		var defaultDate = this._getDefaultDate(inst);
		var html = &#x27;&#x27;;
		for (var row = 0; row &lt; numMonths[0]; row++) {
			var group = &#x27;&#x27;;
			this.maxRows = 4;
			for (var col = 0; col &lt; numMonths[1]; col++) {
				var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				var cornerClass = &#x27; ui-corner-all&#x27;;
				var calender = &#x27;&#x27;;
				if (isMultiMonth) {
					calender += &#x27;&lt;div class=&quot;ui-datepicker-group&#x27;;
					if (numMonths[1] &gt; 1)
						switch (col) {
							case 0: calender += &#x27; ui-datepicker-group-first&#x27;;
								cornerClass = &#x27; ui-corner-&#x27; + (isRTL ? &#x27;right&#x27; : &#x27;left&#x27;); break;
							case numMonths[1]-1: calender += &#x27; ui-datepicker-group-last&#x27;;
								cornerClass = &#x27; ui-corner-&#x27; + (isRTL ? &#x27;left&#x27; : &#x27;right&#x27;); break;
							default: calender += &#x27; ui-datepicker-group-middle&#x27;; cornerClass = &#x27;&#x27;; break;
						}
					calender += &#x27;&quot;&gt;&#x27;;
				}
				calender += &#x27;&lt;div class=&quot;ui-datepicker-header ui-widget-header ui-helper-clearfix&#x27; + cornerClass + &#x27;&quot;&gt;&#x27; +
					(&#x2F;all|left&#x2F;.test(cornerClass) &amp;&amp; row == 0 ? (isRTL ? next : prev) : &#x27;&#x27;) +
					(&#x2F;all|right&#x2F;.test(cornerClass) &amp;&amp; row == 0 ? (isRTL ? prev : next) : &#x27;&#x27;) +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row &gt; 0 || col &gt; 0, monthNames, monthNamesShort) + &#x2F;&#x2F; draw month headers
					&#x27;&lt;&#x2F;div&gt;&lt;table class=&quot;ui-datepicker-calendar&quot;&gt;&lt;thead&gt;&#x27; +
					&#x27;&lt;tr&gt;&#x27;;
				var thead = (showWeek ? &#x27;&lt;th class=&quot;ui-datepicker-week-col&quot;&gt;&#x27; + this._get(inst, &#x27;weekHeader&#x27;) + &#x27;&lt;&#x2F;th&gt;&#x27; : &#x27;&#x27;);
				for (var dow = 0; dow &lt; 7; dow++) { &#x2F;&#x2F; days of the week
					var day = (dow + firstDay) % 7;
					thead += &#x27;&lt;th&#x27; + ((dow + firstDay + 6) % 7 &gt;= 5 ? &#x27; class=&quot;ui-datepicker-week-end&quot;&#x27; : &#x27;&#x27;) + &#x27;&gt;&#x27; +
						&#x27;&lt;span title=&quot;&#x27; + dayNames[day] + &#x27;&quot;&gt;&#x27; + dayNamesMin[day] + &#x27;&lt;&#x2F;span&gt;&lt;&#x2F;th&gt;&#x27;;
				}
				calender += thead + &#x27;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;&#x27;;
				var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear == inst.selectedYear &amp;&amp; drawMonth == inst.selectedMonth)
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				var curRows = Math.ceil((leadDays + daysInMonth) &#x2F; 7); &#x2F;&#x2F; calculate the number of rows to generate
				var numRows = (isMultiMonth ? this.maxRows &gt; curRows ? this.maxRows : curRows : curRows); &#x2F;&#x2F;If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (var dRow = 0; dRow &lt; numRows; dRow++) { &#x2F;&#x2F; create date picker rows
					calender += &#x27;&lt;tr&gt;&#x27;;
					var tbody = (!showWeek ? &#x27;&#x27; : &#x27;&lt;td class=&quot;ui-datepicker-week-col&quot;&gt;&#x27; +
						this._get(inst, &#x27;calculateWeek&#x27;)(printDate) + &#x27;&lt;&#x2F;td&gt;&#x27;);
					for (var dow = 0; dow &lt; 7; dow++) { &#x2F;&#x2F; create date picker days
						var daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, &#x27;&#x27;]);
						var otherMonth = (printDate.getMonth() != drawMonth);
						var unselectable = (otherMonth &amp;&amp; !selectOtherMonths) || !daySettings[0] ||
							(minDate &amp;&amp; printDate &lt; minDate) || (maxDate &amp;&amp; printDate &gt; maxDate);
						tbody += &#x27;&lt;td class=&quot;&#x27; +
							((dow + firstDay + 6) % 7 &gt;= 5 ? &#x27; ui-datepicker-week-end&#x27; : &#x27;&#x27;) + &#x2F;&#x2F; highlight weekends
							(otherMonth ? &#x27; ui-datepicker-other-month&#x27; : &#x27;&#x27;) + &#x2F;&#x2F; highlight days from other months
							((printDate.getTime() == selectedDate.getTime() &amp;&amp; drawMonth == inst.selectedMonth &amp;&amp; inst._keyEvent) || &#x2F;&#x2F; user pressed key
							(defaultDate.getTime() == printDate.getTime() &amp;&amp; defaultDate.getTime() == selectedDate.getTime()) ?
							&#x2F;&#x2F; or defaultDate is current printedDate and defaultDate is selectedDate
							&#x27; &#x27; + this._dayOverClass : &#x27;&#x27;) + &#x2F;&#x2F; highlight selected day
							(unselectable ? &#x27; &#x27; + this._unselectableClass + &#x27; ui-state-disabled&#x27;: &#x27;&#x27;) +  &#x2F;&#x2F; highlight unselectable days
							(otherMonth &amp;&amp; !showOtherMonths ? &#x27;&#x27; : &#x27; &#x27; + daySettings[1] + &#x2F;&#x2F; highlight custom dates
							(printDate.getTime() == currentDate.getTime() ? &#x27; &#x27; + this._currentClass : &#x27;&#x27;) + &#x2F;&#x2F; highlight selected day
							(printDate.getTime() == today.getTime() ? &#x27; ui-datepicker-today&#x27; : &#x27;&#x27;)) + &#x27;&quot;&#x27; + &#x2F;&#x2F; highlight today (if different)
							((!otherMonth || showOtherMonths) &amp;&amp; daySettings[2] ? &#x27; title=&quot;&#x27; + daySettings[2] + &#x27;&quot;&#x27; : &#x27;&#x27;) + &#x2F;&#x2F; cell title
							(unselectable ? &#x27;&#x27; : &#x27; data-handler=&quot;selectDay&quot; data-event=&quot;click&quot; data-month=&quot;&#x27; + printDate.getMonth() + &#x27;&quot; data-year=&quot;&#x27; + printDate.getFullYear() + &#x27;&quot;&#x27;) + &#x27;&gt;&#x27; + &#x2F;&#x2F; actions
							(otherMonth &amp;&amp; !showOtherMonths ? &#x27;&amp;#xa0;&#x27; : &#x2F;&#x2F; display for other months
							(unselectable ? &#x27;&lt;span class=&quot;ui-state-default&quot;&gt;&#x27; + printDate.getDate() + &#x27;&lt;&#x2F;span&gt;&#x27; : &#x27;&lt;a class=&quot;ui-state-default&#x27; +
							(printDate.getTime() == today.getTime() ? &#x27; ui-state-highlight&#x27; : &#x27;&#x27;) +
							(printDate.getTime() == currentDate.getTime() ? &#x27; ui-state-active&#x27; : &#x27;&#x27;) + &#x2F;&#x2F; highlight selected day
							(otherMonth ? &#x27; ui-priority-secondary&#x27; : &#x27;&#x27;) + &#x2F;&#x2F; distinguish dates from other months
							&#x27;&quot; href=&quot;#&quot;&gt;&#x27; + printDate.getDate() + &#x27;&lt;&#x2F;a&gt;&#x27;)) + &#x27;&lt;&#x2F;td&gt;&#x27;; &#x2F;&#x2F; display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + &#x27;&lt;&#x2F;tr&gt;&#x27;;
				}
				drawMonth++;
				if (drawMonth &gt; 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += &#x27;&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;&#x27; + (isMultiMonth ? &#x27;&lt;&#x2F;div&gt;&#x27; + 
							((numMonths[0] &gt; 0 &amp;&amp; col == numMonths[1]-1) ? &#x27;&lt;div class=&quot;ui-datepicker-row-break&quot;&gt;&lt;&#x2F;div&gt;&#x27; : &#x27;&#x27;) : &#x27;&#x27;);
				group += calender;
			}
			html += group;
		}
		html += buttonPanel + ($.browser.msie &amp;&amp; parseInt($.browser.version,10) &lt; 7 &amp;&amp; !inst.inline ?
			&#x27;&lt;iframe src=&quot;javascript:false;&quot; class=&quot;ui-datepicker-cover&quot; frameborder=&quot;0&quot;&gt;&lt;&#x2F;iframe&gt;&#x27; : &#x27;&#x27;);
		inst._keyEvent = false;
		return html;
	},

	&#x2F;* Generate the month and year header. *&#x2F;
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {
		var changeMonth = this._get(inst, &#x27;changeMonth&#x27;);
		var changeYear = this._get(inst, &#x27;changeYear&#x27;);
		var showMonthAfterYear = this._get(inst, &#x27;showMonthAfterYear&#x27;);
		var html = &#x27;&lt;div class=&quot;ui-datepicker-title&quot;&gt;&#x27;;
		var monthHtml = &#x27;&#x27;;
		&#x2F;&#x2F; month selection
		if (secondary || !changeMonth)
			monthHtml += &#x27;&lt;span class=&quot;ui-datepicker-month&quot;&gt;&#x27; + monthNames[drawMonth] + &#x27;&lt;&#x2F;span&gt;&#x27;;
		else {
			var inMinYear = (minDate &amp;&amp; minDate.getFullYear() == drawYear);
			var inMaxYear = (maxDate &amp;&amp; maxDate.getFullYear() == drawYear);
			monthHtml += &#x27;&lt;select class=&quot;ui-datepicker-month&quot; data-handler=&quot;selectMonth&quot; data-event=&quot;change&quot;&gt;&#x27;;
			for (var month = 0; month &lt; 12; month++) {
				if ((!inMinYear || month &gt;= minDate.getMonth()) &amp;&amp;
						(!inMaxYear || month &lt;= maxDate.getMonth()))
					monthHtml += &#x27;&lt;option value=&quot;&#x27; + month + &#x27;&quot;&#x27; +
						(month == drawMonth ? &#x27; selected=&quot;selected&quot;&#x27; : &#x27;&#x27;) +
						&#x27;&gt;&#x27; + monthNamesShort[month] + &#x27;&lt;&#x2F;option&gt;&#x27;;
			}
			monthHtml += &#x27;&lt;&#x2F;select&gt;&#x27;;
		}
		if (!showMonthAfterYear)
			html += monthHtml + (secondary || !(changeMonth &amp;&amp; changeYear) ? &#x27;&amp;#xa0;&#x27; : &#x27;&#x27;);
		&#x2F;&#x2F; year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = &#x27;&#x27;;
			if (secondary || !changeYear)
				html += &#x27;&lt;span class=&quot;ui-datepicker-year&quot;&gt;&#x27; + drawYear + &#x27;&lt;&#x2F;span&gt;&#x27;;
			else {
				&#x2F;&#x2F; determine range of years to display
				var years = this._get(inst, &#x27;yearRange&#x27;).split(&#x27;:&#x27;);
				var thisYear = new Date().getFullYear();
				var determineYear = function(value) {
					var year = (value.match(&#x2F;c[+-].*&#x2F;) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(&#x2F;[+-].*&#x2F;) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				var year = determineYear(years[0]);
				var endYear = Math.max(year, determineYear(years[1] || &#x27;&#x27;));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += &#x27;&lt;select class=&quot;ui-datepicker-year&quot; data-handler=&quot;selectYear&quot; data-event=&quot;change&quot;&gt;&#x27;;
				for (; year &lt;= endYear; year++) {
					inst.yearshtml += &#x27;&lt;option value=&quot;&#x27; + year + &#x27;&quot;&#x27; +
						(year == drawYear ? &#x27; selected=&quot;selected&quot;&#x27; : &#x27;&#x27;) +
						&#x27;&gt;&#x27; + year + &#x27;&lt;&#x2F;option&gt;&#x27;;
				}
				inst.yearshtml += &#x27;&lt;&#x2F;select&gt;&#x27;;
				
				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}
		html += this._get(inst, &#x27;yearSuffix&#x27;);
		if (showMonthAfterYear)
			html += (secondary || !(changeMonth &amp;&amp; changeYear) ? &#x27;&amp;#xa0;&#x27; : &#x27;&#x27;) + monthHtml;
		html += &#x27;&lt;&#x2F;div&gt;&#x27;; &#x2F;&#x2F; Close datepicker_header
		return html;
	},

	&#x2F;* Adjust one of the date sub-fields. *&#x2F;
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period == &#x27;Y&#x27; ? offset : 0);
		var month = inst.drawMonth + (period == &#x27;M&#x27; ? offset : 0);
		var day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) +
			(period == &#x27;D&#x27; ? offset : 0);
		var date = this._restrictMinMax(inst,
			this._daylightSavingAdjust(new Date(year, month, day)));
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period == &#x27;M&#x27; || period == &#x27;Y&#x27;)
			this._notifyChange(inst);
	},

	&#x2F;* Ensure a date is within any min&#x2F;max bounds. *&#x2F;
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, &#x27;min&#x27;);
		var maxDate = this._getMinMaxDate(inst, &#x27;max&#x27;);
		var newDate = (minDate &amp;&amp; date &lt; minDate ? minDate : date);
		newDate = (maxDate &amp;&amp; newDate &gt; maxDate ? maxDate : newDate);
		return newDate;
	},

	&#x2F;* Notify change of month&#x2F;year. *&#x2F;
	_notifyChange: function(inst) {
		var onChange = this._get(inst, &#x27;onChangeMonthYear&#x27;);
		if (onChange)
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
	},

	&#x2F;* Determine the number of months to show. *&#x2F;
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, &#x27;numberOfMonths&#x27;);
		return (numMonths == null ? [1, 1] : (typeof numMonths == &#x27;number&#x27; ? [1, numMonths] : numMonths));
	},

	&#x2F;* Determine the current maximum date - ensure no time components are set. *&#x2F;
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + &#x27;Date&#x27;), null);
	},

	&#x2F;* Find the number of days in a given month. *&#x2F;
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	&#x2F;* Find the day of the week of the first of a month. *&#x2F;
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	&#x2F;* Determines if we should allow a &quot;next&#x2F;prev&quot; month display change. *&#x2F;
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst);
		var date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset &lt; 0 ? offset : numMonths[0] * numMonths[1]), 1));
		if (offset &lt; 0)
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		return this._isInRange(inst, date);
	},

	&#x2F;* Is the given date in the accepted range? *&#x2F;
	_isInRange: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, &#x27;min&#x27;);
		var maxDate = this._getMinMaxDate(inst, &#x27;max&#x27;);
		return ((!minDate || date.getTime() &gt;= minDate.getTime()) &amp;&amp;
			(!maxDate || date.getTime() &lt;= maxDate.getTime()));
	},

	&#x2F;* Provide the configuration settings for formatting&#x2F;parsing. *&#x2F;
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, &#x27;shortYearCutoff&#x27;);
		shortYearCutoff = (typeof shortYearCutoff != &#x27;string&#x27; ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, &#x27;dayNamesShort&#x27;), dayNames: this._get(inst, &#x27;dayNames&#x27;),
			monthNamesShort: this._get(inst, &#x27;monthNamesShort&#x27;), monthNames: this._get(inst, &#x27;monthNames&#x27;)};
	},

	&#x2F;* Format the given date for display. *&#x2F;
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day == &#x27;object&#x27; ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, &#x27;dateFormat&#x27;), date, this._getFormatConfig(inst));
	}
});

&#x2F;*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 *&#x2F; 
function bindHover(dpDiv) {
	var selector = &#x27;button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a&#x27;;
	return dpDiv.bind(&#x27;mouseout&#x27;, function(event) {
			var elem = $( event.target ).closest( selector );
			if ( !elem.length ) {
				return;
			}
			elem.removeClass( &quot;ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover&quot; );
		})
		.bind(&#x27;mouseover&#x27;, function(event) {
			var elem = $( event.target ).closest( selector );
			if ($.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0]) ||
					!elem.length ) {
				return;
			}
			elem.parents(&#x27;.ui-datepicker-calendar&#x27;).find(&#x27;a&#x27;).removeClass(&#x27;ui-state-hover&#x27;);
			elem.addClass(&#x27;ui-state-hover&#x27;);
			if (elem.hasClass(&#x27;ui-datepicker-prev&#x27;)) elem.addClass(&#x27;ui-datepicker-prev-hover&#x27;);
			if (elem.hasClass(&#x27;ui-datepicker-next&#x27;)) elem.addClass(&#x27;ui-datepicker-next-hover&#x27;);
		});
}

&#x2F;* jQuery extend now ignores nulls! *&#x2F;
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props)
		if (props[name] == null || props[name] == undefined)
			target[name] = props[name];
	return target;
};

&#x2F;* Determine whether an object is an array. *&#x2F;
function isArray(a) {
	return (a &amp;&amp; (($.browser.safari &amp;&amp; typeof a == &#x27;object&#x27; &amp;&amp; a.length) ||
		(a.constructor &amp;&amp; a.constructor.toString().match(&#x2F;\Array\(\)&#x2F;))));
};

&#x2F;* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
                    Object - settings for attaching new datepicker functionality
   @return  jQuery object *&#x2F;
$.fn.datepicker = function(options){
	
	&#x2F;* Verify an empty collection wasn&#x27;t passed - Fixes #6976 *&#x2F;
	if ( !this.length ) {
		return this;
	}
	
	&#x2F;* Initialise the date picker. *&#x2F;
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick).
			find(&#x27;body&#x27;).append($.datepicker.dpDiv);
		$.datepicker.initialized = true;
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options == &#x27;string&#x27; &amp;&amp; (options == &#x27;isDisabled&#x27; || options == &#x27;getDate&#x27; || options == &#x27;widget&#x27;))
		return $.datepicker[&#x27;_&#x27; + options + &#x27;Datepicker&#x27;].
			apply($.datepicker, [this[0]].concat(otherArgs));
	if (options == &#x27;option&#x27; &amp;&amp; arguments.length == 2 &amp;&amp; typeof arguments[1] == &#x27;string&#x27;)
		return $.datepicker[&#x27;_&#x27; + options + &#x27;Datepicker&#x27;].
			apply($.datepicker, [this[0]].concat(otherArgs));
	return this.each(function() {
		typeof options == &#x27;string&#x27; ?
			$.datepicker[&#x27;_&#x27; + options + &#x27;Datepicker&#x27;].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); &#x2F;&#x2F; singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = &quot;1.8.23&quot;;

&#x2F;&#x2F; Workaround for #4055
&#x2F;&#x2F; Add another global to avoid noConflict issues with inline event handlers
window[&#x27;DP_jQuery_&#x27; + dpuuid] = $;

})(jQuery);

(function( $, undefined ) {

var uiDialogClasses =
		&#x27;ui-dialog &#x27; +
		&#x27;ui-widget &#x27; +
		&#x27;ui-widget-content &#x27; +
		&#x27;ui-corner-all &#x27;,
	sizeRelatedOptions = {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},
	resizableRelatedOptions = {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	};

$.widget(&quot;ui.dialog&quot;, {
	options: {
		autoOpen: true,
		buttons: {},
		closeOnEscape: true,
		closeText: &#x27;close&#x27;,
		dialogClass: &#x27;&#x27;,
		draggable: true,
		hide: null,
		height: &#x27;auto&#x27;,
		maxHeight: false,
		maxWidth: false,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: &#x27;center&#x27;,
			at: &#x27;center&#x27;,
			collision: &#x27;fit&#x27;,
			&#x2F;&#x2F; ensure that the titlebar is never outside the document
			using: function(pos) {
				var topOffset = $(this).css(pos).offset().top;
				if (topOffset &lt; 0) {
					$(this).css(&#x27;top&#x27;, pos.top - topOffset);
				}
			}
		},
		resizable: true,
		show: null,
		stack: true,
		title: &#x27;&#x27;,
		width: 300,
		zIndex: 1000
	},

	_create: function() {
		this.originalTitle = this.element.attr(&#x27;title&#x27;);
		&#x2F;&#x2F; #5742 - .attr() might return a DOMElement
		if ( typeof this.originalTitle !== &quot;string&quot; ) {
			this.originalTitle = &quot;&quot;;
		}

		this.options.title = this.options.title || this.originalTitle;
		var self = this,
			options = self.options,

			title = options.title || &#x27;&amp;#160;&#x27;,
			titleId = $.ui.dialog.getTitleId(self.element),

			uiDialog = (self.uiDialog = $(&#x27;&lt;div&gt;&lt;&#x2F;div&gt;&#x27;))
				.appendTo(document.body)
				.hide()
				.addClass(uiDialogClasses + options.dialogClass)
				.css({
					zIndex: options.zIndex
				})
				&#x2F;&#x2F; setting tabIndex makes the div focusable
				&#x2F;&#x2F; setting outline to 0 prevents a border on focus in Mozilla
				.attr(&#x27;tabIndex&#x27;, -1).css(&#x27;outline&#x27;, 0).keydown(function(event) {
					if (options.closeOnEscape &amp;&amp; !event.isDefaultPrevented() &amp;&amp; event.keyCode &amp;&amp;
						event.keyCode === $.ui.keyCode.ESCAPE) {
						
						self.close(event);
						event.preventDefault();
					}
				})
				.attr({
					role: &#x27;dialog&#x27;,
					&#x27;aria-labelledby&#x27;: titleId
				})
				.mousedown(function(event) {
					self.moveToTop(false, event);
				}),

			uiDialogContent = self.element
				.show()
				.removeAttr(&#x27;title&#x27;)
				.addClass(
					&#x27;ui-dialog-content &#x27; +
					&#x27;ui-widget-content&#x27;)
				.appendTo(uiDialog),

			uiDialogTitlebar = (self.uiDialogTitlebar = $(&#x27;&lt;div&gt;&lt;&#x2F;div&gt;&#x27;))
				.addClass(
					&#x27;ui-dialog-titlebar &#x27; +
					&#x27;ui-widget-header &#x27; +
					&#x27;ui-corner-all &#x27; +
					&#x27;ui-helper-clearfix&#x27;
				)
				.prependTo(uiDialog),

			uiDialogTitlebarClose = $(&#x27;&lt;a href=&quot;#&quot;&gt;&lt;&#x2F;a&gt;&#x27;)
				.addClass(
					&#x27;ui-dialog-titlebar-close &#x27; +
					&#x27;ui-corner-all&#x27;
				)
				.attr(&#x27;role&#x27;, &#x27;button&#x27;)
				.hover(
					function() {
						uiDialogTitlebarClose.addClass(&#x27;ui-state-hover&#x27;);
					},
					function() {
						uiDialogTitlebarClose.removeClass(&#x27;ui-state-hover&#x27;);
					}
				)
				.focus(function() {
					uiDialogTitlebarClose.addClass(&#x27;ui-state-focus&#x27;);
				})
				.blur(function() {
					uiDialogTitlebarClose.removeClass(&#x27;ui-state-focus&#x27;);
				})
				.click(function(event) {
					self.close(event);
					return false;
				})
				.appendTo(uiDialogTitlebar),

			uiDialogTitlebarCloseText = (self.uiDialogTitlebarCloseText = $(&#x27;&lt;span&gt;&lt;&#x2F;span&gt;&#x27;))
				.addClass(
					&#x27;ui-icon &#x27; +
					&#x27;ui-icon-closethick&#x27;
				)
				.text(options.closeText)
				.appendTo(uiDialogTitlebarClose),

			uiDialogTitle = $(&#x27;&lt;span&gt;&lt;&#x2F;span&gt;&#x27;)
				.addClass(&#x27;ui-dialog-title&#x27;)
				.attr(&#x27;id&#x27;, titleId)
				.html(title)
				.prependTo(uiDialogTitlebar);

		&#x2F;&#x2F;handling of deprecated beforeclose (vs beforeClose) option
		&#x2F;&#x2F;Ticket #4669 http:&#x2F;&#x2F;dev.jqueryui.com&#x2F;ticket&#x2F;4669
		&#x2F;&#x2F;TODO: remove in 1.9pre
		if ($.isFunction(options.beforeclose) &amp;&amp; !$.isFunction(options.beforeClose)) {
			options.beforeClose = options.beforeclose;
		}

		uiDialogTitlebar.find(&quot;*&quot;).add(uiDialogTitlebar).disableSelection();

		if (options.draggable &amp;&amp; $.fn.draggable) {
			self._makeDraggable();
		}
		if (options.resizable &amp;&amp; $.fn.resizable) {
			self._makeResizable();
		}

		self._createButtons(options.buttons);
		self._isOpen = false;

		if ($.fn.bgiframe) {
			uiDialog.bgiframe();
		}
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	destroy: function() {
		var self = this;
		
		if (self.overlay) {
			self.overlay.destroy();
		}
		self.uiDialog.hide();
		self.element
			.unbind(&#x27;.dialog&#x27;)
			.removeData(&#x27;dialog&#x27;)
			.removeClass(&#x27;ui-dialog-content ui-widget-content&#x27;)
			.hide().appendTo(&#x27;body&#x27;);
		self.uiDialog.remove();

		if (self.originalTitle) {
			self.element.attr(&#x27;title&#x27;, self.originalTitle);
		}

		return self;
	},

	widget: function() {
		return this.uiDialog;
	},

	close: function(event) {
		var self = this,
			maxZ, thisZ;
		
		if (false === self._trigger(&#x27;beforeClose&#x27;, event)) {
			return;
		}

		if (self.overlay) {
			self.overlay.destroy();
		}
		self.uiDialog.unbind(&#x27;keypress.ui-dialog&#x27;);

		self._isOpen = false;

		if (self.options.hide) {
			self.uiDialog.hide(self.options.hide, function() {
				self._trigger(&#x27;close&#x27;, event);
			});
		} else {
			self.uiDialog.hide();
			self._trigger(&#x27;close&#x27;, event);
		}

		$.ui.dialog.overlay.resize();

		&#x2F;&#x2F; adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		if (self.options.modal) {
			maxZ = 0;
			$(&#x27;.ui-dialog&#x27;).each(function() {
				if (this !== self.uiDialog[0]) {
					thisZ = $(this).css(&#x27;z-index&#x27;);
					if(!isNaN(thisZ)) {
						maxZ = Math.max(maxZ, thisZ);
					}
				}
			});
			$.ui.dialog.maxZ = maxZ;
		}

		return self;
	},

	isOpen: function() {
		return this._isOpen;
	},

	&#x2F;&#x2F; the force parameter allows us to move modal dialogs to their correct
	&#x2F;&#x2F; position on open
	moveToTop: function(force, event) {
		var self = this,
			options = self.options,
			saveScroll;

		if ((options.modal &amp;&amp; !force) ||
			(!options.stack &amp;&amp; !options.modal)) {
			return self._trigger(&#x27;focus&#x27;, event);
		}

		if (options.zIndex &gt; $.ui.dialog.maxZ) {
			$.ui.dialog.maxZ = options.zIndex;
		}
		if (self.overlay) {
			$.ui.dialog.maxZ += 1;
			self.overlay.$el.css(&#x27;z-index&#x27;, $.ui.dialog.overlay.maxZ = $.ui.dialog.maxZ);
		}

		&#x2F;&#x2F;Save and then restore scroll since Opera 9.5+ resets when parent z-Index is changed.
		&#x2F;&#x2F;  http:&#x2F;&#x2F;ui.jquery.com&#x2F;bugs&#x2F;ticket&#x2F;3193
		saveScroll = { scrollTop: self.element.scrollTop(), scrollLeft: self.element.scrollLeft() };
		$.ui.dialog.maxZ += 1;
		self.uiDialog.css(&#x27;z-index&#x27;, $.ui.dialog.maxZ);
		self.element.attr(saveScroll);
		self._trigger(&#x27;focus&#x27;, event);

		return self;
	},

	open: function() {
		if (this._isOpen) { return; }

		var self = this,
			options = self.options,
			uiDialog = self.uiDialog;

		self.overlay = options.modal ? new $.ui.dialog.overlay(self) : null;
		self._size();
		self._position(options.position);
		uiDialog.show(options.show);
		self.moveToTop(true);

		&#x2F;&#x2F; prevent tabbing out of modal dialogs
		if ( options.modal ) {
			uiDialog.bind( &quot;keydown.ui-dialog&quot;, function( event ) {
				if ( event.keyCode !== $.ui.keyCode.TAB ) {
					return;
				}

				var tabbables = $(&#x27;:tabbable&#x27;, this),
					first = tabbables.filter(&#x27;:first&#x27;),
					last  = tabbables.filter(&#x27;:last&#x27;);

				if (event.target === last[0] &amp;&amp; !event.shiftKey) {
					first.focus(1);
					return false;
				} else if (event.target === first[0] &amp;&amp; event.shiftKey) {
					last.focus(1);
					return false;
				}
			});
		}

		&#x2F;&#x2F; set focus to the first tabbable element in the content area or the first button
		&#x2F;&#x2F; if there are no tabbable elements, set focus on the dialog itself
		$(self.element.find(&#x27;:tabbable&#x27;).get().concat(
			uiDialog.find(&#x27;.ui-dialog-buttonpane :tabbable&#x27;).get().concat(
				uiDialog.get()))).eq(0).focus();

		self._isOpen = true;
		self._trigger(&#x27;open&#x27;);

		return self;
	},

	_createButtons: function(buttons) {
		var self = this,
			hasButtons = false,
			uiDialogButtonPane = $(&#x27;&lt;div&gt;&lt;&#x2F;div&gt;&#x27;)
				.addClass(
					&#x27;ui-dialog-buttonpane &#x27; +
					&#x27;ui-widget-content &#x27; +
					&#x27;ui-helper-clearfix&#x27;
				),
			uiButtonSet = $( &quot;&lt;div&gt;&lt;&#x2F;div&gt;&quot; )
				.addClass( &quot;ui-dialog-buttonset&quot; )
				.appendTo( uiDialogButtonPane );

		&#x2F;&#x2F; if we already have a button pane, remove it
		self.uiDialog.find(&#x27;.ui-dialog-buttonpane&#x27;).remove();

		if (typeof buttons === &#x27;object&#x27; &amp;&amp; buttons !== null) {
			$.each(buttons, function() {
				return !(hasButtons = true);
			});
		}
		if (hasButtons) {
			$.each(buttons, function(name, props) {
				props = $.isFunction( props ) ?
					{ click: props, text: name } :
					props;
				var button = $(&#x27;&lt;button type=&quot;button&quot;&gt;&lt;&#x2F;button&gt;&#x27;)
					.click(function() {
						props.click.apply(self.element[0], arguments);
					})
					.appendTo(uiButtonSet);
				&#x2F;&#x2F; can&#x27;t use .attr( props, true ) with jQuery 1.3.2.
				$.each( props, function( key, value ) {
					if ( key === &quot;click&quot; ) {
						return;
					}
					if ( key in button ) {
						button[ key ]( value );
					} else {
						button.attr( key, value );
					}
				});
				if ($.fn.button) {
					button.button();
				}
			});
			uiDialogButtonPane.appendTo(self.uiDialog);
		}
	},

	_makeDraggable: function() {
		var self = this,
			options = self.options,
			doc = $(document),
			heightBeforeDrag;

		function filteredUi(ui) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		self.uiDialog.draggable({
			cancel: &#x27;.ui-dialog-content, .ui-dialog-titlebar-close&#x27;,
			handle: &#x27;.ui-dialog-titlebar&#x27;,
			containment: &#x27;document&#x27;,
			start: function(event, ui) {
				heightBeforeDrag = options.height === &quot;auto&quot; ? &quot;auto&quot; : $(this).height();
				$(this).height($(this).height()).addClass(&quot;ui-dialog-dragging&quot;);
				self._trigger(&#x27;dragStart&#x27;, event, filteredUi(ui));
			},
			drag: function(event, ui) {
				self._trigger(&#x27;drag&#x27;, event, filteredUi(ui));
			},
			stop: function(event, ui) {
				options.position = [ui.position.left - doc.scrollLeft(),
					ui.position.top - doc.scrollTop()];
				$(this).removeClass(&quot;ui-dialog-dragging&quot;).height(heightBeforeDrag);
				self._trigger(&#x27;dragStop&#x27;, event, filteredUi(ui));
				$.ui.dialog.overlay.resize();
			}
		});
	},

	_makeResizable: function(handles) {
		handles = (handles === undefined ? this.options.resizable : handles);
		var self = this,
			options = self.options,
			&#x2F;&#x2F; .ui-resizable has position: relative defined in the stylesheet
			&#x2F;&#x2F; but dialogs have to use absolute or fixed positioning
			position = self.uiDialog.css(&#x27;position&#x27;),
			resizeHandles = (typeof handles === &#x27;string&#x27; ?
				handles	:
				&#x27;n,e,s,w,se,sw,ne,nw&#x27;
			);

		function filteredUi(ui) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		self.uiDialog.resizable({
			cancel: &#x27;.ui-dialog-content&#x27;,
			containment: &#x27;document&#x27;,
			alsoResize: self.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: self._minHeight(),
			handles: resizeHandles,
			start: function(event, ui) {
				$(this).addClass(&quot;ui-dialog-resizing&quot;);
				self._trigger(&#x27;resizeStart&#x27;, event, filteredUi(ui));
			},
			resize: function(event, ui) {
				self._trigger(&#x27;resize&#x27;, event, filteredUi(ui));
			},
			stop: function(event, ui) {
				$(this).removeClass(&quot;ui-dialog-resizing&quot;);
				options.height = $(this).height();
				options.width = $(this).width();
				self._trigger(&#x27;resizeStop&#x27;, event, filteredUi(ui));
				$.ui.dialog.overlay.resize();
			}
		})
		.css(&#x27;position&#x27;, position)
		.find(&#x27;.ui-resizable-se&#x27;).addClass(&#x27;ui-icon ui-icon-grip-diagonal-se&#x27;);
	},

	_minHeight: function() {
		var options = this.options;

		if (options.height === &#x27;auto&#x27;) {
			return options.minHeight;
		} else {
			return Math.min(options.minHeight, options.height);
		}
	},

	_position: function(position) {
		var myAt = [],
			offset = [0, 0],
			isVisible;

		if (position) {
			&#x2F;&#x2F; deep extending converts arrays to objects in jQuery &lt;= 1.3.2 :-(
	&#x2F;&#x2F;		if (typeof position == &#x27;string&#x27; || $.isArray(position)) {
	&#x2F;&#x2F;			myAt = $.isArray(position) ? position : position.split(&#x27; &#x27;);

			if (typeof position === &#x27;string&#x27; || (typeof position === &#x27;object&#x27; &amp;&amp; &#x27;0&#x27; in position)) {
				myAt = position.split ? position.split(&#x27; &#x27;) : [position[0], position[1]];
				if (myAt.length === 1) {
					myAt[1] = myAt[0];
				}

				$.each([&#x27;left&#x27;, &#x27;top&#x27;], function(i, offsetPosition) {
					if (+myAt[i] === myAt[i]) {
						offset[i] = myAt[i];
						myAt[i] = offsetPosition;
					}
				});

				position = {
					my: myAt.join(&quot; &quot;),
					at: myAt.join(&quot; &quot;),
					offset: offset.join(&quot; &quot;)
				};
			} 

			position = $.extend({}, $.ui.dialog.prototype.options.position, position);
		} else {
			position = $.ui.dialog.prototype.options.position;
		}

		&#x2F;&#x2F; need to show the dialog to get the actual offset in the position plugin
		isVisible = this.uiDialog.is(&#x27;:visible&#x27;);
		if (!isVisible) {
			this.uiDialog.show();
		}
		this.uiDialog
			&#x2F;&#x2F; workaround for jQuery bug #5781 http:&#x2F;&#x2F;dev.jquery.com&#x2F;ticket&#x2F;5781
			.css({ top: 0, left: 0 })
			.position($.extend({ of: window }, position));
		if (!isVisible) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var self = this,
			resizableOptions = {},
			resize = false;

		$.each( options, function( key, value ) {
			self._setOption( key, value );
			
			if ( key in sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
		}
		if ( this.uiDialog.is( &quot;:data(resizable)&quot; ) ) {
			this.uiDialog.resizable( &quot;option&quot;, resizableOptions );
		}
	},

	_setOption: function(key, value){
		var self = this,
			uiDialog = self.uiDialog;

		switch (key) {
			&#x2F;&#x2F;handling of deprecated beforeclose (vs beforeClose) option
			&#x2F;&#x2F;Ticket #4669 http:&#x2F;&#x2F;dev.jqueryui.com&#x2F;ticket&#x2F;4669
			&#x2F;&#x2F;TODO: remove in 1.9pre
			case &quot;beforeclose&quot;:
				key = &quot;beforeClose&quot;;
				break;
			case &quot;buttons&quot;:
				self._createButtons(value);
				break;
			case &quot;closeText&quot;:
				&#x2F;&#x2F; ensure that we always pass a string
				self.uiDialogTitlebarCloseText.text(&quot;&quot; + value);
				break;
			case &quot;dialogClass&quot;:
				uiDialog
					.removeClass(self.options.dialogClass)
					.addClass(uiDialogClasses + value);
				break;
			case &quot;disabled&quot;:
				if (value) {
					uiDialog.addClass(&#x27;ui-dialog-disabled&#x27;);
				} else {
					uiDialog.removeClass(&#x27;ui-dialog-disabled&#x27;);
				}
				break;
			case &quot;draggable&quot;:
				var isDraggable = uiDialog.is( &quot;:data(draggable)&quot; );
				if ( isDraggable &amp;&amp; !value ) {
					uiDialog.draggable( &quot;destroy&quot; );
				}
				
				if ( !isDraggable &amp;&amp; value ) {
					self._makeDraggable();
				}
				break;
			case &quot;position&quot;:
				self._position(value);
				break;
			case &quot;resizable&quot;:
				&#x2F;&#x2F; currently resizable, becoming non-resizable
				var isResizable = uiDialog.is( &quot;:data(resizable)&quot; );
				if (isResizable &amp;&amp; !value) {
					uiDialog.resizable(&#x27;destroy&#x27;);
				}

				&#x2F;&#x2F; currently resizable, changing handles
				if (isResizable &amp;&amp; typeof value === &#x27;string&#x27;) {
					uiDialog.resizable(&#x27;option&#x27;, &#x27;handles&#x27;, value);
				}

				&#x2F;&#x2F; currently non-resizable, becoming resizable
				if (!isResizable &amp;&amp; value !== false) {
					self._makeResizable(value);
				}
				break;
			case &quot;title&quot;:
				&#x2F;&#x2F; convert whatever was passed in o a string, for html() to not throw up
				$(&quot;.ui-dialog-title&quot;, self.uiDialogTitlebar).html(&quot;&quot; + (value || &#x27;&amp;#160;&#x27;));
				break;
		}

		$.Widget.prototype._setOption.apply(self, arguments);
	},

	_size: function() {
		&#x2F;* If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		 * divs will both have width and height set, so we need to reset them
		 *&#x2F;
		var options = this.options,
			nonContentHeight,
			minContentHeight,
			isVisible = this.uiDialog.is( &quot;:visible&quot; );

		&#x2F;&#x2F; reset content sizing
		this.element.show().css({
			width: &#x27;auto&#x27;,
			minHeight: 0,
			height: 0
		});

		if (options.minWidth &gt; options.width) {
			options.width = options.minWidth;
		}

		&#x2F;&#x2F; reset wrapper sizing
		&#x2F;&#x2F; determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: &#x27;auto&#x27;,
				width: options.width
			})
			.height();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
		
		if ( options.height === &quot;auto&quot; ) {
			&#x2F;&#x2F; only needed for IE6 support
			if ( $.support.minHeight ) {
				this.element.css({
					minHeight: minContentHeight,
					height: &quot;auto&quot;
				});
			} else {
				this.uiDialog.show();
				var autoHeight = this.element.css( &quot;height&quot;, &quot;auto&quot; ).height();
				if ( !isVisible ) {
					this.uiDialog.hide();
				}
				this.element.height( Math.max( autoHeight, minContentHeight ) );
			}
		} else {
			this.element.height( Math.max( options.height - nonContentHeight, 0 ) );
		}

		if (this.uiDialog.is(&#x27;:data(resizable)&#x27;)) {
			this.uiDialog.resizable(&#x27;option&#x27;, &#x27;minHeight&#x27;, this._minHeight());
		}
	}
});

$.extend($.ui.dialog, {
	version: &quot;1.8.23&quot;,

	uuid: 0,
	maxZ: 0,

	getTitleId: function($el) {
		var id = $el.attr(&#x27;id&#x27;);
		if (!id) {
			this.uuid += 1;
			id = this.uuid;
		}
		return &#x27;ui-dialog-title-&#x27; + id;
	},

	overlay: function(dialog) {
		this.$el = $.ui.dialog.overlay.create(dialog);
	}
});

$.extend($.ui.dialog.overlay, {
	instances: [],
	&#x2F;&#x2F; reuse old instances due to IE memory leak with alpha transparency (see #5185)
	oldInstances: [],
	maxZ: 0,
	events: $.map(&#x27;focus,mousedown,mouseup,keydown,keypress,click&#x27;.split(&#x27;,&#x27;),
		function(event) { return event + &#x27;.dialog-overlay&#x27;; }).join(&#x27; &#x27;),
	create: function(dialog) {
		if (this.instances.length === 0) {
			&#x2F;&#x2F; prevent use of anchors and inputs
			&#x2F;&#x2F; we use a setTimeout in case the overlay is created from an
			&#x2F;&#x2F; event that we&#x27;re going to be cancelling (see #2804)
			setTimeout(function() {
				&#x2F;&#x2F; handle $(el).dialog().dialog(&#x27;close&#x27;) (see #4065)
				if ($.ui.dialog.overlay.instances.length) {
					$(document).bind($.ui.dialog.overlay.events, function(event) {
						&#x2F;&#x2F; stop events if the z-index of the target is &lt; the z-index of the overlay
						&#x2F;&#x2F; we cannot return true when we don&#x27;t want to cancel the event (#3523)
						if ($(event.target).zIndex() &lt; $.ui.dialog.overlay.maxZ) {
							return false;
						}
					});
				}
			}, 1);

			&#x2F;&#x2F; allow closing by pressing the escape key
			$(document).bind(&#x27;keydown.dialog-overlay&#x27;, function(event) {
				if (dialog.options.closeOnEscape &amp;&amp; !event.isDefaultPrevented() &amp;&amp; event.keyCode &amp;&amp;
					event.keyCode === $.ui.keyCode.ESCAPE) {
					
					dialog.close(event);
					event.preventDefault();
				}
			});

			&#x2F;&#x2F; handle window resize
			$(window).bind(&#x27;resize.dialog-overlay&#x27;, $.ui.dialog.overlay.resize);
		}

		var $el = (this.oldInstances.pop() || $(&#x27;&lt;div&gt;&lt;&#x2F;div&gt;&#x27;).addClass(&#x27;ui-widget-overlay&#x27;))
			.appendTo(document.body)
			.css({
				width: this.width(),
				height: this.height()
			});

		if ($.fn.bgiframe) {
			$el.bgiframe();
		}

		this.instances.push($el);
		return $el;
	},

	destroy: function($el) {
		var indexOf = $.inArray($el, this.instances);
		if (indexOf != -1){
			this.oldInstances.push(this.instances.splice(indexOf, 1)[0]);
		}

		if (this.instances.length === 0) {
			$([document, window]).unbind(&#x27;.dialog-overlay&#x27;);
		}

		$el.remove();
		
		&#x2F;&#x2F; adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		var maxZ = 0;
		$.each(this.instances, function() {
			maxZ = Math.max(maxZ, this.css(&#x27;z-index&#x27;));
		});
		this.maxZ = maxZ;
	},

	height: function() {
		var scrollHeight,
			offsetHeight;
		&#x2F;&#x2F; handle IE 6
		if ($.browser.msie &amp;&amp; $.browser.version &lt; 7) {
			scrollHeight = Math.max(
				document.documentElement.scrollHeight,
				document.body.scrollHeight
			);
			offsetHeight = Math.max(
				document.documentElement.offsetHeight,
				document.body.offsetHeight
			);

			if (scrollHeight &lt; offsetHeight) {
				return $(window).height() + &#x27;px&#x27;;
			} else {
				return scrollHeight + &#x27;px&#x27;;
			}
		&#x2F;&#x2F; handle &quot;good&quot; browsers
		} else {
			return $(document).height() + &#x27;px&#x27;;
		}
	},

	width: function() {
		var scrollWidth,
			offsetWidth;
		&#x2F;&#x2F; handle IE
		if ( $.browser.msie ) {
			scrollWidth = Math.max(
				document.documentElement.scrollWidth,
				document.body.scrollWidth
			);
			offsetWidth = Math.max(
				document.documentElement.offsetWidth,
				document.body.offsetWidth
			);

			if (scrollWidth &lt; offsetWidth) {
				return $(window).width() + &#x27;px&#x27;;
			} else {
				return scrollWidth + &#x27;px&#x27;;
			}
		&#x2F;&#x2F; handle &quot;good&quot; browsers
		} else {
			return $(document).width() + &#x27;px&#x27;;
		}
	},

	resize: function() {
		&#x2F;* If the dialog is draggable and the user drags it past the
		 * right edge of the window, the document becomes wider so we
		 * need to stretch the overlay. If the user then drags the
		 * dialog back to the left, the document will become narrower,
		 * so we need to shrink the overlay to the appropriate size.
		 * This is handled by shrinking the overlay before setting it
		 * to the full document size.
		 *&#x2F;
		var $overlays = $([]);
		$.each($.ui.dialog.overlay.instances, function() {
			$overlays = $overlays.add(this);
		});

		$overlays.css({
			width: 0,
			height: 0
		}).css({
			width: $.ui.dialog.overlay.width(),
			height: $.ui.dialog.overlay.height()
		});
	}
});

$.extend($.ui.dialog.overlay.prototype, {
	destroy: function() {
		$.ui.dialog.overlay.destroy(this.$el);
	}
});

}(jQuery));

(function( $, undefined ) {

$.ui = $.ui || {};

var horizontalPositions = &#x2F;left|center|right&#x2F;,
	verticalPositions = &#x2F;top|center|bottom&#x2F;,
	center = &quot;center&quot;,
	support = {},
	_position = $.fn.position,
	_offset = $.fn.offset;

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	&#x2F;&#x2F; make a copy, we don&#x27;t want to modify arguments
	options = $.extend( {}, options );

	var target = $( options.of ),
		targetElem = target[0],
		collision = ( options.collision || &quot;flip&quot; ).split( &quot; &quot; ),
		offset = options.offset ? options.offset.split( &quot; &quot; ) : [ 0, 0 ],
		targetWidth,
		targetHeight,
		basePosition;

	if ( targetElem.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: 0, left: 0 };
	&#x2F;&#x2F; TODO: use $.isWindow() in 1.9
	} else if ( targetElem.setTimeout ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( targetElem.preventDefault ) {
		&#x2F;&#x2F; force left top to allow flipping
		options.at = &quot;left top&quot;;
		targetWidth = targetHeight = 0;
		basePosition = { top: options.of.pageY, left: options.of.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		basePosition = target.offset();
	}

	&#x2F;&#x2F; force my and at to have valid horizontal and veritcal positions
	&#x2F;&#x2F; if a value is missing or invalid, it will be converted to center 
	$.each( [ &quot;my&quot;, &quot;at&quot; ], function() {
		var pos = ( options[this] || &quot;&quot; ).split( &quot; &quot; );
		if ( pos.length === 1) {
			pos = horizontalPositions.test( pos[0] ) ?
				pos.concat( [center] ) :
				verticalPositions.test( pos[0] ) ?
					[ center ].concat( pos ) :
					[ center, center ];
		}
		pos[ 0 ] = horizontalPositions.test( pos[0] ) ? pos[ 0 ] : center;
		pos[ 1 ] = verticalPositions.test( pos[1] ) ? pos[ 1 ] : center;
		options[ this ] = pos;
	});

	&#x2F;&#x2F; normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	&#x2F;&#x2F; normalize offset option
	offset[ 0 ] = parseInt( offset[0], 10 ) || 0;
	if ( offset.length === 1 ) {
		offset[ 1 ] = offset[ 0 ];
	}
	offset[ 1 ] = parseInt( offset[1], 10 ) || 0;

	if ( options.at[0] === &quot;right&quot; ) {
		basePosition.left += targetWidth;
	} else if ( options.at[0] === center ) {
		basePosition.left += targetWidth &#x2F; 2;
	}

	if ( options.at[1] === &quot;bottom&quot; ) {
		basePosition.top += targetHeight;
	} else if ( options.at[1] === center ) {
		basePosition.top += targetHeight &#x2F; 2;
	}

	basePosition.left += offset[ 0 ];
	basePosition.top += offset[ 1 ];

	return this.each(function() {
		var elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseInt( $.curCSS( this, &quot;marginLeft&quot;, true ) ) || 0,
			marginTop = parseInt( $.curCSS( this, &quot;marginTop&quot;, true ) ) || 0,
			collisionWidth = elemWidth + marginLeft +
				( parseInt( $.curCSS( this, &quot;marginRight&quot;, true ) ) || 0 ),
			collisionHeight = elemHeight + marginTop +
				( parseInt( $.curCSS( this, &quot;marginBottom&quot;, true ) ) || 0 ),
			position = $.extend( {}, basePosition ),
			collisionPosition;

		if ( options.my[0] === &quot;right&quot; ) {
			position.left -= elemWidth;
		} else if ( options.my[0] === center ) {
			position.left -= elemWidth &#x2F; 2;
		}

		if ( options.my[1] === &quot;bottom&quot; ) {
			position.top -= elemHeight;
		} else if ( options.my[1] === center ) {
			position.top -= elemHeight &#x2F; 2;
		}

		&#x2F;&#x2F; prevent fractions if jQuery version doesn&#x27;t support them (see #5280)
		if ( !support.fractions ) {
			position.left = Math.round( position.left );
			position.top = Math.round( position.top );
		}

		collisionPosition = {
			left: position.left - marginLeft,
			top: position.top - marginTop
		};

		$.each( [ &quot;left&quot;, &quot;top&quot; ], function( i, dir ) {
			if ( $.ui.position[ collision[i] ] ) {
				$.ui.position[ collision[i] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: offset,
					my: options.my,
					at: options.at
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}
		elem.offset( $.extend( position, { using: options.using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft();
			position.left = over &gt; 0 ? position.left - over : Math.max( position.left - data.collisionPosition.left, position.left );
		},
		top: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop();
			position.top = over &gt; 0 ? position.top - over : Math.max( position.top - data.collisionPosition.top, position.top );
		}
	},

	flip: {
		left: function( position, data ) {
			if ( data.at[0] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft(),
				myOffset = data.my[ 0 ] === &quot;left&quot; ?
					-data.elemWidth :
					data.my[ 0 ] === &quot;right&quot; ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === &quot;left&quot; ?
					data.targetWidth :
					-data.targetWidth,
				offset = -2 * data.offset[ 0 ];
			position.left += data.collisionPosition.left &lt; 0 ?
				myOffset + atOffset + offset :
				over &gt; 0 ?
					myOffset + atOffset + offset :
					0;
		},
		top: function( position, data ) {
			if ( data.at[1] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop(),
				myOffset = data.my[ 1 ] === &quot;top&quot; ?
					-data.elemHeight :
					data.my[ 1 ] === &quot;bottom&quot; ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === &quot;top&quot; ?
					data.targetHeight :
					-data.targetHeight,
				offset = -2 * data.offset[ 1 ];
			position.top += data.collisionPosition.top &lt; 0 ?
				myOffset + atOffset + offset :
				over &gt; 0 ?
					myOffset + atOffset + offset :
					0;
		}
	}
};

&#x2F;&#x2F; offset setter from jQuery 1.4
if ( !$.offset.setOffset ) {
	$.offset.setOffset = function( elem, options ) {
		&#x2F;&#x2F; set position first, in-case top&#x2F;left are set even on static elem
		if ( &#x2F;static&#x2F;.test( $.curCSS( elem, &quot;position&quot; ) ) ) {
			elem.style.position = &quot;relative&quot;;
		}
		var curElem   = $( elem ),
			curOffset = curElem.offset(),
			curTop    = parseInt( $.curCSS( elem, &quot;top&quot;,  true ), 10 ) || 0,
			curLeft   = parseInt( $.curCSS( elem, &quot;left&quot;, true ), 10)  || 0,
			props     = {
				top:  (options.top  - curOffset.top)  + curTop,
				left: (options.left - curOffset.left) + curLeft
			};
		
		if ( &#x27;using&#x27; in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	};

	$.fn.offset = function( options ) {
		var elem = this[ 0 ];
		if ( !elem || !elem.ownerDocument ) { return null; }
		if ( options ) {
			if ( $.isFunction( options ) ) {
				return this.each(function( i ) {
					$( this ).offset( options.call( this, i, $( this ).offset() ) );
				});
			}
			return this.each(function() {
				$.offset.setOffset( this, options );
			});
		}
		return _offset.call( this );
	};
}

&#x2F;&#x2F; jQuery &lt;1.4.3 uses curCSS, in 1.4.3 - 1.7.2 curCSS = css, 1.8+ only has css
if ( !$.curCSS ) {
	$.curCSS = $.css;
}

&#x2F;&#x2F; fraction support test (older versions of jQuery don&#x27;t support fractions)
(function () {
	var body = document.getElementsByTagName( &quot;body&quot; )[ 0 ], 
		div = document.createElement( &quot;div&quot; ),
		testElement, testElementParent, testElementStyle, offset, offsetTotal;

	&#x2F;&#x2F;Create a &quot;fake body&quot; for testing based on method used in jQuery.support
	testElement = document.createElement( body ? &quot;div&quot; : &quot;body&quot; );
	testElementStyle = {
		visibility: &quot;hidden&quot;,
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: &quot;none&quot;
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: &quot;absolute&quot;,
			left: &quot;-1000px&quot;,
			top: &quot;-1000px&quot;
		});
	}
	for ( var i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = &quot;position: absolute; left: 10.7432222px; top: 10.432325px; height: 30px; width: 201px;&quot;;

	offset = $( div ).offset( function( _, offset ) {
		return offset;
	}).offset();

	testElement.innerHTML = &quot;&quot;;
	testElementParent.removeChild( testElement );

	offsetTotal = offset.top + offset.left + ( body ? 2000 : 0 );
	support.fractions = offsetTotal &gt; 21 &amp;&amp; offsetTotal &lt; 22;
})();

}( jQuery ));

(function( $, undefined ) {

$.widget( &quot;ui.progressbar&quot;, {
	options: {
		value: 0,
		max: 100
	},

	min: 0,

	_create: function() {
		this.element
			.addClass( &quot;ui-progressbar ui-widget ui-widget-content ui-corner-all&quot; )
			.attr({
				role: &quot;progressbar&quot;,
				&quot;aria-valuemin&quot;: this.min,
				&quot;aria-valuemax&quot;: this.options.max,
				&quot;aria-valuenow&quot;: this._value()
			});

		this.valueDiv = $( &quot;&lt;div class=&#x27;ui-progressbar-value ui-widget-header ui-corner-left&#x27;&gt;&lt;&#x2F;div&gt;&quot; )
			.appendTo( this.element );

		this.oldValue = this._value();
		this._refreshValue();
	},

	destroy: function() {
		this.element
			.removeClass( &quot;ui-progressbar ui-widget ui-widget-content ui-corner-all&quot; )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-valuemin&quot; )
			.removeAttr( &quot;aria-valuemax&quot; )
			.removeAttr( &quot;aria-valuenow&quot; );

		this.valueDiv.remove();

		$.Widget.prototype.destroy.apply( this, arguments );
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this._value();
		}

		this._setOption( &quot;value&quot;, newValue );
		return this;
	},

	_setOption: function( key, value ) {
		if ( key === &quot;value&quot; ) {
			this.options.value = value;
			this._refreshValue();
			if ( this._value() === this.options.max ) {
				this._trigger( &quot;complete&quot; );
			}
		}

		$.Widget.prototype._setOption.apply( this, arguments );
	},

	_value: function() {
		var val = this.options.value;
		&#x2F;&#x2F; normalize invalid value
		if ( typeof val !== &quot;number&quot; ) {
			val = 0;
		}
		return Math.min( this.options.max, Math.max( this.min, val ) );
	},

	_percentage: function() {
		return 100 * this._value() &#x2F; this.options.max;
	},

	_refreshValue: function() {
		var value = this.value();
		var percentage = this._percentage();

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( &quot;change&quot; );
		}

		this.valueDiv
			.toggle( value &gt; this.min )
			.toggleClass( &quot;ui-corner-right&quot;, value === this.options.max )
			.width( percentage.toFixed(0) + &quot;%&quot; );
		this.element.attr( &quot;aria-valuenow&quot;, value );
	}
});

$.extend( $.ui.progressbar, {
	version: &quot;1.8.23&quot;
});

})( jQuery );

(function( $, undefined ) {

&#x2F;&#x2F; number of pages in a slider
&#x2F;&#x2F; (how many times can you page up&#x2F;down to go through the whole range)
var numPages = 5;

$.widget( &quot;ui.slider&quot;, $.ui.mouse, {

	widgetEventPrefix: &quot;slide&quot;,

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: &quot;horizontal&quot;,
		range: false,
		step: 1,
		value: 0,
		values: null
	},

	_create: function() {
		var self = this,
			o = this.options,
			existingHandles = this.element.find( &quot;.ui-slider-handle&quot; ).addClass( &quot;ui-state-default ui-corner-all&quot; ),
			handle = &quot;&lt;a class=&#x27;ui-slider-handle ui-state-default ui-corner-all&#x27; href=&#x27;#&#x27;&gt;&lt;&#x2F;a&gt;&quot;,
			handleCount = ( o.values &amp;&amp; o.values.length ) || 1,
			handles = [];

		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( &quot;ui-slider&quot; +
				&quot; ui-slider-&quot; + this.orientation +
				&quot; ui-widget&quot; +
				&quot; ui-widget-content&quot; +
				&quot; ui-corner-all&quot; +
				( o.disabled ? &quot; ui-slider-disabled ui-disabled&quot; : &quot;&quot; ) );

		this.range = $([]);

		if ( o.range ) {
			if ( o.range === true ) {
				if ( !o.values ) {
					o.values = [ this._valueMin(), this._valueMin() ];
				}
				if ( o.values.length &amp;&amp; o.values.length !== 2 ) {
					o.values = [ o.values[0], o.values[0] ];
				}
			}

			this.range = $( &quot;&lt;div&gt;&lt;&#x2F;div&gt;&quot; )
				.appendTo( this.element )
				.addClass( &quot;ui-slider-range&quot; +
				&#x2F;&#x2F; note: this isn&#x27;t the most fittingly semantic framework class for this element,
				&#x2F;&#x2F; but worked best visually with a variety of themes
				&quot; ui-widget-header&quot; + 
				( ( o.range === &quot;min&quot; || o.range === &quot;max&quot; ) ? &quot; ui-slider-range-&quot; + o.range : &quot;&quot; ) );
		}

		for ( var i = existingHandles.length; i &lt; handleCount; i += 1 ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( &quot;&quot; ) ).appendTo( self.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.add( this.range ).filter( &quot;a&quot; )
			.click(function( event ) {
				event.preventDefault();
			})
			.hover(function() {
				if ( !o.disabled ) {
					$( this ).addClass( &quot;ui-state-hover&quot; );
				}
			}, function() {
				$( this ).removeClass( &quot;ui-state-hover&quot; );
			})
			.focus(function() {
				if ( !o.disabled ) {
					$( &quot;.ui-slider .ui-state-focus&quot; ).removeClass( &quot;ui-state-focus&quot; );
					$( this ).addClass( &quot;ui-state-focus&quot; );
				} else {
					$( this ).blur();
				}
			})
			.blur(function() {
				$( this ).removeClass( &quot;ui-state-focus&quot; );
			});

		this.handles.each(function( i ) {
			$( this ).data( &quot;index.ui-slider-handle&quot;, i );
		});

		this.handles
			.keydown(function( event ) {
				var index = $( this ).data( &quot;index.ui-slider-handle&quot; ),
					allowed,
					curVal,
					newVal,
					step;
	
				if ( self.options.disabled ) {
					return;
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						event.preventDefault();
						if ( !self._keySliding ) {
							self._keySliding = true;
							$( this ).addClass( &quot;ui-state-active&quot; );
							allowed = self._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}
	
				step = self.options.step;
				if ( self.options.values &amp;&amp; self.options.values.length ) {
					curVal = newVal = self.values( index );
				} else {
					curVal = newVal = self.value();
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = self._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = self._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = self._trimAlignValue( curVal + ( (self._valueMax() - self._valueMin()) &#x2F; numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = self._trimAlignValue( curVal - ( (self._valueMax() - self._valueMin()) &#x2F; numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === self._valueMax() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === self._valueMin() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal - step );
						break;
				}
	
				self._slide( event, index, newVal );
			})
			.keyup(function( event ) {
				var index = $( this ).data( &quot;index.ui-slider-handle&quot; );
	
				if ( self._keySliding ) {
					self._keySliding = false;
					self._stop( event, index );
					self._change( event, index );
					$( this ).removeClass( &quot;ui-state-active&quot; );
				}
	
			});

		this._refreshValue();

		this._animateOff = false;
	},

	destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( &quot;ui-slider&quot; +
				&quot; ui-slider-horizontal&quot; +
				&quot; ui-slider-vertical&quot; +
				&quot; ui-slider-disabled&quot; +
				&quot; ui-widget&quot; +
				&quot; ui-widget-content&quot; +
				&quot; ui-corner-all&quot; )
			.removeData( &quot;slider&quot; )
			.unbind( &quot;.slider&quot; );

		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function( event ) {
		var o = this.options,
			position,
			normValue,
			distance,
			closestHandle,
			self,
			index,
			allowed,
			offset,
			mouseOverHandle;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		self = this;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - self.values(i) );
			if ( distance &gt; thisDistance ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		&#x2F;&#x2F; workaround for bug #3736 (if both handles of a range are at 0,
		&#x2F;&#x2F; the first is always used as the one with least distance,
		&#x2F;&#x2F; and moving it is obviously prevented by preventing negative ranges)
		if( o.range === true &amp;&amp; this.values(1) === o.min ) {
			index += 1;
			closestHandle = $( this.handles[index] );
		}

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		self._handleIndex = index;

		closestHandle
			.addClass( &quot;ui-state-active&quot; )
			.focus();
		
		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().andSelf().is( &quot;.ui-slider-handle&quot; );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() &#x2F; 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() &#x2F; 2 ) -
				( parseInt( closestHandle.css(&quot;borderTopWidth&quot;), 10 ) || 0 ) -
				( parseInt( closestHandle.css(&quot;borderBottomWidth&quot;), 10 ) || 0) +
				( parseInt( closestHandle.css(&quot;marginTop&quot;), 10 ) || 0)
		};

		if ( !this.handles.hasClass( &quot;ui-state-hover&quot; ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function( event ) {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );
		
		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( &quot;ui-state-active&quot; );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},
	
	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === &quot;vertical&quot; ) ? &quot;vertical&quot; : &quot;horizontal&quot;;
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === &quot;horizontal&quot; ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse &#x2F; pixelTotal );
		if ( percentMouse &gt; 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse &lt; 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === &quot;vertical&quot; ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values &amp;&amp; this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( &quot;start&quot;, event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values &amp;&amp; this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 &amp;&amp; this.options.range === true ) &amp;&amp; 
					( ( index === 0 &amp;&amp; newVal &gt; otherVal) || ( index === 1 &amp;&amp; newVal &lt; otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				&#x2F;&#x2F; A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( &quot;slide&quot;, event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				&#x2F;&#x2F; A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( &quot;slide&quot;, event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values &amp;&amp; this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( &quot;stop&quot;, event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding &amp;&amp; !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values &amp;&amp; this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			this._trigger( &quot;change&quot;, event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length &gt; 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i &lt; vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values &amp;&amp; this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case &quot;disabled&quot;:
				if ( value ) {
					this.handles.filter( &quot;.ui-state-focus&quot; ).blur();
					this.handles.removeClass( &quot;ui-state-hover&quot; );
					this.handles.propAttr( &quot;disabled&quot;, true );
					this.element.addClass( &quot;ui-disabled&quot; );
				} else {
					this.handles.propAttr( &quot;disabled&quot;, false );
					this.element.removeClass( &quot;ui-disabled&quot; );
				}
				break;
			case &quot;orientation&quot;:
				this._detectOrientation();
				this.element
					.removeClass( &quot;ui-slider-horizontal ui-slider-vertical&quot; )
					.addClass( &quot;ui-slider-&quot; + this.orientation );
				this._refreshValue();
				break;
			case &quot;value&quot;:
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case &quot;values&quot;:
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i &lt; valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
		}
	},

	&#x2F;&#x2F;internal value getter
	&#x2F;&#x2F; _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	&#x2F;&#x2F;internal values getter
	&#x2F;&#x2F; _values() returns array of values trimmed by min and max, aligned by step
	&#x2F;&#x2F; _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else {
			&#x2F;&#x2F; .slice() creates a copy of the array
			&#x2F;&#x2F; this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i &lt; vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		}
	},
	
	&#x2F;&#x2F; returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val &lt;= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val &gt;= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step &gt; 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 &gt;= step ) {
			alignValue += ( valModStep &gt; 0 ) ? step : ( -step );
		}

		&#x2F;&#x2F; Since JavaScript has problems with large floats, round
		&#x2F;&#x2F; the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},
	
	_refreshValue: function() {
		var oRange = this.options.range,
			o = this.options,
			self = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			valPercent,
			_set = {},
			lastValPercent,
			value,
			valueMin,
			valueMax;

		if ( this.options.values &amp;&amp; this.options.values.length ) {
			this.handles.each(function( i, j ) {
				valPercent = ( self.values(i) - self._valueMin() ) &#x2F; ( self._valueMax() - self._valueMin() ) * 100;
				_set[ self.orientation === &quot;horizontal&quot; ? &quot;left&quot; : &quot;bottom&quot; ] = valPercent + &quot;%&quot;;
				$( this ).stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( _set, o.animate );
				if ( self.options.range === true ) {
					if ( self.orientation === &quot;horizontal&quot; ) {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { left: valPercent + &quot;%&quot; }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { width: ( valPercent - lastValPercent ) + &quot;%&quot; }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { bottom: ( valPercent ) + &quot;%&quot; }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { height: ( valPercent - lastValPercent ) + &quot;%&quot; }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) &#x2F; ( valueMax - valueMin ) * 100 :
					0;
			_set[ self.orientation === &quot;horizontal&quot; ? &quot;left&quot; : &quot;bottom&quot; ] = valPercent + &quot;%&quot;;
			this.handle.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( _set, o.animate );

			if ( oRange === &quot;min&quot; &amp;&amp; this.orientation === &quot;horizontal&quot; ) {
				this.range.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { width: valPercent + &quot;%&quot; }, o.animate );
			}
			if ( oRange === &quot;max&quot; &amp;&amp; this.orientation === &quot;horizontal&quot; ) {
				this.range[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { width: ( 100 - valPercent ) + &quot;%&quot; }, { queue: false, duration: o.animate } );
			}
			if ( oRange === &quot;min&quot; &amp;&amp; this.orientation === &quot;vertical&quot; ) {
				this.range.stop( 1, 1 )[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { height: valPercent + &quot;%&quot; }, o.animate );
			}
			if ( oRange === &quot;max&quot; &amp;&amp; this.orientation === &quot;vertical&quot; ) {
				this.range[ animate ? &quot;animate&quot; : &quot;css&quot; ]( { height: ( 100 - valPercent ) + &quot;%&quot; }, { queue: false, duration: o.animate } );
			}
		}
	}

});

$.extend( $.ui.slider, {
	version: &quot;1.8.23&quot;
});

}(jQuery));

(function( $, undefined ) {

var tabId = 0,
	listId = 0;

function getNextTabId() {
	return ++tabId;
}

function getNextListId() {
	return ++listId;
}

$.widget( &quot;ui.tabs&quot;, {
	options: {
		add: null,
		ajaxOptions: null,
		cache: false,
		cookie: null, &#x2F;&#x2F; e.g. { expires: 7, path: &#x27;&#x2F;&#x27;, domain: &#x27;jquery.com&#x27;, secure: true }
		collapsible: false,
		disable: null,
		disabled: [],
		enable: null,
		event: &quot;click&quot;,
		fx: null, &#x2F;&#x2F; e.g. { height: &#x27;toggle&#x27;, opacity: &#x27;toggle&#x27;, duration: 200 }
		idPrefix: &quot;ui-tabs-&quot;,
		load: null,
		panelTemplate: &quot;&lt;div&gt;&lt;&#x2F;div&gt;&quot;,
		remove: null,
		select: null,
		show: null,
		spinner: &quot;&lt;em&gt;Loading&amp;#8230;&lt;&#x2F;em&gt;&quot;,
		tabTemplate: &quot;&lt;li&gt;&lt;a href=&#x27;#{href}&#x27;&gt;&lt;span&gt;#{label}&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&quot;
	},

	_create: function() {
		this._tabify( true );
	},

	_setOption: function( key, value ) {
		if ( key == &quot;selected&quot; ) {
			if (this.options.collapsible &amp;&amp; value == this.options.selected ) {
				return;
			}
			this.select( value );
		} else {
			this.options[ key ] = value;
			this._tabify();
		}
	},

	_tabId: function( a ) {
		return a.title &amp;&amp; a.title.replace( &#x2F;\s&#x2F;g, &quot;_&quot; ).replace( &#x2F;[^\w\u00c0-\uFFFF-]&#x2F;g, &quot;&quot; ) ||
			this.options.idPrefix + getNextTabId();
	},

	_sanitizeSelector: function( hash ) {
		&#x2F;&#x2F; we need this because an id may contain a &quot;:&quot;
		return hash.replace( &#x2F;:&#x2F;g, &quot;\\:&quot; );
	},

	_cookie: function() {
		var cookie = this.cookie ||
			( this.cookie = this.options.cookie.name || &quot;ui-tabs-&quot; + getNextListId() );
		return $.cookie.apply( null, [ cookie ].concat( $.makeArray( arguments ) ) );
	},

	_ui: function( tab, panel ) {
		return {
			tab: tab,
			panel: panel,
			index: this.anchors.index( tab )
		};
	},

	_cleanup: function() {
		&#x2F;&#x2F; restore all former loading tabs labels
		this.lis.filter( &quot;.ui-state-processing&quot; )
			.removeClass( &quot;ui-state-processing&quot; )
			.find( &quot;span:data(label.tabs)&quot; )
				.each(function() {
					var el = $( this );
					el.html( el.data( &quot;label.tabs&quot; ) ).removeData( &quot;label.tabs&quot; );
				});
	},

	_tabify: function( init ) {
		var self = this,
			o = this.options,
			fragmentId = &#x2F;^#.+&#x2F;; &#x2F;&#x2F; Safari 2 reports &#x27;#&#x27; for an empty hash

		this.list = this.element.find( &quot;ol,ul&quot; ).eq( 0 );
		this.lis = $( &quot; &gt; li:has(a[href])&quot;, this.list );
		this.anchors = this.lis.map(function() {
			return $( &quot;a&quot;, this )[ 0 ];
		});
		this.panels = $( [] );

		this.anchors.each(function( i, a ) {
			var href = $( a ).attr( &quot;href&quot; );
			&#x2F;&#x2F; For dynamically created HTML that contains a hash as href IE &lt; 8 expands
			&#x2F;&#x2F; such href to the full page url with hash and then misinterprets tab as ajax.
			&#x2F;&#x2F; Same consideration applies for an added tab with a fragment identifier
			&#x2F;&#x2F; since a[href=#fragment-identifier] does unexpectedly not match.
			&#x2F;&#x2F; Thus normalize href attribute...
			var hrefBase = href.split( &quot;#&quot; )[ 0 ],
				baseEl;
			if ( hrefBase &amp;&amp; ( hrefBase === location.toString().split( &quot;#&quot; )[ 0 ] ||
					( baseEl = $( &quot;base&quot; )[ 0 ]) &amp;&amp; hrefBase === baseEl.href ) ) {
				href = a.hash;
				a.href = href;
			}

			&#x2F;&#x2F; inline tab
			if ( fragmentId.test( href ) ) {
				self.panels = self.panels.add( self.element.find( self._sanitizeSelector( href ) ) );
			&#x2F;&#x2F; remote tab
			&#x2F;&#x2F; prevent loading the page itself if href is just &quot;#&quot;
			} else if ( href &amp;&amp; href !== &quot;#&quot; ) {
				&#x2F;&#x2F; required for restore on destroy
				$.data( a, &quot;href.tabs&quot;, href );

				&#x2F;&#x2F; TODO until #3808 is fixed strip fragment identifier from url
				&#x2F;&#x2F; (IE fails to load from such url)
				$.data( a, &quot;load.tabs&quot;, href.replace( &#x2F;#.*$&#x2F;, &quot;&quot; ) );

				var id = self._tabId( a );
				a.href = &quot;#&quot; + id;
				var $panel = self.element.find( &quot;#&quot; + id );
				if ( !$panel.length ) {
					$panel = $( o.panelTemplate )
						.attr( &quot;id&quot;, id )
						.addClass( &quot;ui-tabs-panel ui-widget-content ui-corner-bottom&quot; )
						.insertAfter( self.panels[ i - 1 ] || self.list );
					$panel.data( &quot;destroy.tabs&quot;, true );
				}
				self.panels = self.panels.add( $panel );
			&#x2F;&#x2F; invalid tab href
			} else {
				o.disabled.push( i );
			}
		});

		&#x2F;&#x2F; initialization from scratch
		if ( init ) {
			&#x2F;&#x2F; attach necessary classes for styling
			this.element.addClass( &quot;ui-tabs ui-widget ui-widget-content ui-corner-all&quot; );
			this.list.addClass( &quot;ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all&quot; );
			this.lis.addClass( &quot;ui-state-default ui-corner-top&quot; );
			this.panels.addClass( &quot;ui-tabs-panel ui-widget-content ui-corner-bottom&quot; );

			&#x2F;&#x2F; Selected tab
			&#x2F;&#x2F; use &quot;selected&quot; option or try to retrieve:
			&#x2F;&#x2F; 1. from fragment identifier in url
			&#x2F;&#x2F; 2. from cookie
			&#x2F;&#x2F; 3. from selected class attribute on &lt;li&gt;
			if ( o.selected === undefined ) {
				if ( location.hash ) {
					this.anchors.each(function( i, a ) {
						if ( a.hash == location.hash ) {
							o.selected = i;
							return false;
						}
					});
				}
				if ( typeof o.selected !== &quot;number&quot; &amp;&amp; o.cookie ) {
					o.selected = parseInt( self._cookie(), 10 );
				}
				if ( typeof o.selected !== &quot;number&quot; &amp;&amp; this.lis.filter( &quot;.ui-tabs-selected&quot; ).length ) {
					o.selected = this.lis.index( this.lis.filter( &quot;.ui-tabs-selected&quot; ) );
				}
				o.selected = o.selected || ( this.lis.length ? 0 : -1 );
			} else if ( o.selected === null ) { &#x2F;&#x2F; usage of null is deprecated, TODO remove in next release
				o.selected = -1;
			}

			&#x2F;&#x2F; sanity check - default to first tab...
			o.selected = ( ( o.selected &gt;= 0 &amp;&amp; this.anchors[ o.selected ] ) || o.selected &lt; 0 )
				? o.selected
				: 0;

			&#x2F;&#x2F; Take disabling tabs via class attribute from HTML
			&#x2F;&#x2F; into account and update option properly.
			&#x2F;&#x2F; A selected tab cannot become disabled.
			o.disabled = $.unique( o.disabled.concat(
				$.map( this.lis.filter( &quot;.ui-state-disabled&quot; ), function( n, i ) {
					return self.lis.index( n );
				})
			) ).sort();

			if ( $.inArray( o.selected, o.disabled ) != -1 ) {
				o.disabled.splice( $.inArray( o.selected, o.disabled ), 1 );
			}

			&#x2F;&#x2F; highlight selected tab
			this.panels.addClass( &quot;ui-tabs-hide&quot; );
			this.lis.removeClass( &quot;ui-tabs-selected ui-state-active&quot; );
			&#x2F;&#x2F; check for length avoids error when initializing empty list
			if ( o.selected &gt;= 0 &amp;&amp; this.anchors.length ) {
				self.element.find( self._sanitizeSelector( self.anchors[ o.selected ].hash ) ).removeClass( &quot;ui-tabs-hide&quot; );
				this.lis.eq( o.selected ).addClass( &quot;ui-tabs-selected ui-state-active&quot; );

				&#x2F;&#x2F; seems to be expected behavior that the show callback is fired
				self.element.queue( &quot;tabs&quot;, function() {
					self._trigger( &quot;show&quot;, null,
						self._ui( self.anchors[ o.selected ], self.element.find( self._sanitizeSelector( self.anchors[ o.selected ].hash ) )[ 0 ] ) );
				});

				this.load( o.selected );
			}

			&#x2F;&#x2F; clean up to avoid memory leaks in certain versions of IE 6
			&#x2F;&#x2F; TODO: namespace this event
			$( window ).bind( &quot;unload&quot;, function() {
				self.lis.add( self.anchors ).unbind( &quot;.tabs&quot; );
				self.lis = self.anchors = self.panels = null;
			});
		&#x2F;&#x2F; update selected after add&#x2F;remove
		} else {
			o.selected = this.lis.index( this.lis.filter( &quot;.ui-tabs-selected&quot; ) );
		}

		&#x2F;&#x2F; update collapsible
		&#x2F;&#x2F; TODO: use .toggleClass()
		this.element[ o.collapsible ? &quot;addClass&quot; : &quot;removeClass&quot; ]( &quot;ui-tabs-collapsible&quot; );

		&#x2F;&#x2F; set or update cookie after init and add&#x2F;remove respectively
		if ( o.cookie ) {
			this._cookie( o.selected, o.cookie );
		}

		&#x2F;&#x2F; disable tabs
		for ( var i = 0, li; ( li = this.lis[ i ] ); i++ ) {
			$( li )[ $.inArray( i, o.disabled ) != -1 &amp;&amp;
				&#x2F;&#x2F; TODO: use .toggleClass()
				!$( li ).hasClass( &quot;ui-tabs-selected&quot; ) ? &quot;addClass&quot; : &quot;removeClass&quot; ]( &quot;ui-state-disabled&quot; );
		}

		&#x2F;&#x2F; reset cache if switching from cached to not cached
		if ( o.cache === false ) {
			this.anchors.removeData( &quot;cache.tabs&quot; );
		}

		&#x2F;&#x2F; remove all handlers before, tabify may run on existing tabs after add or option change
		this.lis.add( this.anchors ).unbind( &quot;.tabs&quot; );

		if ( o.event !== &quot;mouseover&quot; ) {
			var addState = function( state, el ) {
				if ( el.is( &quot;:not(.ui-state-disabled)&quot; ) ) {
					el.addClass( &quot;ui-state-&quot; + state );
				}
			};
			var removeState = function( state, el ) {
				el.removeClass( &quot;ui-state-&quot; + state );
			};
			this.lis.bind( &quot;mouseover.tabs&quot; , function() {
				addState( &quot;hover&quot;, $( this ) );
			});
			this.lis.bind( &quot;mouseout.tabs&quot;, function() {
				removeState( &quot;hover&quot;, $( this ) );
			});
			this.anchors.bind( &quot;focus.tabs&quot;, function() {
				addState( &quot;focus&quot;, $( this ).closest( &quot;li&quot; ) );
			});
			this.anchors.bind( &quot;blur.tabs&quot;, function() {
				removeState( &quot;focus&quot;, $( this ).closest( &quot;li&quot; ) );
			});
		}

		&#x2F;&#x2F; set up animations
		var hideFx, showFx;
		if ( o.fx ) {
			if ( $.isArray( o.fx ) ) {
				hideFx = o.fx[ 0 ];
				showFx = o.fx[ 1 ];
			} else {
				hideFx = showFx = o.fx;
			}
		}

		&#x2F;&#x2F; Reset certain styles left over from animation
		&#x2F;&#x2F; and prevent IE&#x27;s ClearType bug...
		function resetStyle( $el, fx ) {
			$el.css( &quot;display&quot;, &quot;&quot; );
			if ( !$.support.opacity &amp;&amp; fx.opacity ) {
				$el[ 0 ].style.removeAttribute( &quot;filter&quot; );
			}
		}

		&#x2F;&#x2F; Show a tab...
		var showTab = showFx
			? function( clicked, $show ) {
				$( clicked ).closest( &quot;li&quot; ).addClass( &quot;ui-tabs-selected ui-state-active&quot; );
				$show.hide().removeClass( &quot;ui-tabs-hide&quot; ) &#x2F;&#x2F; avoid flicker that way
					.animate( showFx, showFx.duration || &quot;normal&quot;, function() {
						resetStyle( $show, showFx );
						self._trigger( &quot;show&quot;, null, self._ui( clicked, $show[ 0 ] ) );
					});
			}
			: function( clicked, $show ) {
				$( clicked ).closest( &quot;li&quot; ).addClass( &quot;ui-tabs-selected ui-state-active&quot; );
				$show.removeClass( &quot;ui-tabs-hide&quot; );
				self._trigger( &quot;show&quot;, null, self._ui( clicked, $show[ 0 ] ) );
			};

		&#x2F;&#x2F; Hide a tab, $show is optional...
		var hideTab = hideFx
			? function( clicked, $hide ) {
				$hide.animate( hideFx, hideFx.duration || &quot;normal&quot;, function() {
					self.lis.removeClass( &quot;ui-tabs-selected ui-state-active&quot; );
					$hide.addClass( &quot;ui-tabs-hide&quot; );
					resetStyle( $hide, hideFx );
					self.element.dequeue( &quot;tabs&quot; );
				});
			}
			: function( clicked, $hide, $show ) {
				self.lis.removeClass( &quot;ui-tabs-selected ui-state-active&quot; );
				$hide.addClass( &quot;ui-tabs-hide&quot; );
				self.element.dequeue( &quot;tabs&quot; );
			};

		&#x2F;&#x2F; attach tab event handler, unbind to avoid duplicates from former tabifying...
		this.anchors.bind( o.event + &quot;.tabs&quot;, function() {
			var el = this,
				$li = $(el).closest( &quot;li&quot; ),
				$hide = self.panels.filter( &quot;:not(.ui-tabs-hide)&quot; ),
				$show = self.element.find( self._sanitizeSelector( el.hash ) );

			&#x2F;&#x2F; If tab is already selected and not collapsible or tab disabled or
			&#x2F;&#x2F; or is already loading or click callback returns false stop here.
			&#x2F;&#x2F; Check if click handler returns false last so that it is not executed
			&#x2F;&#x2F; for a disabled or loading tab!
			if ( ( $li.hasClass( &quot;ui-tabs-selected&quot; ) &amp;&amp; !o.collapsible) ||
				$li.hasClass( &quot;ui-state-disabled&quot; ) ||
				$li.hasClass( &quot;ui-state-processing&quot; ) ||
				self.panels.filter( &quot;:animated&quot; ).length ||
				self._trigger( &quot;select&quot;, null, self._ui( this, $show[ 0 ] ) ) === false ) {
				this.blur();
				return false;
			}

			o.selected = self.anchors.index( this );

			self.abort();

			&#x2F;&#x2F; if tab may be closed
			if ( o.collapsible ) {
				if ( $li.hasClass( &quot;ui-tabs-selected&quot; ) ) {
					o.selected = -1;

					if ( o.cookie ) {
						self._cookie( o.selected, o.cookie );
					}

					self.element.queue( &quot;tabs&quot;, function() {
						hideTab( el, $hide );
					}).dequeue( &quot;tabs&quot; );

					this.blur();
					return false;
				} else if ( !$hide.length ) {
					if ( o.cookie ) {
						self._cookie( o.selected, o.cookie );
					}

					self.element.queue( &quot;tabs&quot;, function() {
						showTab( el, $show );
					});

					&#x2F;&#x2F; TODO make passing in node possible, see also http:&#x2F;&#x2F;dev.jqueryui.com&#x2F;ticket&#x2F;3171
					self.load( self.anchors.index( this ) );

					this.blur();
					return false;
				}
			}

			if ( o.cookie ) {
				self._cookie( o.selected, o.cookie );
			}

			&#x2F;&#x2F; show new tab
			if ( $show.length ) {
				if ( $hide.length ) {
					self.element.queue( &quot;tabs&quot;, function() {
						hideTab( el, $hide );
					});
				}
				self.element.queue( &quot;tabs&quot;, function() {
					showTab( el, $show );
				});

				self.load( self.anchors.index( this ) );
			} else {
				throw &quot;jQuery UI Tabs: Mismatching fragment identifier.&quot;;
			}

			&#x2F;&#x2F; Prevent IE from keeping other link focussed when using the back button
			&#x2F;&#x2F; and remove dotted border from clicked link. This is controlled via CSS
			&#x2F;&#x2F; in modern browsers; blur() removes focus from address bar in Firefox
			&#x2F;&#x2F; which can become a usability and annoying problem with tabs(&#x27;rotate&#x27;).
			if ( $.browser.msie ) {
				this.blur();
			}
		});

		&#x2F;&#x2F; disable click in any case
		this.anchors.bind( &quot;click.tabs&quot;, function(){
			return false;
		});
	},

    _getIndex: function( index ) {
		&#x2F;&#x2F; meta-function to give users option to provide a href string instead of a numerical index.
		&#x2F;&#x2F; also sanitizes numerical indexes to valid values.
		if ( typeof index == &quot;string&quot; ) {
			index = this.anchors.index( this.anchors.filter( &quot;[href$=&#x27;&quot; + index + &quot;&#x27;]&quot; ) );
		}

		return index;
	},

	destroy: function() {
		var o = this.options;

		this.abort();

		this.element
			.unbind( &quot;.tabs&quot; )
			.removeClass( &quot;ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible&quot; )
			.removeData( &quot;tabs&quot; );

		this.list.removeClass( &quot;ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all&quot; );

		this.anchors.each(function() {
			var href = $.data( this, &quot;href.tabs&quot; );
			if ( href ) {
				this.href = href;
			}
			var $this = $( this ).unbind( &quot;.tabs&quot; );
			$.each( [ &quot;href&quot;, &quot;load&quot;, &quot;cache&quot; ], function( i, prefix ) {
				$this.removeData( prefix + &quot;.tabs&quot; );
			});
		});

		this.lis.unbind( &quot;.tabs&quot; ).add( this.panels ).each(function() {
			if ( $.data( this, &quot;destroy.tabs&quot; ) ) {
				$( this ).remove();
			} else {
				$( this ).removeClass([
					&quot;ui-state-default&quot;,
					&quot;ui-corner-top&quot;,
					&quot;ui-tabs-selected&quot;,
					&quot;ui-state-active&quot;,
					&quot;ui-state-hover&quot;,
					&quot;ui-state-focus&quot;,
					&quot;ui-state-disabled&quot;,
					&quot;ui-tabs-panel&quot;,
					&quot;ui-widget-content&quot;,
					&quot;ui-corner-bottom&quot;,
					&quot;ui-tabs-hide&quot;
				].join( &quot; &quot; ) );
			}
		});

		if ( o.cookie ) {
			this._cookie( null, o.cookie );
		}

		return this;
	},

	add: function( url, label, index ) {
		if ( index === undefined ) {
			index = this.anchors.length;
		}

		var self = this,
			o = this.options,
			$li = $( o.tabTemplate.replace( &#x2F;#\{href\}&#x2F;g, url ).replace( &#x2F;#\{label\}&#x2F;g, label ) ),
			id = !url.indexOf( &quot;#&quot; ) ? url.replace( &quot;#&quot;, &quot;&quot; ) : this._tabId( $( &quot;a&quot;, $li )[ 0 ] );

		$li.addClass( &quot;ui-state-default ui-corner-top&quot; ).data( &quot;destroy.tabs&quot;, true );

		&#x2F;&#x2F; try to find an existing element before creating a new one
		var $panel = self.element.find( &quot;#&quot; + id );
		if ( !$panel.length ) {
			$panel = $( o.panelTemplate )
				.attr( &quot;id&quot;, id )
				.data( &quot;destroy.tabs&quot;, true );
		}
		$panel.addClass( &quot;ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide&quot; );

		if ( index &gt;= this.lis.length ) {
			$li.appendTo( this.list );
			$panel.appendTo( this.list[ 0 ].parentNode );
		} else {
			$li.insertBefore( this.lis[ index ] );
			$panel.insertBefore( this.panels[ index ] );
		}

		o.disabled = $.map( o.disabled, function( n, i ) {
			return n &gt;= index ? ++n : n;
		});

		this._tabify();

		if ( this.anchors.length == 1 ) {
			o.selected = 0;
			$li.addClass( &quot;ui-tabs-selected ui-state-active&quot; );
			$panel.removeClass( &quot;ui-tabs-hide&quot; );
			this.element.queue( &quot;tabs&quot;, function() {
				self._trigger( &quot;show&quot;, null, self._ui( self.anchors[ 0 ], self.panels[ 0 ] ) );
			});

			this.load( 0 );
		}

		this._trigger( &quot;add&quot;, null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		return this;
	},

	remove: function( index ) {
		index = this._getIndex( index );
		var o = this.options,
			$li = this.lis.eq( index ).remove(),
			$panel = this.panels.eq( index ).remove();

		&#x2F;&#x2F; If selected tab was removed focus tab to the right or
		&#x2F;&#x2F; in case the last tab was removed the tab to the left.
		if ( $li.hasClass( &quot;ui-tabs-selected&quot; ) &amp;&amp; this.anchors.length &gt; 1) {
			this.select( index + ( index + 1 &lt; this.anchors.length ? 1 : -1 ) );
		}

		o.disabled = $.map(
			$.grep( o.disabled, function(n, i) {
				return n != index;
			}),
			function( n, i ) {
				return n &gt;= index ? --n : n;
			});

		this._tabify();

		this._trigger( &quot;remove&quot;, null, this._ui( $li.find( &quot;a&quot; )[ 0 ], $panel[ 0 ] ) );
		return this;
	},

	enable: function( index ) {
		index = this._getIndex( index );
		var o = this.options;
		if ( $.inArray( index, o.disabled ) == -1 ) {
			return;
		}

		this.lis.eq( index ).removeClass( &quot;ui-state-disabled&quot; );
		o.disabled = $.grep( o.disabled, function( n, i ) {
			return n != index;
		});

		this._trigger( &quot;enable&quot;, null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		return this;
	},

	disable: function( index ) {
		index = this._getIndex( index );
		var self = this, o = this.options;
		&#x2F;&#x2F; cannot disable already selected tab
		if ( index != o.selected ) {
			this.lis.eq( index ).addClass( &quot;ui-state-disabled&quot; );

			o.disabled.push( index );
			o.disabled.sort();

			this._trigger( &quot;disable&quot;, null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		}

		return this;
	},

	select: function( index ) {
		index = this._getIndex( index );
		if ( index == -1 ) {
			if ( this.options.collapsible &amp;&amp; this.options.selected != -1 ) {
				index = this.options.selected;
			} else {
				return this;
			}
		}
		this.anchors.eq( index ).trigger( this.options.event + &quot;.tabs&quot; );
		return this;
	},

	load: function( index ) {
		index = this._getIndex( index );
		var self = this,
			o = this.options,
			a = this.anchors.eq( index )[ 0 ],
			url = $.data( a, &quot;load.tabs&quot; );

		this.abort();

		&#x2F;&#x2F; not remote or from cache
		if ( !url || this.element.queue( &quot;tabs&quot; ).length !== 0 &amp;&amp; $.data( a, &quot;cache.tabs&quot; ) ) {
			this.element.dequeue( &quot;tabs&quot; );
			return;
		}

		&#x2F;&#x2F; load remote from here on
		this.lis.eq( index ).addClass( &quot;ui-state-processing&quot; );

		if ( o.spinner ) {
			var span = $( &quot;span&quot;, a );
			span.data( &quot;label.tabs&quot;, span.html() ).html( o.spinner );
		}

		this.xhr = $.ajax( $.extend( {}, o.ajaxOptions, {
			url: url,
			success: function( r, s ) {
				self.element.find( self._sanitizeSelector( a.hash ) ).html( r );

				&#x2F;&#x2F; take care of tab labels
				self._cleanup();

				if ( o.cache ) {
					$.data( a, &quot;cache.tabs&quot;, true );
				}

				self._trigger( &quot;load&quot;, null, self._ui( self.anchors[ index ], self.panels[ index ] ) );
				try {
					o.ajaxOptions.success( r, s );
				}
				catch ( e ) {}
			},
			error: function( xhr, s, e ) {
				&#x2F;&#x2F; take care of tab labels
				self._cleanup();

				self._trigger( &quot;load&quot;, null, self._ui( self.anchors[ index ], self.panels[ index ] ) );
				try {
					&#x2F;&#x2F; Passing index avoid a race condition when this method is
					&#x2F;&#x2F; called after the user has selected another tab.
					&#x2F;&#x2F; Pass the anchor that initiated this request allows
					&#x2F;&#x2F; loadError to manipulate the tab content panel via $(a.hash)
					o.ajaxOptions.error( xhr, s, index, a );
				}
				catch ( e ) {}
			}
		} ) );

		&#x2F;&#x2F; last, so that load event is fired before show...
		self.element.dequeue( &quot;tabs&quot; );

		return this;
	},

	abort: function() {
		&#x2F;&#x2F; stop possibly running animations
		this.element.queue( [] );
		this.panels.stop( false, true );

		&#x2F;&#x2F; &quot;tabs&quot; queue must not contain more than two elements,
		&#x2F;&#x2F; which are the callbacks for the latest clicked tab...
		this.element.queue( &quot;tabs&quot;, this.element.queue( &quot;tabs&quot; ).splice( -2, 2 ) );

		&#x2F;&#x2F; terminate pending requests from other tabs
		if ( this.xhr ) {
			this.xhr.abort();
			delete this.xhr;
		}

		&#x2F;&#x2F; take care of tab labels
		this._cleanup();
		return this;
	},

	url: function( index, url ) {
		this.anchors.eq( index ).removeData( &quot;cache.tabs&quot; ).data( &quot;load.tabs&quot;, url );
		return this;
	},

	length: function() {
		return this.anchors.length;
	}
});

$.extend( $.ui.tabs, {
	version: &quot;1.8.23&quot;
});

&#x2F;*
 * Tabs Extensions
 *&#x2F;

&#x2F;*
 * Rotate
 *&#x2F;
$.extend( $.ui.tabs.prototype, {
	rotation: null,
	rotate: function( ms, continuing ) {
		var self = this,
			o = this.options;

		var rotate = self._rotate || ( self._rotate = function( e ) {
			clearTimeout( self.rotation );
			self.rotation = setTimeout(function() {
				var t = o.selected;
				self.select( ++t &lt; self.anchors.length ? t : 0 );
			}, ms );
			
			if ( e ) {
				e.stopPropagation();
			}
		});

		var stop = self._unrotate || ( self._unrotate = !continuing
			? function(e) {
				if (e.clientX) { &#x2F;&#x2F; in case of a true click
					self.rotate(null);
				}
			}
			: function( e ) {
				rotate();
			});

		&#x2F;&#x2F; start rotation
		if ( ms ) {
			this.element.bind( &quot;tabsshow&quot;, rotate );
			this.anchors.bind( o.event + &quot;.tabs&quot;, stop );
			rotate();
		&#x2F;&#x2F; stop rotation
		} else {
			clearTimeout( self.rotation );
			this.element.unbind( &quot;tabsshow&quot;, rotate );
			this.anchors.unbind( o.event + &quot;.tabs&quot;, stop );
			delete this._rotate;
			delete this._unrotate;
		}

		return this;
	}
});

})( jQuery );

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
